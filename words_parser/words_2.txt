sufficient|sentence cnt : 4 <br> <br>1. They give sufficient implementation of both searchand insert.<br><br>2. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>3. What we want is sufficient implementationsof both search and insert.<br><br>4. So, that's a fine implementation of QuickFind so the nextthing to decide is how effective or efficient that algorithm is going to beand we'll talk in some detail about how to do that but for this it's sufficient tojust think about the number of times the code has to access the array.<br>
secure|sentence cnt : 1 <br> <br>1. And so the, it's the concept of so called one way hash functions whichmean that we, we, use it for secure to try to be, have some secure fingerprints foruse on the web.<br>
tosses|sentence cnt : 1 <br> <br>1. After about natural log M tosses,every bin has at least one ball.<br>
leans|sentence cnt : 1 <br> <br>1. [cough] so, in this case, we have the right link of E points to S and Sis red so that's a right-leaning red link and so now that's the before and what wewant to do is reorient things so that it leans to the left.<br>
particularly|sentence cnt : 7 <br> <br>1. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>2. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>3. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>4. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>5. It's a very efficient andsimple data structure for processing k dimensional datathat's very widely used and the whole idea is that data clusters,particularly in high dimensions.<br><br>6. The designers found that the cost of computing the hashfunction for strings seemed to be excessive, particularly for long strings.<br><br>7. Now as alpha gets close toone, you can see these things are going to grow, and particularly the search miss isgrowing to grow quite, quite a bit.<br>
multiply|sentence cnt : 6 <br> <br>1. So we pick some othersmall prime number and for each field we multiply by 31.<br><br>2. Where for each digit, you just multiply.<br><br>3. And if it's plus, add the resultof the two values at the top of the value stack and if it's a star, multiply the twovalues on the top of the stack and, and then push the result.<br><br>4. First thing we do is just multiply by Nand collect terms.<br><br>5. The zero keys are going to be zero on the dot product sowhat we're going to do is take the item key of the vector and multiply it bywhatever value we get for the non-zero entries.<br><br>6. And to compute that wholenumber you multiply 31 times what you have so far andadd the next digit.<br>
minutes|sentence cnt : 2 <br> <br>1.Even on your PC you can sort huge array of a million items in less then a second anda million items in only a few minutes.<br><br>2. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br>
becker|sentence cnt : 1 <br> <br>1. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
conceivable|sentence cnt : 1 <br> <br>1. And we can keep the root page in memory so that it means, for anyconceivable application, you can get to any piece of data.<br>
certain|sentence cnt : 29 <br> <br>1. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>2. Say,university has student records and for every student there is a certain amount ofinformation.<br><br>3. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>4.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>5. It's certainly worth adding them.<br><br>6.You, you can't have [cough] lines that come too close to other lines, certaintypes of lines can't intersect.<br><br>7. And actually there is avalue as N gets large that if you're less than that value it almost certainly willnot percolate, if you're greater it almost certainly will.<br><br>8. And certain codons have names, that's theamino acids.<br>
falling|sentence cnt : 1 <br> <br>1. If we get to the bottom and our current nodeis null and that's falling off the bottom of the tree we return null and that'sequivalent to saying our buyer convention that, that key is not in our datastructure, or not in our symbol table.<br>
from|sentence cnt : 212 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>3. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>4.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>5. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>6. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>7. And so, this client readsstrings from standard input.<br><br>8. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br>
someday|sentence cnt : 2 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. And so, there is still the goal of a, of afast guaranteed linear time selection algorithm maybe somebody in this classwill invent someday.<br>
said|sentence cnt : 6 <br> <br>1. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>2. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>3. What's the implementation of an exception filters?Here's a simple one using the said API that we just articulated.<br><br>4. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>5. Don Knuth who wrote several books on, on algorithmsand was a pioneer in the field said that, "An algorithm must be seen to bebelieved.<br><br>6. Well, at thatpoint we said we only do that if the size of T2 was bigger than the or equal to sizeof T1.<br>
differ|sentence cnt : 121 <br> <br>1. We have two different stacks.<br><br>2. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>3. So, one thing is we're usinga different key interface.<br><br>4. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>5. So that's three different clients, three completelydifferent types of data.<br><br>6. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>7. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>8. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br>
kevin|sentence cnt : 2 <br> <br>1. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>2. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br>
surprising|sentence cnt : 4 <br> <br>1.Now, we're not going to be able to really implement that in a computer program butit's surprising how well we can do.<br><br>2. And there's anothersurprising situation that happens in today's world.<br><br>3.And, it's a extremely, simple algorithim, but surprisingly, complicated tounderstand, so we'll go slowly.<br><br>4. And, surprisingly binary search trees and these associatedalgorithms that we've looked at are going to provide very efficient solutions to anumber of important problems in this area.<br>
specific|sentence cnt : 8 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>2. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>3. There's a lot of different ways toimplement callbacks and that's programming language specific.<br><br>4. If you want that you have to providethat as a specific operation but in the case of symbol tableswe're not going to do that, you'd have to remove it andput it back in.<br><br>5. And specifically, the work we do is, weadd the key to a 3-node to create a temporary 4-node and then split up thatfour node and move it's middle key into the parent.<br><br>6. All of that leads up to, in a programmingworld to specifying, a data type which is simply specification of the methods thatwe are want to going to implement in order to solve this problem.<br><br>7. Now a specific example that really shows this off and also will illustratethe utility of being able to process multiple types of data with the same codeis this example is Dijkstra's two-stack algorithm for arithmetic expressionevaluation.<br><br>8. And this is the specific math that gets that implemented.<br>
assured|sentence cnt : 1 <br> <br>1. So rest assured these types ofalgorithms lie at the heart of any program you use that isinvolving a lot of geometric data.<br>
costs|sentence cnt : 4 <br> <br>1. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>2. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br><br>3. But still again, using theory as a guide maybe there's a way to decrease costs a little bit from binary heaps.<br><br>4. The call, or operations have costs that'sproportional to the path link from the, height to the bottom, and every path fromthe root to a null link has the same length.<br>
functional|sentence cnt : 5 <br> <br>1. But we can also provide a lot of convenient functionalityfor the client that's what we are going to look at next.<br><br>2. So, a very smallamount of code based on a symbol table implementation that gives us thedictionary functionality.<br><br>3. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>4. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br><br>5. Again, quite useful and familiarfunctionality and very easy to implement with our simul tableclient.<br>
wayne|sentence cnt : 2 <br> <br>1. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>2. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br>
macros|sentence cnt : 1 <br> <br>1. So very inexpensive and they had macros to do this so and use not too muchcost to find a partitioning element that's much closer to the middle than, and if youuse a, a random one.<br>
keyword|sentence cnt : 1 <br> <br>1. Web search is something that weall do multiple times everyday and the key is a keyword ora list of key words and the value is a list of placeswhere that key word is found.<br>
exact|sentence cnt : 38 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. This gives exactly what happens duringeach of the calls to merge.<br><br>3. Again, exactly as what would happen in a2-3 tree.<br><br>4. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br><br>5. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>6. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br><br>7.And the exact number they use is not too, critical.<br><br>8. Sothat, that means you'd have, if you did exactly and [inaudible] + n/2 + n/4 and soforth which adds up to about two N compare so linear cross.<br>
pops|sentence cnt : 6 <br> <br>1.And if it's not a CCW turn, it pops and then continues going.<br><br>2. We didn't put in code to throwan exception if the client pops from an empty stack.<br><br>3. So how are we going to grow andshrink the array? Well, first thing you might think of is,when the client pushes a new item onto the stack, increase the size ofthe array by 1, and when it pops, decrease the size of the array by 1.<br><br>4. But the advantage that weget is very fast pushes and pops, just access array and increment it,and very efficient for most operations.<br><br>5. And then, it's up to the client when it pops something off theapple stacks to cast at the apple to keep the type checking system happy.<br><br>6. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br>
hoping|sentence cnt : 1 <br> <br>1. In this care we're kind of hoping forrandomness and maybe that doesn't really always hold.<br>
practitioners|sentence cnt : 1 <br> <br>1. There's versions ofmerge sort that come close but they are too complex for practitioners to haveadopted them.<br>
organize|sentence cnt : 3 <br> <br>1. Maybe the way yourcomputer's memory is organized make a difference.<br><br>2. And that's just the way it organized.<br><br>3. And then, what the priority queue tells us is - let's organize it in some ways that we are always taking the best one to processnext.<br>
merges|sentence cnt : 67 <br> <br>1. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>2.Mergesort is not only efficient, it's also.<br><br>3. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>4. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>5. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>6. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>7. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>8. It uses actually both quicksort and mergesort.<br>
inadequate|sentence cnt : 1 <br> <br>1. We saw a few easy algorithms for solving theproblem, and quickly saw that they were inadequate for addressing huge problems.<br>
interacting|sentence cnt : 2 <br> <br>1. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>2. And basically, the computation is based on computing the interacting force foreach pair of particles.<br>
reads|sentence cnt : 4 <br> <br>1. And so, this client readsstrings from standard input.<br><br>2. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>3.And in this case it reads the strings from a file using our readStrings() method inour In class that which takes a file as argument.<br><br>4. So that's read this loop,reads in all the data and associates each word withits frequency of occurrence.<br>
coordinates|sentence cnt : 12 <br> <br>1. So, we're going to keep trackof y coordinates in a binary search tree.<br><br>2. And again, to keep the code simplewe're going to assume that all the coordinates are distinct.<br><br>3. Simply divide both coordinates by M, andthen look in the two-dimensional array.<br><br>4. And on the right, we put the points whoseith coordinates are greater than p.<br><br>5. So again, just aswith, line intersection search, using a priority queue or a sort is only N log Nfor processing the X coordinates.<br><br>6. So, the BST contains the y coordinates of all the horizontal linesthat currently might involve an intersection.<br><br>7. So, the point with thelowest y coordinates on the convex hull and shows the one that is the smallestpolar angle that creates with the x-axis.<br><br>8. And then putting the y coordinates into, into a binary search tree is, again,N log N.<br>
decrements|sentence cnt : 2 <br> <br>1. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br><br>2.The j pointer decrements until it gets to the c which it stops there which is lessthan the partitioning element.<br>
reorient|sentence cnt : 2 <br> <br>1. [cough] so, in this case, we have the right link of E points to S and Sis red so that's a right-leaning red link and so now that's the before and what wewant to do is reorient things so that it leans to the left.<br><br>2. And so we'll needwhat's called a left rotation, and the job of that operation is to take a, a rightleaning red link that is there for whatever reason and reorient it to lean tothe left.<br>
creates|sentence cnt : 9 <br> <br>1. And then the actual sort is takes just theone argument of the array creates the auxiliary arrayand then uses that.<br><br>2. So this creates a new symbol table associating string keys with sets offiles.<br><br>3. So, that creates a connection between five andzero.<br><br>4. Seven and two creates a connection between seven and two.<br><br>5. This one has a constructor, andthe constructor creates the array.<br><br>6. And for strings, it kind of createsthe string as a huge number and then,really computes the value of that number.<br><br>7. So, the point with thelowest y coordinates on the convex hull and shows the one that is the smallestpolar angle that creates with the x-axis.<br><br>8.We convert that 3-node into a temporary 4-node, but then we need to split that4-node moving E to the parent and that creates a new, root node and increases thesize of the tree by one, But now that's a legal 2-3 tree so we stop.<br>
harder|sentence cnt : 1 <br> <br>1. And again, that's a little harder to do withsomething like a red black tree where we have performance guarantees.<br>
efficiently|sentence cnt : 18 <br> <br>1. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>2. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>3.And how can we do it efficiently that is in, in log N time versus quadratic time.<br><br>4. So we can,implement these, efficiently and they are, convenient and useful for the clients.<br><br>5. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>6. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br><br>7. It can't maintain a dynamic table efficiently with binarysearch and that's going to be your focus in the next lecture.<br><br>8. Where's the closest thing? How am I going to findthe closest thing efficiently? What things are nearby and so forth.<br>
courses|sentence cnt : 1 <br> <br>1. Actually years ago when we taught coursesin algorithms and data structures, much of the course would be aboutthis kind of pointer manipulation.<br>
white|sentence cnt : 7 <br> <br>1. The white is the unoccupied part.<br><br>2. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>3.So that's an example of a white list filter.<br><br>4. So the system at the left, you can find a way to get fromthe top to the bottom through white squares, but the system to the right doesnot percolate, there's no way to get from the top to the bottom through whitesquares.<br><br>5. That's white in the diagram with probablyP or blocked, that's black of the diagram with probability one - P and we define asystem to, we say that a system is percolated if the top and the bottom areconnected by open sites.<br><br>6. So, that's the fullcode in white for implementing quick union.<br><br>7. One is so-called White Listing where we want to take the words in that fileand, and then we have some other much bigger file.<br>
goal|sentence cnt : 14 <br> <br>1. So the goal is socalled three way partitioning.<br><br>2. So, more generally, here's the goal.<br><br>3. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>4. So the goal is, you got an arithmetic expression this is justactually like a simple stand in for a program and we'll talk about that in asecond but let's say, arithmetic expressions.<br><br>5.And now we've achieved the goal of partitioning the array.<br><br>6. But anyway, those arereasonable goals.<br><br>7. And one of the things we'll look at is algorithms thatcome very, very close to achieving that goal.<br><br>8. And so, there is still the goal of a, of afast guaranteed linear time selection algorithm maybe somebody in this classwill invent someday.<br>
recommend|sentence cnt : 2 <br> <br>1. The other thing that's possible to do andit's a little mind bending so recommended only for experts.<br><br>2. So our best practice that we recommend is so few thatthese basic data structures that we use and there's so simple is to go ahead anduse the implementations that we've just discussed for these fundamental datastructures.<br>
largest|sentence cnt : 33 <br> <br>1. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>2. Andfor example, the largest of all the keys is at the root.<br><br>3. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>4. Give me the minimum key, give me the largest key, andthen I can get the value associated with that using that.<br><br>5. So now that's one step in the sort, we got the largest element off.<br><br>6. Well so, we arelooking for the largest key that's less than G.<br><br>7. Delete the minimum key, delete the largest key.<br><br>8. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br>
import|sentence cnt : 59 <br> <br>1. There's lots of importantapplications for this.<br><br>2. But more important, there's code, there's exercises, tere's agreat deal of information there.<br><br>3. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>4. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>5. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>6. And also in all different typesof scientific data processing, these things are extremely important.<br><br>7. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>8. This is historically, an extremely, important problem.<br>
fuller|sentence cnt : 1 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br>
database|sentence cnt : 7 <br> <br>1.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>2. And this is a very common operation, say, in databases.<br><br>3. And even if it's not points in the plane,just databases.<br><br>4. Sql or Oracles database and others,are based on, some variant of B-trees because they're so, so effective.<br><br>5. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br><br>6. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>7. In mostdatabases, nowadays that, that you might use.<br>
proving|sentence cnt : 1 <br> <br>1. So, here's the basic idea for proving a lower bound forsorting.<br>
restriction|sentence cnt : 1 <br> <br>1. And, and the only other restrictionis that, we don't want the nodes to get too empty.<br>
okay|sentence cnt : 29 <br> <br>1. Okay, X7 is a new value.<br><br>2. Okay? Yup.<br><br>3. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>4.And okay, that's fine and you're going to see that when you do compiles using codelike these.<br><br>5. So left subtreeis [inaudible] right, okay? Otherwise, we have to check whether the max endpoint inthe left subtree is less than, the low point in our interval.<br><br>6. Okay then,it's one of the detail that Java takes care of and that's what about primitivetypes [cough] so the generic type that we're using is for objects and you know,we're casting down from array of objects.<br><br>7. Shell's original idea is to try powers to two minus one andthat works okay.<br><br>8.Okay? And that's the legal of 2-3 trees, So we stop inserting A into that.<br>
heart|sentence cnt : 2 <br> <br>1. We start our I pointer at the left hearton the left half.<br><br>2. So rest assured these types ofalgorithms lie at the heart of any program you use that isinvolving a lot of geometric data.<br>
formed|sentence cnt : 5 <br> <br>1. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>2. And then we did a right rotate on the top node, and that transformed to thecase where our temporary four node is balanced.<br><br>3. And the bottom line is that we can articulate anAPI for generic stacks that works for any type of data and we've got twoimplementations, link list and arrays that, that performed very well for [cough]any type of data using the, the resizing or link list as we've described.<br><br>4. We get this most complicated case we did a left rotate onthe bottom node and that, that transformed it to this case where they're both leaningleft.<br><br>5. So for example, in this set of ten objects, weperformed already, a bunch of union commands, connecting four and three, threeand eight, six and five, nine and four, two and one.<br>
access|sentence cnt : 21 <br> <br>1. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>2. So to insert N items,it's about three array accesses.<br><br>3. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>4. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>5. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>6. Wehave constant time access to every element, but the space is proportional toN.<br><br>7. We're only counting the number oftimes we access the pages.<br><br>8. And what that mans is that all we can use iscompare, that's the only way we can access the data.<br>
review|sentence cnt : 4 <br> <br>1. So here's the review of where we were withsingle tables.<br><br>2. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br><br>3. If you want to review the material that we think isprerequisite for the material in this course, you can do a quick review bylooking at sections 1.<br><br>4. If you're not familiar with linked lists, you'll need to review that insection 1.<br>
amount|sentence cnt : 25 <br> <br>1. There's a, alarge amount of data.<br><br>2. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>3. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>4.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>5. So, this has got the same amount of information.<br><br>6. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>7. Say,university has student records and for every student there is a certain amount ofinformation.<br><br>8. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br>
dump|sentence cnt : 1 <br> <br>1. And simple algorithms like insertions or dump,they've they don't use any extra space at all.<br>
extension|sentence cnt : 4 <br> <br>1. It's a little bit of anextension of the ordered symbol table API that we gave before and we're going tohave operations range-search and range-count.<br><br>2. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br><br>3.Now we're going to look at k-d trees,which is an extension of BSTs that allow us to do efficientprocessing of sets of points in space.<br><br>4.Okay next we're gonna look at anotherextension of geometric algorithms to process slightly more complicated objectsand then we'll see an important application.<br>
shrink|sentence cnt : 6 <br> <br>1. Now we have, what about the pop, we haveto think about how to shrink the array.<br><br>2. How do we, we do not implementing the API? The API says we should justbe able to create a stack and it should be able to grow andshrink to any size.<br><br>3. And it doesn't shrink back to four untilafter there's only two items in there, and then it shrinks, and so forth.<br><br>4. So how are we going to grow andshrink the array? Well, first thing you might think of is,when the client pushes a new item onto the stack, increase the size ofthe array by 1, and when it pops, decrease the size of the array by 1.<br><br>5. And so then at that point,it's half full, and it can either grow by adding stuff orshrink by subtracting stuff.<br><br>6. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br>
algorithim|sentence cnt : 3 <br> <br>1. In fact,a pr ogrammer might ask, why study anything else? Well, there's plenty ofgood reasons to study other things, but I'll submit there's no good reason not tostudy algorithims.<br><br>2.And, it's a extremely, simple algorithim, but surprisingly, complicated tounderstand, so we'll go slowly.<br><br>3. Okay, with this concrete demo in mind then moving tocoding up this algorithim is pretty straight forward.<br>
leads|sentence cnt : 9 <br> <br>1. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>2. And it just leads to a lotof interesting questions.<br><br>3. So, why we are interested in this algorithm? Well, it's a simple ideathat leads to substantial performance gains.<br><br>4. We're going to stick to thisassociative array abstraction and no duplicate keys in the symbol table, because it both simplifies implementationsand leads to simpler client code.<br><br>5. All of that leads up to, in a programmingworld to specifying, a data type which is simply specification of the methods thatwe are want to going to implement in order to solve this problem.<br><br>6. There's another facility that Javaprovides that leads to very elegant compact client code that's definitelyworthwhile to add to our basic data types and that's iteration, that's what we'regoing to talk about now.<br><br>7. But if we're going to be implementingsymbol with our own types of data we're going to have to worry about thesethings in order to get a hash function that's effective, that leads toan effective symbol table implementation.<br><br>8. And that leads todifferent types of clients, different types of implementations.<br>
trickier|sentence cnt : 1 <br> <br>1. In this case it's a bit trickier to affix thesituation, what we do is we rotate the bottom link left.<br>
excited|sentence cnt : 3 <br> <br>1. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br><br>2. I didn't know he spend his time doing that But he was veryexcited because he saw this clip.<br><br>3. He was quiteexcited because he was watching a re-run on, of an English actually Canadian TVshow on French TV.<br>
reached|sentence cnt : 1 <br> <br>1. The client might have a lot of stacks thatneed to be maintained simultaneously and maybe they reached their maximumcapacities at different times and various other things.<br>
indicated|sentence cnt : 3 <br> <br>1. And our simple client is totake some strings on standard input and some pop commands whichare indicated with hyphens.<br><br>2. Now, it's indicated by a little redarrow in this representation.<br><br>3. Andwe'll give'em a name, from zero to N^2-1 as indicated here.<br>
ackermann|sentence cnt : 1 <br> <br>1. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br>
aware|sentence cnt : 4 <br> <br>1. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>2. So that's certainly somethingto be aware of when using hashing in practice.<br><br>3. So, you have to just be aware that these situations have to bedealt with.<br><br>4. But it's something always to be aware of whentrying to [cough] apply simple algorithms in situations like these that turn out tobe maybe more sophisticated than we might think.<br>
extend|sentence cnt : 13 <br> <br>1. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>2. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br><br>3. We say that our generic type Key extendsComparable of Key.<br><br>4. And as we'll see this extendsto a practical problem in a number of situations.<br><br>5. Some of them very mathematical, that extend thehigher dimensions.<br><br>6. So how are we'regoing to represent binary search trees in Java? Well, we're going to extend ourimplementations of linked list structures to have two references instead of justone.<br><br>7. Clearly, these things can be extended in many ways.<br><br>8. So, this is just extending our ball data type that we use for thebouncing balls that didn't collide to take in, into account these extra things.<br>
inner|sentence cnt : 11 <br> <br>1. We use to implementlinked list in all linked data structures throughout the course, weuse what's called an inner class in Java.<br><br>2. And there's some better system support in Java for strings thatcache hash code means that you don't even have to compute the hash if your, yoursimple table for strings is in an inner loop.<br><br>3. And since stack is used inthe inner loop of some algorithms, it's important to think abouteven faster implementations.<br><br>4. First thing is the inner loop is longer than Quicksorts.<br><br>5.Like Mergesort there is more things to do in the inner loop.<br><br>6. The inner class node is the code that was given on the previousslide, and then we'll need implementations of put and get, and we'll also look at animplementation of delete, and an iterator as well.<br><br>7. We have this inner class that we use tobuild the items in the linked-list and we make it an inner class so we can directlyrefer to those instance variables.<br><br>8. So what's aniterator? So, we're going to use an inner class.<br>
clusters|sentence cnt : 5 <br> <br>1. You get long clusters and they're likely to getlonger.<br><br>2.Group of four key, continuous keys in a table space there is called a cluster andclearly we want to keep those clusters small.<br><br>3.>> And not only that once you have a big cluster and you hash into the middle of ityou've got a good chance that, that clusters going to get longer, or worse.<br><br>4. You have, these clusters or these chains building.<br><br>5. It's a very efficient andsimple data structure for processing k dimensional datathat's very widely used and the whole idea is that data clusters,particularly in high dimensions.<br>
performing|sentence cnt : 5 <br> <br>1. Except that it compute a skip that wouldmean that, that only look at about every eight key and they wouldn't have to doquite so much work performing the hash function.<br><br>2. Onevery smaller heap, now we continue just performing sync operations at the rootuntil we get a completely sorted array.<br><br>3. We want to add something to thecollection, maybe remove something from the collection and iterate throughthe objects in a collection, performing some operation on them,and of course test if it's empty.<br><br>4. And you'll sometimes see Mergesortperforming poorly because of that bug.<br><br>5. Nowusually we argue against why the interface is just adding operations to an interface,usually our reason for doing so is that we can't guarantee that all the operationscan be performing efficiently.<br>
locally|sentence cnt : 1 <br> <br>1. We just moved things around locally withinnodes.<br>
slightly|sentence cnt : 3 <br> <br>1. Slightly reduces the number of compares.<br><br>2. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>3.Okay next we're gonna look at anotherextension of geometric algorithms to process slightly more complicated objectsand then we'll see an important application.<br>
dating|sentence cnt : 2 <br> <br>1. So the tree grows from the bottomin the little side to side motion it's just accommodating room for each new keyas it's added.<br><br>2., dating at least to Euclid.<br>
molecules|sentence cnt : 2 <br> <br>1. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>2. Sowhether it's individual atoms and molecules or some bigger kinds ofparticles.<br>
phase|sentence cnt : 4 <br> <br>1. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>2. And so we have twophases, we have prediction and resolution.<br><br>3. So the scientific question, or the, mathematical questionfrom this model is, how do we know, whether it's going to percolate or not? Inthis problem and in many similar problems, there's what's called a phase transition.<br><br>4. So, we do have a quadraticinitialization phase that we perform just once to get the priority queue filled up.<br>
juts|sentence cnt : 1 <br> <br>1. And we do that by juts by notputting too many keys in to the table.<br>
semantics|sentence cnt : 3 <br> <br>1. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>2. And the semantics is different, forenqueue we add an item say at the end of the queue, and for dequeue weremove an item from the beginning.<br><br>3. And the semantics justclear from the names.<br>
argument|sentence cnt : 51 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>3. First thing we do is the public sortmethod that takes the array of comparable items as its argument.<br><br>4. It implements the compare method that takes two points as argument and withjust a little bit of calculation is able to do the compare.<br><br>5. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>6. The idea is that you create acomparator object and then pass that as a second argument to Java's sort routine andwe can do the same thing for our sorts.<br><br>7. And thenthe sort code can just use that compareTo() method, invoked in a sense of theobject like an entry in the array and as argument and another instance in theobject like another entry in the array to test whether the first is less than thesecond as in this example.<br><br>8. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br>
suppose|sentence cnt : 30 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2.Suppose we're inserting K.<br><br>3. Suppose we want to test if an array is sorted.<br><br>4. As a warm up, let's suppose that wehave a string, a collection of stings.<br><br>5. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br><br>6. If we're not done we're supposed to return true and the next() is supposed togive the next item in the iteration.<br><br>7. So, say, four is supposed to be unio n with three.<br><br>8. Supposed to search the right subtreeat 1 next, but we can prune that.<br>
manages|sentence cnt : 1 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br>
evaluate|sentence cnt : 1 <br> <br>1. We have operands andoperators and you want to evaluate it.<br>
fictional|sentence cnt : 1 <br> <br>1. Say, for this fictionalclass Student, that's got two instance variables - name and section.<br>
designers|sentence cnt : 5 <br> <br>1. Littlebit scary for some systems designers.<br><br>2. So, the system designer, Jon Bentley was one of the designers totake a look at these problems and that lead ultimately to the development of the3-way quick sort that were used today.<br><br>3. Now for standard keys like integers andstrings and doubles and so forth,we can count on the designers and implementors at Java toimplement good hash functions.<br><br>4. So the, the reason they used that is they thought they gotthem closer to the middle and they also don't like the, some system designersdon't like the idea of using random choices in a system method because of waythat it changes the state of the system.<br><br>5. The designers found that the cost of computing the hashfunction for strings seemed to be excessive, particularly for long strings.<br>
extensively|sentence cnt : 1 <br> <br>1. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br>
refines|sentence cnt : 1 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br>
shell|sentence cnt : 24 <br> <br>1. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>2. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>3. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>4. You wouldn't work to use Shellsortas the basis for h-sorting because that always takes quadratic time no matter whatorder there is in the array.<br><br>5.Now, we'll look at Shellsort which is abit elementary on the face of it but it's not at all elementary as you'll see.<br><br>6. It could be that there aresome increment sequence out there that make Shellsort more efficient than anyother method, any of the sorting method that we know for pratical file size, noone can deny that.<br><br>7. Try some technique to discover one and try to saysomething about the average-case performance of Shellsort.<br><br>8. But most people will accept thatand it's a fact and that's how Shellsort gains efficiency.<br>
starting|sentence cnt : 18 <br> <br>1. So, that's our starting point in terms of the code.<br><br>2. In the third case now,when i is at the third entry in the array, now we start a index j, andwe move that starting at i to the left.<br><br>3. We'll just goahead and compute the increments that are less than n, n / 3 and then startingat that increment whatever it is and say, we started 364 then next time we need anincrement, we'll just divide it by 3, 364 integer divide by 3, 364 integer /3 it gets 121, 40 and so forth.<br><br>4. What about the [cough]starting at the root if we have the case where E is less than S.<br><br>5. We just go throughstarting at h for i and when we do the insertion, the j loop, we decrement j by heach time, otherwise the code is exactly like Insertion Sort.<br><br>6. So, but anyway, starting at point 3,as far as we know, we're going to have tolook at both subtrees.<br><br>7. We'll assume that is a starting point.<br><br>8. We just go backwards doing a sync starting at K.<br>
infrastructure|sentence cnt : 5 <br> <br>1. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>2. And these methods are all widely used throughout ourcomputational infrastructure.<br><br>3. So it has the infrastructure that allows us tobe used for all types of data types and all types of ordering so it's got a methodthat implements comparable then its got methods easy compare order.<br><br>4. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>5. We talked about dynamic connectivity innetworks there's many other examples in our computational infrastructure.<br>
similar|sentence cnt : 21 <br> <br>1. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>2. And that immediately gives this code forinsertion sort, which is similar to our code forselection sort and just as simple.<br><br>3. So how we're going ti implement that? Wellthis is the basic problem that is very similar to our symbol table problem.<br><br>4. So, the API will look very similar to our stack or queue API with adifference that we want to have generic items that are comparable.<br><br>5. So if you have this recurrence [COUGH]which is similar to the ones that we're talkingabout.<br><br>6. And the implementation of put issimilar.<br><br>7. And similarly, maybe we want to build a, abook index, maybe for a real book, or maybe foran ebook.<br><br>8. So the scientific question, or the, mathematical questionfrom this model is, how do we know, whether it's going to percolate or not? Inthis problem and in many similar problems, there's what's called a phase transition.<br>
doubling|sentence cnt : 3 <br> <br>1. If the client happens to dopush-pop-push-pop alternating when the array is full, then it's going tobe doubling, having, doubling, having, doubling, having.<br><br>2. So you can imagine keeping the item, say, in a linked list or ina doubling array and just keeping just an order just as we would in the, in thestack just keeping in the way that they come in.<br><br>3. So the well-known technique fordoing that, called repeated doubling,is to, when the array fills up, create a new array of twice the size andcopy all the items over.<br>
generated|sentence cnt : 1 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br>
filter|sentence cnt : 7 <br> <br>1. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>2. That's an example of a, anexception filter.<br><br>3. What's the implementation of an exception filters?Here's a simple one using the said API that we just articulated.<br><br>4.So that's an example of a white list filter.<br><br>5. So that's a simple example of a filter usingsets.<br><br>6. So that's theexception filter, and that's useful in lots of applications such as the oneslisted here.<br><br>7. One thing thatis very common is the idea of an exception filter.<br>
remaining|sentence cnt : 4 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br><br>3. And in the ith iteration, we go through the array to try to find thesmallest remaining entry, in this case, the 2 is the smallest from any entry.<br><br>4.  Each time we have to scanthrough all the remaining entries in order to find the smallest.<br>
this|sentence cnt : 798 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>4. This is not a course on discretemathematics.<br><br>5.If you look at this visual trace you can see how it works.<br><br>6. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>7. There's lots of importantapplications for this.<br><br>8. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br>
commercial|sentence cnt : 2 <br> <br>1. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br><br>2. Or in commercial computing the keymight be an account number and the value might be the transactiondetails for that account.<br>
achieved|sentence cnt : 3 <br> <br>1.And now we've achieved the goal of partitioning the array.<br><br>2. So we've achieved putting it inorder with less work in this case.<br><br>3.Here's another client that we could use our sort program for, if we achieved thegoal of sorting any type of data.<br>
mapping|sentence cnt : 1 <br> <br>1. In fact, to make this mapping from an object name to theinteger zero through N - one is to find application of a symbol table or asearching algorithm, which is one of the things that we'll be studying later inthis course algorithms and data structures for solving that problem.<br>
gains|sentence cnt : 22 <br> <br>1.So we move to the left and compare H against the root of the left subtree.<br><br>2. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>3. Now we canpair H against the root of the right subtree of E, and that's R and it's lessso we have to go left cuz everybody to the right of R is bigger and H is smaller.<br><br>4. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>5. But most people will accept thatand it's a fact and that's how Shellsort gains efficiency.<br><br>6. And if we wanna find all intervals we just have to run thealgorithm fur Each interval that's, until we come up against no intersection, soit'll take time proportional to R log N if there's R intervals that intersect.<br><br>7. If it'sless than b, maybe the next compare is b against c.<br><br>8. Now, this was very easy to implement and, and we could stopbut usually, what happens in the design of algorithms is now that we understand whatit is that gains performance, we take a look and see, well, could we improve iteven further.<br>
elementary|sentence cnt : 24 <br> <br>1. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>2. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>3.Now, we'll look at Shellsort which is abit elementary on the face of it but it's not at all elementary as you'll see.<br><br>4.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>5.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br><br>6. Those are some basic data structuresand implementations and it seem quite elementary and simple but actually rightaway we can get to some very sophisticated applications of these basic concepts andthat's what we're going to consider next.<br><br>7. We'll look at couple of elementary priority queue implementationsthat are straightforward.<br><br>8. It's actually not so different from the elementary implementations that we looked at in the last section.<br>
field|sentence cnt : 31 <br> <br>1. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>2. We'll populate its fields andthen that old link will change that from null toa pointer to the new node.<br><br>3. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>4. Here's the 31x plus y ruleto combine all the fields.<br><br>5. And that willfill in the fields and then, we put that transaction on the priority queue.<br><br>6. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br><br>7. So, what we are going to do with thisclient is specify with integers which field is the key, and which is the value.<br><br>8. So we pick some othersmall prime number and for each field we multiply by 31.<br>
properties|sentence cnt : 20 <br> <br>1. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>2. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>3. We'lllook at different methods that take advantage of such properties.<br><br>4. So, there's alot of geometric properties of the convex hull that we can take advantage of todevelop an algorithm.<br><br>5. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br><br>6. So, given a BST with someof the links colored red that has those properties that's going to correspond to a2-3 tree.<br><br>7. Now theseproperties are very intuitive.<br><br>8. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br>
repeat|sentence cnt : 3 <br> <br>1. We have onestudent who was paying attention to what we're saying and uses an array and canpick the indices into that array at random check whether they're open and, andrepeat.<br><br>2. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br><br>3. So the well-known technique fordoing that, called repeated doubling,is to, when the array fills up, create a new array of twice the size andcopy all the items over.<br>
anyway|sentence cnt : 7 <br> <br>1. But anyway, those arereasonable goals.<br><br>2. If why is a reference that's pointingto the same object as this object, just return true,because if you're going to test the values they're going tohave the same values anyway.<br><br>3. So, but anyway, starting at point 3,as far as we know, we're going to have tolook at both subtrees.<br><br>4. And anyway for Java 1.<br><br>5. But anyway, that's a basic operation that we sometimes need.<br><br>6. So anyway,that code down at the bottom is you can use that as a template forwhat you might want to do.<br><br>7. So anyway, we're required to makesure that X is always equal to X, and that X equals Y is the same as Y equals X,and if X equals Y and Y equals Z, then X equals Z.<br>
languages|sentence cnt : 8 <br> <br>1. Differentlanguages have different mechanisms.<br><br>2. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>3. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>4. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br><br>5. With arrays, it doesn't quite work andagain all programming languages and, you know, many programming languages nowadayshave difficulties with this and Java's got a particular difficulty.<br><br>6. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br><br>7. There's many reason that immutable keys are that programming languages provide the capability to build immutable keys and this is a fine example of one.<br><br>8. So, that are sorting algorithms actually their actual code canbe used to implement sorting in many other languages.<br>
recompile|sentence cnt : 1 <br> <br>1. It says that we're using unchecked or unsafe operations and we shouldrecompile with a minus -Xlint equals unchecked for details.<br>
manner|sentence cnt : 3 <br> <br>1. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>2. It expands like binary search to handle all these convenient clientoperations in a very natural manner.<br><br>3. They're used for movies andvideo games, for particle collision simulation, they're used to study thegenome, and all manner of other applications.<br>
skip|sentence cnt : 6 <br> <br>1. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>2. Except that it compute a skip that wouldmean that, that only look at about every eight key and they wouldn't have to doquite so much work performing the hash function.<br><br>3. And we will skip the details.<br><br>4. You might also want it to be iterable but we'll skip that for now.<br><br>5. And we'll skip that code and just take a look at the comparison betweenthis elementary implementation for symbol tables with the sequentialsearch in an unordered list.<br><br>6. So the code is the same as insertion, as for Insertion Sort, exceptthat when we go backwards through the array we skip by h instead of just by one.<br>
coding|sentence cnt : 2 <br> <br>1. Okay, with this concrete demo in mind then moving tocoding up this algorithim is pretty straight forward.<br><br>2. Even if you are familiar with linkedlists, it's worth taking a look at this code because it's the style of codingthat we'll use throughout the course for much more complicated data structures.<br>
heap|sentence cnt : 122 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. So the heap order condition is satisfied everywhere except at this node.<br><br>3. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>4. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>5. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>6. So, with just two exchanges we insert that new element into the heap in this case.<br><br>7. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>8. Pull it off the heap and then that's our example.<br>
trough|sentence cnt : 1 <br> <br>1.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br>
analyzing|sentence cnt : 3 <br> <br>1. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br><br>2. Something goes wrong somebody analyzing the situation canenable insertions and they often will help find out where, what theproblem is.<br><br>3. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
override|sentence cnt : 1 <br> <br>1. And if it is in the symbol table,we'll just override the old value, which is st.<br>
client|sentence cnt : 141 <br> <br>1. The client really can'tknow how big the stack is.<br><br>2. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>3. So this is a simple test client thatwe can use to test our implementations.<br><br>4. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>5. And so what the test client'sgoing to do is going to just go in the loop as long asstandard in is not empty.<br><br>6. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>7. So that's three different clients, three completelydifferent types of data.<br><br>8. And so, this client readsstrings from standard input.<br>
encapsulate|sentence cnt : 2 <br> <br>1. We encapsulate them in basicdata types like these.<br><br>2. The way we do that is to takethe two primary operations, compares and exchangers that were that were, were usedto refer the data and encapsulate them just the static methods.<br>
uniformly|sentence cnt : 7 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>2. It was proved actually a long time ago even before computer implementations that if you do that, you get a uniformly random permutation and it only takes linear time.<br><br>3. So idealistically, what we'd likeis to be able to take any key and uniformly scramble it toproduce a table index.<br><br>4. And every time we pick an integer between zero and i uniformly at random, and swap a of i with that integer.<br><br>5. And they're pretty uniformly distributed.<br><br>6. But, doing the whole array doesn't give you a uniformly random result.<br><br>7. There's actually a very easy way to rearrange an array so that the result is a uniformly random permutation, and only require linear time to get the job done.<br>
advancing|sentence cnt : 1 <br> <br>1. We save away the item, we delete the firstnode by advancing the reference and then we return the item, so identical.<br>
inquiry|sentence cnt : 2 <br> <br>1.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>2. And that's something that's very, very common in, inscientific inquiry nowadays.<br>
words|sentence cnt : 31 <br> <br>1. So that now, we have our set ofexceptional words.<br><br>2. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>3. Let's look at the meaning of those words.<br><br>4. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br><br>5. And then we left out, left out the code where you print out the nine words thatyou want.<br><br>6. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>7. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br><br>8. And in yourexceptional list would be words that are in the dictionary.<br>
displaying|sentence cnt : 1 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br>
integral|sentence cnt : 1 <br> <br>1.And then that gives us an easy sum that we can approximate by an integral.<br>
both|sentence cnt : 78 <br> <br>1. Make sure that both first andlast are always what we want them to be.<br><br>2. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>3. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>4. And so, it's larger than, it's bothchildren, and the larger of the two children is T, so we promote the T.<br><br>5. We're going to have to look at both,as far as we know now.<br><br>6. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>7. So, if they're going to be comparable,we might as well take advantage of it, both to get more efficient algorithms and to be able to take advantage ofa broader set of operations.<br><br>8. It uses actually both quicksort and mergesort.<br>
neighbor|sentence cnt : 6 <br> <br>1. So then we're done, andwe found that the nearest neighbor is 5.<br><br>2. And while the nearest neighbor can't be, we don't have to go down the right subtreeat 6 because you can't have a point in that rectangle that's closerto the query point than 3.<br><br>3. So in typical cases, the runningtime of nearest neighbor search in a 2D tree is going to beproportional to logarithmic.<br><br>4. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>5. Nearest neighbor couldn't be in there.<br><br>6. Let's look at another using 2dtrees to solve another problem, the so-called nearest neighbor search.<br>
aggregate|sentence cnt : 2 <br> <br>1. And his idea was that if some particle isway away from some cluster of particles, we can treat that cluster asa single aggregate particle.<br><br>2. And not do the individual forcecalculation between our particle and every one of those in the aggregate.<br>
traversal|sentence cnt : 2 <br> <br>1. So, in a binary search tree, those rank numbers goin an increasing order as we do in an ordered traversal and that's easy tocompute.<br><br>2. And it's based on so called in-order traversal.<br>
exist|sentence cnt : 2 <br> <br>1. And in all of these cases where we're on a node that alreadyexisted, we just want to return the link to that node.<br><br>2. This things exist but they're not sowidely applied at in practice.<br>
bullet|sentence cnt : 1 <br> <br>1. We have to probably to make bullet proof code -throw exceptions if a client tries to call next() with no items there and triesto call remove() at all, we're not going to support remove().<br>
dijkstra|sentence cnt : 9 <br> <br>1. And Dijkstra's algorithm is very simple toexpress.<br><br>2. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>3. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>4. But, but actually it's a problem that Edsger Dijkstra had proposedin the 70s as an example of, of programming problem.<br><br>5. And then simply performDijkstra's algorithm.<br><br>6. Here's the code thatimplements Dijkstra's two-stack algorithm.<br><br>7. Here's a trace of Dijkstra 3-way partitioning forhis problem which is when there's just three different values in the file.<br><br>8. Now a specific example that really shows this off and also will illustratethe utility of being able to process multiple types of data with the same codeis this example is Dijkstra's two-stack algorithm for arithmetic expressionevaluation.<br>
operator|sentence cnt : 15 <br> <br>1. And plus it goes on the operator stack.<br><br>2.Operator, we put on to the operator stack.<br><br>3. The operandstack the operator stack is string, it could be characters which is just ouroperator.<br><br>4. The right goes to the value stack and nowwe got a lot of stuff on the stacks and we got through right parenthesis and that'sgoing to finish up the computation, take the top two items off the stack and thetop operator off the operator stack, perform the operation, put the resultback on the value stack.<br><br>5. What it says is to you have the top operator and the top two valuesand that's what you want to do.<br><br>6. If we have a rightparenthesis, then go ahead and pop the operator.<br><br>7. We have operands andoperators and you want to evaluate it.<br><br>8. Put the value on to the value stack and finally, the lastright parenthesis, take the two operators of the value stack, operators of the valuestack, and operator of the operator stack, perform the operation, put the result backon the value stack.<br>
items|sentence cnt : 88 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>3. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>4. So to insert N items,it's about three array accesses.<br><br>5. So this is when the itemscome in in reverse order.<br><br>6. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br><br>7. So a stable sort is asort that preserves the relative order of items with equal keys.<br><br>8. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br>
emerged|sentence cnt : 3 <br> <br>1. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>2. And with just changing one value in the arraywe get the two large components emerged together.<br><br>3. So, we've got an array A and its firsthalf is sorted and its second half is sorted and the computation we need toperform is to replace that with the sorted array where those two sub-halves aremerged together.<br>
sweeps|sentence cnt : 1 <br> <br>1. So the method that we'regoing to look at is a so called Sweep Line algorithm and the idea is to think ofvertical line that sweeps left to right through the data.<br>
while|sentence cnt : 40 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>3. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>4. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>5. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>6. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br><br>7. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>8. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br>
waiting|sentence cnt : 5 <br> <br>1. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>2. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>3. So, the lesson isthat we can develop good algorithms or good implementations without much code butthere are some out there that are still waiting discovery.<br><br>4. That's another great algorithm waiting tobe discovered.<br><br>5. It's as if you're waitingin line to buy a ticket.<br>
remember|sentence cnt : 5 <br> <br>1. The thing is remember represented in array one two three and so forth.<br><br>2. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>3. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>4. What's the next smallest xcoordinate? In this case it's the line number one there, and we'll remember its ycoordinate in a binary search tree.<br><br>5. So, here's another one that involves, remember, wepassed that red link up.<br>
utility|sentence cnt : 1 <br> <br>1. Now a specific example that really shows this off and also will illustratethe utility of being able to process multiple types of data with the same codeis this example is Dijkstra's two-stack algorithm for arithmetic expressionevaluation.<br>
backwards|sentence cnt : 3 <br> <br>1. We just go backwards doing a sync starting at K.<br><br>2. We go backwards through the heap.<br><br>3. So the code is the same as insertion, as for Insertion Sort, exceptthat when we go backwards through the array we skip by h instead of just by one.<br>
returning|sentence cnt : 2 <br> <br>1. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br><br>2. Again, when we look at moresophisticated values we'll be returning something else.<br>
tony|sentence cnt : 1 <br> <br>1. This method was invented in 1961 by TonyHore, who won the Turing Award in 1980 for this and other work.<br>
spending|sentence cnt : 1 <br> <br>1. A good algorithm is much more effectivethan spending money or time wasting money or time usinga bad one.<br>
collection|sentence cnt : 16 <br> <br>1. As a warm up, let's suppose that wehave a string, a collection of stings.<br><br>2. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>3. And then what we can do, is just return that node's right link, then that old node, nobody's pointing to it, so it's available for garbage collection.<br><br>4. Really often what we're doing is just inserting items into a collectionand then, later on, iterating through the items that we have.<br><br>5. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>6. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>7. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>8. So, what we want to do is to allow the client to iteratethrough the items in the collection.<br>
connection|sentence cnt : 16 <br> <br>1. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br><br>2. There's not enough open site for there to be a connection from the topto the bottom.<br><br>3. And then, we have the idea of a connection between two objects.<br><br>4. So, that creates a connection between five andzero.<br><br>5. Seven and two creates a connection between seven and two.<br><br>6. So shouldn't use it inconnection with inheritance.<br><br>7. And that's a redundant connection.<br><br>8. Now, theconnections, well, we need, a few abstract properties that these connections have tosatisfy.<br>
generics|sentence cnt : 7 <br> <br>1. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>2. So, since we're making array ofnodes, a node would have generics if we use to key in value.<br><br>3. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>4. Because we can't have an array of generics.<br><br>5. And we have to use ugly cast, 'cause we can't have a race ofgenerics.<br><br>6. What if we want to havequeues and stacks of other types of data? And that brings us to the topic ofgenerics.<br><br>7. So, the third attempt that we'regoing to talk about uses generics.<br>
range|sentence cnt : 50 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. So now what about solving a problem likethis, range search problem for a 2d tree.<br><br>3. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>4. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>5. Now, we want to talk about deletion andthen range search and range count.<br><br>6. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>7. So and a range search.<br><br>8. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br>
indeed|sentence cnt : 1 <br> <br>1. And indeed if you just draw theline from 1 to 4, you can see the 2 inside so there is no way it could be inthe convex hull.<br>
characteristic|sentence cnt : 10 <br> <br>1. At leastthat some indication that you understand the performance characteristics.<br><br>2. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>3.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br><br>4. So that seems as if it should work but that doesn't have all the characteristicswe need in the Java implementation.<br><br>5. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br><br>6. So that's obviously a verydesirable characteristic.<br><br>7. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>8. So again,typical characteristics we have a huge file but small number of different keyvalues.<br>
chunck|sentence cnt : 1 <br> <br>1. So it's the first little chunck and thenthe next little chunk and then merges those together, andso forth and so on.<br>
lawsuit|sentence cnt : 1 <br> <br>1. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br>
being|sentence cnt : 21 <br> <br>1.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>2. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>3. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>4. The basic plan is tothink of the symbol table as really try to reduce the problemto being like an array.<br><br>5. It depends on the arraybeing randomly ordered.<br><br>6. The basic idea is to think of the array as being a littleat the begining a set of little sorted sub arrays of size one.<br><br>7. He's widely accredited as being theinventor of Mergesort.<br><br>8. And then the only instance variableof a stack is a reference to the first node on the list andit starts out being null.<br>
practices|sentence cnt : 2 <br> <br>1. One of the practices that will follow often inthis course is to check our API design before getting too far into dealing withthe problem, by building a client that is going to use the data type that wedevelop.<br><br>2. All right, so, and certainly you want tofollow some of these best practices, so fields that are most likely to differ, those are the ones that youmight want to compare first.<br>
millions|sentence cnt : 4 <br> <br>1. So, maybe we can store millions or thousands of them.<br><br>2. They could contain millions of keys,But it doesn't matter what they contain.<br><br>3. So what we want to do is run this experiment millions of times,which we can do in a computer, as long as we can, efficiently do the calculation ofdoes it percolate or not.<br><br>4. You could spendmillions on a super computer, and maybe you could get it done in six years insteadof 30, or in two months but with a fast logarithm, you can do it in seconds, inseconds on your own PC.<br>
moving|sentence cnt : 21 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2. Moving current to the next place.<br><br>3. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>4. And then proceeding inthat way, moving bottom up or moving from right to left, the next thing we do is butthen worry about a three node heap that's heap ordered and we're fine.<br><br>5.Now, if that parent were a 3-node, it would become a temporary 4-node and wouldcontinue the process moving up the tree.<br><br>6.But the advantage of that might be that removing the maximum is easy.<br><br>7. And another property is that youcan't sort moving less data because selection sort does just a linear numberof exchanges.<br><br>8. So that's moving the smaller key down.<br>
query|sentence cnt : 34 <br> <br>1. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br><br>2. Any interval thatintersects this query interval 23 25.<br><br>3. And we'll always go towardsthe query point first.<br><br>4. And so that idea of getting closer andcloser to the query point is going to cut out different parts ofthe tree as we process.<br><br>5. Try to find any interval that intersects our queryinterval.<br><br>6. because there could be nopoint on the right subtree, on the right of this splitting line,that's closer to the query point than 3.<br><br>7. So the first point that's the closestwe found so far to the query point, so we'll save our number 1 as the distance.<br><br>8. So again, go towards the query point, so I'll go to the top first,and that takes us to 6.<br>
dollars|sentence cnt : 2 <br> <br>1. But we're interested in the biggest ones andso maybe it's the biggest amount of dollars, or the biggest cost, or whateverit might happen to be.<br><br>2. So we are going to use a min-oriented priority queue sothat's going to keep, it'll [cough] it'll be one where we can delete the minimumand, and it'll be generic so we'll have a transaction type that holds thisinformation including natural ordering where it's ordered by dollars that lastcolumn.<br>
determining|sentence cnt : 1 <br> <br>1.So now let's look at a basic geometricdata processing problem of determining intersections among a set of linesegments.<br>
drew|sentence cnt : 2 <br> <br>1. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>2. So, another undergraduate in an algorithmsclass discovered this idea for N-body simulation and that's Andrew Appel.<br>
concoct|sentence cnt : 1 <br> <br>1. It is possible to concoct cases, where you're going to haveto examine all the points.<br>
overhead|sentence cnt : 6 <br> <br>1. There's a little extra for it first,but that's about N overhead for the whole stack.<br><br>2. Even Quicksort has more overhead than youwant for a tiny array, like one of size two or three or four.<br><br>3. But thespace is only proportional to the number of non-zero elements plus N for the extrasymbol table overhead.<br><br>4. So say the subarrays are only of two, orthree, or four there's too much overhead with the recursive calls andso forth to get that done efficiently.<br><br>5. There's some extra overhead, 8 bytes,because it's an inner class.<br><br>6. So, in Java, in inner class there is, for every object there's 16 bytes of overhead.<br>
ulman|sentence cnt : 1 <br> <br>1. And what was provedby Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of Munion and find operations will touch the array at most a c (N + M lg star N) times.<br>
blink|sentence cnt : 1 <br> <br>1. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br>
intersections|sentence cnt : 13 <br> <br>1. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>2. Be, becausesince there's no intersections in the left sub tree high has gotta be less than C.<br><br>3. No intersection in the left means no intersections at all, sothose two cases is enough to show that this algebroid finds an intersection, ifthere is one.<br><br>4. So, how are we going to be able to determinethese intersections efficiently? Now, the natural algorithm, or the naivebrute-force algorithm, is quadratic in time.<br><br>5.So now let's look at a basic geometricdata processing problem of determining intersections among a set of linesegments.<br><br>6. That's the basic idea behind the sweep linealgorithm, to find intersections in sets of horizontal and vertical lines.<br><br>7. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br><br>8. Any possibleintersection would have to be in the right, And then the other point is that ifyou go left, then either there's an intersection there, or there's nointersections at all.<br>
grid|sentence cnt : 7 <br> <br>1. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>2. In the case of the grid implementation,they might all fall in the same square.<br><br>3. It's got 13,000 points, but if you tryto use the grid implementation for this you find that halfthe squares would be empty and half the points are injust 10% of the squares.<br><br>4. The amount of space required is N squared,for the grid plus N.<br><br>5. So, and I will pick a parameter M and divide space intoan M-by-M grid of squares.<br><br>6. So let's think of an n by n grid of squares that we call sites.<br><br>7. Well one easy way to doit is to just think about dividing space into a grid of squares.<br>
server|sentence cnt : 2 <br> <br>1. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br><br>2. So for example,a domain name server might have a lookup where you've got a tablethat's got an IP address and URL associated with that IP address.<br>
stacks|sentence cnt : 26 <br> <br>1. Stacks are familiar.<br><br>2. We have two different stacks.<br><br>3. So to begin, we will talk about stacks.<br><br>4. So howare we going to implement stacks and queues for that types of data.<br><br>5. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>6. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>7. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br><br>8. The right goes to the value stack and nowwe got a lot of stuff on the stacks and we got through right parenthesis and that'sgoing to finish up the computation, take the top two items off the stack and thetop operator off the operator stack, perform the operation, put the resultback on the value stack.<br>
representative|sentence cnt : 3 <br> <br>1. So, from this datastructure we can associate with each item a root, which is representative, say, ofit's connected component.<br><br>2. And you can test this out for different types of environments easily andit's representative.<br><br>3.Now, look at an interesting application ofpriority queues that is actually representative of whole family of acritically important applications in applications of computing.<br>
overlaps|sentence cnt : 1 <br> <br>1. And it's easy to tell whether anyof them could fall in the range by just checking whether they're range overlapsthe root or not.<br>
rebuild|sentence cnt : 2 <br> <br>1. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br><br>2. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br>
complementary|sentence cnt : 1 <br> <br>1." another, A complementary approachis to think of these words as words that we don't want to ever see.<br>
selling|sentence cnt : 1 <br> <br>1. So that's the cut off point for, selling,seven tickets that's the cut off point.<br>
nobody|sentence cnt : 16 <br> <br>1. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>2. And then what we can do, is just return that node's right link, then that old node, nobody's pointing to it, so it's available for garbage collection.<br><br>3. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br><br>4. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>5. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>6.And everybody to the right, there's nobody less.<br><br>7.Nobody to the right is less.<br><br>8.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br>
professor|sentence cnt : 1 <br> <br>1. I'm Bob Sedgewick, professor ofcomputer science at Princeton.<br>
disadvantage|sentence cnt : 2 <br> <br>1. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br><br>2. There is a disadvantage that you have to create a new object for every data type value.<br>
quickfind|sentence cnt : 2 <br> <br>1.All right so QuickFind is too slow forhuge problems.<br><br>2. So, that's a fine implementation of QuickFind so the nextthing to decide is how effective or efficient that algorithm is going to beand we'll talk in some detail about how to do that but for this it's sufficient tojust think about the number of times the code has to access the array.<br>
traverse|sentence cnt : 2 <br> <br>1. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>2. Traverse the left subtree enqueue the key, traverse theright subtree.<br>
gives|sentence cnt : 38 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>3. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>4. This gives exactly what happens duringeach of the calls to merge.<br><br>5. And if M is prime,it gives us some comfort that we have some possibility of each table positionappearing with equal likelihood.<br><br>6. The idea though is that this example illustrates that good sortingalgorithm gives us a good convex hull algorithm.<br><br>7. So, if you have the keys in random order the binary searchtree gives efficient search and insert.<br><br>8.So this gives a feeling for the.<br>
terms|sentence cnt : 12 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. So, that's our starting point in terms of the code.<br><br>3.Rearrange the terms, so we get n+1 cn-1 and then divided by n, n+1.<br><br>4.And then these terms, every size appears twice.<br><br>5. Weneed to just in terms of implementation details, our keys and values have to beobjects.<br><br>6. So, all of the operations thatwe're going to look at for red-black trees can be understood in terms of thecorresponding operations on 2-3 trees.<br><br>7. Again, we can look at insertionsort in terms of invariants.<br><br>8. First thing we do is just multiply by Nand collect terms.<br>
parking|sentence cnt : 4 <br> <br>1. And he was able to show, and we'll talk just a little bitabout this, that if, there's, only half of the parking spaces are occupied, then, onaverage, half the people find, find it after one place and the other half have tolook one extra.<br><br>2. So, what happens is that you are on a one waystreet and you are looking for a parking place and, it's, the idea's you startlooking for a parking place at particular times and say "Okay, now I need a parkingplace", and what you're doing is linear probing hashing.<br><br>3. No way can you formulate theproblem as so called parking problem.<br><br>4. Then that modelsthe hash function, then how far do they have to go to look for a place? That'scanoot's parking problem.<br>
nearest|sentence cnt : 9 <br> <br>1. So then we're done, andwe found that the nearest neighbor is 5.<br><br>2. And while the nearest neighbor can't be, we don't have to go down the right subtreeat 6 because you can't have a point in that rectangle that's closerto the query point than 3.<br><br>3. So in typical cases, the runningtime of nearest neighbor search in a 2D tree is going to beproportional to logarithmic.<br><br>4. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>5. And velocity matching, where you update your velocity tothe average of the k nearest boids.<br><br>6. Nearest neighbor couldn't be in there.<br><br>7. Let's look at another using 2dtrees to solve another problem, the so-called nearest neighbor search.<br><br>8. You have centering, where you try to point near the centerof mass of the k nearest boids.<br>
impose|sentence cnt : 1 <br> <br>1. So when we start putting the keys in the nodes, we're going to impose one more condition that's called heap ordering.<br>
hours|sentence cnt : 1 <br> <br>1. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br>
effects|sentence cnt : 1 <br> <br>1. Andthis is an elementary programing exercise that is the, the code at the left has theeffects shown at the right.<br>
pause|sentence cnt : 1 <br> <br>1. At least reason for pause in using hashing.<br>
collisions|sentence cnt : 13 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. So, what we want to do is have an easy way to dealwith collisions.<br><br>3. And there's also a variable called count, which is the number ofcollisions of particles have been involved in.<br><br>4. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>5.Now, all collisions are, might not happen so we might have two particles that are ona collision course that and we're going to predict that point for both of thoseparticles, you know, even right at the beginning.<br><br>6. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>7. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br><br>8. You need a quadratic amount ofmemory to avoid collisions.<br>
maintain|sentence cnt : 43 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>3. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>4. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>5. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>6. To maintain the sorted array in dynamic fashion is going to takelinear time you have to go through the whole thing.<br><br>7. So we have to look at the code that'sgoing to maintain that invariant as the pointer increments.<br><br>8. And what are we supposed to do then? Well, to maintain thevariant there we just need to increment i.<br>
security|sentence cnt : 3 <br> <br>1. So, this isn't just an example about software security, there's a lot of difficult and deep issues to worry about in software security, and we're not going to worry about all of them.<br><br>2. Another example, Social Security numbers.<br><br>3. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
memory|sentence cnt : 34 <br> <br>1. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>2. Maybe the way yourcomputer's memory is organized make a difference.<br><br>3. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br><br>4. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>5. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>6.There's plenty of time by the memory model.<br><br>7. So, that means that you could touch everything in the main memory inabout a second.<br><br>8. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br>
lots|sentence cnt : 29 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. There's lots of importantapplications for this.<br><br>3. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>4. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>5. It's not agood idea to have lots and lots of, you know, operations in the same API.<br><br>6. And so, symbol tables provide us with a way to provide a moreefficient implementation of, of this process when we have lots of zero entries.<br><br>7. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>8.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br>
installed|sentence cnt : 1 <br> <br>1. [cough]and because in this implementation for left-leaning red-black trees we're goingto return the link whenever we're done, and then that will get that link installedup in the node above whether it be left or right.<br>
wind|sentence cnt : 19 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>3. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>4. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>5. So, it goes down to the middle, and windsup needing to be inserted in the, 3-node in the middle.<br><br>6. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br><br>7.So the easy case is if the key winds up in a 2-node at the bottom, like this one.<br><br>8. You could wind up with a long skinny tree.<br>
second|sentence cnt : 65 <br> <br>1. You can see it's got the first half sorted, now it's working on the secondhalf.<br><br>2. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>3. So now we have a second item b.<br><br>4.Even on your PC you can sort huge array of a million items in less then a second anda million items in only a few minutes.<br><br>5. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br><br>6. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>7. And we'll see how that looks in just a second.<br><br>8. So, that means that you could touch everything in the main memory inabout a second.<br>
swims|sentence cnt : 1 <br> <br>1. Swims up to the top, and if we have a node at index k and we know the heap condition is violated there.<br>
limits|sentence cnt : 1 <br> <br>1.And then it calls the recursive method that takes as arguments the limits of thesubarray that's gonna be sorted.<br>
playing|sentence cnt : 2 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. The ideaof selection sort, is start out with a unsorted array and we'll use these playingcards as an example.<br>
technically|sentence cnt : 1 <br> <br>1.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br>
consideration|sentence cnt : 4 <br> <br>1. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>2. And, andpeople have variants of these algorithms that keep it more, much more than halfempty if that kind of space is a, is a consideration.<br><br>3. Nowthere's a number of considerations to take into account.<br><br>4. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br>
instances|sentence cnt : 3 <br> <br>1. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>2. Now that we've seen efficientimplementations of algorithms that can solve the unifying problem for hugeproblem instances let's look to see how that might be applied.<br><br>3. And you've, you've used programs like this on, on your computer many instances, mostlikely.<br>
give|sentence cnt : 130 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>5. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>6. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>7. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>8. This gives exactly what happens duringeach of the calls to merge.<br>
accessing|sentence cnt : 2 <br> <br>1. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>2. But it's a different wayof accessing the data.<br>
stupid|sentence cnt : 1 <br> <br>1. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br>
broken|sentence cnt : 2 <br> <br>1. Andthis was taking a look at the Qsort that a user found was broken and, and now, thismethod is incorporated into some plenty of system sorts.<br><br>2. Now the invariant's brokenbecause the element on the pointer is not in sorted order.<br>
exhausted|sentence cnt : 3 <br> <br>1. If the j pointer is exhausted we move over the next ith element.<br><br>2.And now that first subarray is exhausted so reallyall we need to do is take the rest of the elements from the rightpart and move them back in.<br><br>3. If the i pointer is exhausted, then wejust move over the j, next jth element.<br>
suring|sentence cnt : 1 <br> <br>1. So that's just a, a way of make suring that the simulation keepsproceeding.<br>
overload|sentence cnt : 1 <br> <br>1. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br>
dependence|sentence cnt : 1 <br> <br>1. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br>
crucial|sentence cnt : 2 <br> <br>1. We're having a efficient sortas absolutely crucial.<br><br>2. Well, let'slook at the other two cases and these understanding needs is crucial tounderstanding the whole algorithm.<br>
forced|sentence cnt : 1 <br> <br>1. Well, firstthing that we might that we might consider and actually we're forced to consider thisone in lots of programming environment, is to implement a separate stack class foreach type of data that we're using.<br>
network|sentence cnt : 6 <br> <br>1.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br><br>2. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>3. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br><br>4. For example, in the firstlecture, we're going to talk about the network connectivity problem, where theproblem is, given a large set of items that are connected together pairwise isthere a way to get from one to another with a path through the connections.<br><br>5. In fact,almost any computer application system is going to have a symbol table ormultiple symbol tables at its core all the way down to the basicmemory system of the computer or the networking system that your computeraccess to information depends on.<br><br>6. We talked about dynamic connectivity innetworks there's many other examples in our computational infrastructure.<br>
innovations|sentence cnt : 1 <br> <br>1. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br>
insertion|sentence cnt : 88 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2. Just put them in anarray, and then, well, insertion is, is fast.<br><br>3. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>4. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>5. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>6. We're going to talk about insertion andsearch.<br><br>7. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>8. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br>
comparative|sentence cnt : 2 <br> <br>1. And the firstone called by name implements a comparator for students and when you compare twostudents by name, it's going to use the string comparative method.<br><br>2. How do we test if two objects are equal? So Java has got requirements as forcomparative and here's the basic requirement about equals.<br>
mergesort|sentence cnt : 65 <br> <br>1. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>2.Mergesort is not only efficient, it's also.<br><br>3. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>4. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>5. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>6. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>7. It uses actually both quicksort and mergesort.<br><br>8. Whatever the size,bottom of Mergesort gets the job done in log N passes.<br>
baggage|sentence cnt : 1 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br>
effective|sentence cnt : 22 <br> <br>1. And, and in many applications evensetting M = 100 or 1,000 is going to be very effective.<br><br>2. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>3. It generalizes thestack and the queue and gives us a data structure that we can use to effectivelydesign algorithm of all sorts.<br><br>4. So now we're going to have tolook at can this code be effective for large problems? Well unfortunatelyQuick-union is faster but it's also too slow.<br><br>5. And that is going to be very effective forperformance and lots of applications.<br><br>6. So array resizing doesn'thappen that often, but it's a very effective way ofimplementing the stack API with an array where the client does not have toprovide the maximum capacity of the stack.<br><br>7. Another importantreason is that if you know effect, how to effectively use algorithms and datastructures you're going to have a much better chance at interviewing for a job inthe technology industry then if you don't.<br><br>8. Sql or Oracles database and others,are based on, some variant of B-trees because they're so, so effective.<br>
output|sentence cnt : 3 <br> <br>1. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>2.[COUGH] so the first thing we do is, take the smaller of the two entriespointed to by i and j, and compare those, and take the smallest one, and movethat one to be the next item output.<br><br>3. It's the next thing that has to go in theoutput.<br>
filters|sentence cnt : 2 <br> <br>1. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>2. What's the implementation of an exception filters?Here's a simple one using the said API that we just articulated.<br>
gonna|sentence cnt : 24 <br> <br>1. We're not gonna try to find them all we'llget back to that in a minute.<br><br>2. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>3. The maximum end-point in the left is 22, and we're looking for 23, andwe're not gonna find anything there, so we just wanna go right.<br><br>4. So now, we're gonna go back up the tree.<br><br>5. Alright so now we're gonna look tosee if we have an intersection what a.<br><br>6. But we're gonna store the, largest endpoint inthe subtree rooted at that node.<br><br>7.And then it calls the recursive method that takes as arguments the limits of thesubarray that's gonna be sorted.<br><br>8.It's gonna to do a shuffle.<br>
proves|sentence cnt : 1 <br> <br>1.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br>
segments|sentence cnt : 5 <br> <br>1. And again, as we know,such an algorithm is not going to be practical, for huge numbers of linesegments.<br><br>2. And so,suppose we have a large number of such line segments and what we want to be ableto do is to find all places where they intersect.<br><br>3. So, it's called the orthogonal line segment, segment intersection searchwhere the lines segments or constrained to be either horizontal or vertical.<br><br>4.So now let's look at a basic geometricdata processing problem of determining intersections among a set of linesegments.<br><br>5.Where there's N horizontal vertical line segments.<br>
thirteenth|sentence cnt : 1 <br> <br>1. So wealready looked at the Get operation so we might want to know what city is associatedwith the event that happened at time nine o'clock, thirteenth and so that shouldreturn that value.<br>
examine|sentence cnt : 9 <br> <br>1. For queue,we examine the item least recently added.<br><br>2. Our regular search code doesn't examine the color of a linkand so we can just use it exactly as is.<br><br>3. The [cough] number of nodes examined when wedo a search is the length of the search path to low plus the length of the searchpath to high to [cough] find their ranks and that's going to be time proportionalto log N.<br><br>4. All right, so what about the analysisof how long is this is going to take? Well, again, a typical case, rectanglesare small that we're only going to examine really the path of the tree maybea couple of other nodes along with path.<br><br>5. It is possible to concoct cases, where you're going to haveto examine all the points.<br><br>6. So we exchange itwill lt and increment both i and lt and now where the point, where the pointershave crossed i and gt across there's nothing that we haven't examined yet.<br><br>7. In this diagram, the entries in black, are theones that are examined in order to find the minimum each time with the minimum inred.<br><br>8. And so on average, you examined Nover M squared points per square.<br>
peel|sentence cnt : 2 <br> <br>1. And in the worst case if the randomshuffle winds up putting the items exactly in order, then partitioning doesn't,doesn't really do anything except find the smallest, peel off the smallest item.<br><br>2. You just peels off one key to do file size n then you get a sub file size n- one and then n - two and so forth and the result is a quadratic tim e algorithm.<br>
ingenious|sentence cnt : 1 <br> <br>1.Now we're going to look at binary heaps, which is an ingenious and very simple data structure that's going to help us implement all the priority queue operations quickly.<br>
enabling|sentence cnt : 1 <br> <br>1. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br>
struggle|sentence cnt : 1 <br> <br>1. And that's maybe a little bit what happens when a new boss is hired from the outside and then the two subordinates struggle to take over that position and then the boss would get demoted to it's level of competence.<br>
exercise|sentence cnt : 15 <br> <br>1. But more important, there's code, there's exercises, tere's agreat deal of information there.<br><br>2. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>3. And it's definitelyan instructive exercise to check that you believe that, that method works.<br><br>4. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>5. And we'll leave that as an exercise.<br><br>6. If we're going to implement our own typesand then use those types as keys and symbol tables you have toexercise a little bit of care and we'll talk about that briefly.<br><br>7. Soit's a little exercise in abstraction.<br><br>8. But, the bottom line is, you should be able t oprogram, and the quick exercise to get ready is, to write a java program on yourcomputer perhaps using a programming model, as described on the book site.<br>
manipulate|sentence cnt : 2 <br> <br>1. Now what about inserting?Well, it's a similar type of strategy as with regular binary search trees, exceptthat we manipulate the two and 3-node to keep perfect balance in the tree.<br><br>2. Well, each one of these operations are fairly straightforward but just to check our ability to manipulate this data structure, we'll takea look at each.<br>
heights|sentence cnt : 1 <br> <br>1. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br>
switches|sentence cnt : 1 <br> <br>1. Somethings are wires, and some things are switches that, are used to, implementmemory bits and computer logic.<br>
sets|sentence cnt : 16 <br> <br>1. That's building a symbol table associatingkeys with sets of files.<br><br>2. We have an inter-for loop that for j, if it finds asmaller one, resets min and then once we've looked at all the elements to theright of i we exchange the smallest one with i.<br><br>3. And then that sets up for this four loop that accomplishes themerge.<br><br>4. So this creates a new symbol table associating string keys with sets offiles.<br><br>5. First when we look at, seemseven simpler than the regular symbol tables, and that's about sets.<br><br>6. And also, itwouldn't be reasonably efficient at all for large data sets.<br><br>7. If the key's there, it just resets the value.<br><br>8. And again the string is the key and thesets of integers are going to be the places in the arraywhere the given work appears.<br>
model|sentence cnt : 53 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. And we're, we're going to look at a more general model forexternal storage.<br><br>3.There's plenty of time by the memory model.<br><br>4. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br><br>5. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br><br>6. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>7. And this code is straight forward way to implement comparators that you canuse as a model.<br><br>8. So, our cost model is the numbercompares.<br>
ficiently|sentence cnt : 20 <br> <br>1. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>2. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>3.And how can we do it efficiently that is in, in log N time versus quadratic time.<br><br>4. So we can,implement these, efficiently and they are, convenient and useful for the clients.<br><br>5. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>6. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>7. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br><br>8. It can't maintain a dynamic table efficiently with binarysearch and that's going to be your focus in the next lecture.<br>
attractive|sentence cnt : 3 <br> <br>1. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br><br>2. And since as with stack and queue operations, theseinsert and deletes might be intermixed in arbitrary ways and there might be hugenumbers of them either one of these is very attractive because they're going totake N times the number of operations.<br><br>3. And linear probing isvery attractive in this case.<br>
ending|sentence cnt : 28 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>3. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>4. And what about Mergesort? Mergesort is stable well,it's stable as long as the merge operation is stable and that operation is going tobe stable depending on how we code it.<br><br>5. The amount used is between 8N and 32N, depending on how full the array is and just a quick analysis of the amountof space that arrays take in Java.<br><br>6. So everything to the left of i is inascending order, everything to the right, we haven't seen it all yet.<br><br>7. And, depending on the valueof the parameter, M, you have a space time trade-off.<br><br>8. And once we've done that, then we have everything tothe left by in ascending order.<br>
dimensional|sentence cnt : 24 <br> <br>1. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>2. We can use a two-dimensional arrayto directly index relevant squares.<br><br>3. We started with one dimensionalrange search and just used regular binary search tree to compute ranks to get theanswer.<br><br>4. So [cough] so, for example whatabout one-dimensional range counting? Well, what we're going to do is just keepthe keys in a binary search tree and we looked at the implementation of the rankfunction for binary search trees where for every key, we can compute how many keysare there that are strictly less than that key.<br><br>5. Simply divide both coordinates by M, andthen look in the two-dimensional array.<br><br>6. But that as the basis, we're able to solve the two dimensional line segmentintersection search using the sweep line algorithm.<br><br>7. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>8. So,that's one dimensional range search using binary search trees.<br>
subtracting|sentence cnt : 2 <br> <br>1. And so then at that point,it's half full, and it can either grow by adding stuff orshrink by subtracting stuff.<br><br>2. Now what we can do is get rid of that sumby subtracting the same equation for N minus one.<br>
texture|sentence cnt : 1 <br> <br>1.The first one is that you have t o check all pairs of balls for overlap so that'squadratic, so it's going to be really, really lot of overall texture you're notgoing to be able to do it for a huge, huge value of N.<br>
please|sentence cnt : 1 <br> <br>1. So with that note please don't think there's something wrong with yourcode if you follow our prescriptive and, and get this warning message.<br>
avoiding|sentence cnt : 2 <br> <br>1. Actually since we copied, we couldoptimize by avoiding these moves.<br><br>2. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br>
typed|sentence cnt : 1 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br>
bunch|sentence cnt : 11 <br> <br>1. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>2. So, here's a bunch of reasons that I justwent through for studying algorithms.<br><br>3. So, normally we have a bunch of dot java files when we're working on anapplication.<br><br>4.Then, we've talked about a bunch of attributes.<br><br>5. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>6.So 2d tree again, it's going to be a datastructure based on a bunch of points that's going to facilitateefficient data processing at these points.<br><br>7. So now, we have a bunch of rectangles.<br><br>8. So we have a, a, a bunch of conventions just toreduce the code.<br>
median|sentence cnt : 7 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. So one thing that we can do is sample theitems, and then take a median of the sample.<br><br>3. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>4.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br><br>5. And so,for example, finding the median and if it's already sorted, it's much easy tofind the median.<br><br>6. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br><br>7. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
naive|sentence cnt : 3 <br> <br>1. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>2. So, how are we going to be able to determinethese intersections efficiently? Now, the natural algorithm, or the naivebrute-force algorithm, is quadratic in time.<br><br>3. And the [cough] Naive Brute-Force Algorithminvolves checking each pair of rectangles for intersection.<br>
southern|sentence cnt : 1 <br> <br>1. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br>
percolates|sentence cnt : 6 <br> <br>1. But in the middle, when it's medium, it's questionable whether itpercolates or not.<br><br>2. And then, when we want to know whetherthis system percolates, we just check whether the virtual top site is connectedto the virtual bottom site.<br><br>3. And wekeep going until we get to a point where the system percolates.<br><br>4. And actually, the threshold between when itpercolates and when it doesn't percolate is very sharp.<br><br>5. So, that's a demo of insertion into a3-node at the bottom, in a 2-3 tree that percolates all the way to the top.<br><br>6. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br>
wanted|sentence cnt : 8 <br> <br>1. Suppose, we wanted to find the minimum key in a binary search tree,or the maximum key.<br><br>2. And correspondingly given a red-black BST then you can get the 2-3tree if you wanted it.<br><br>3. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>4. And what we wanted to do with the temporary four node was to split it andpass the center node up to the root.<br><br>5. I wanted to findthe top k or the medium or other order statistics so that's what selection is allabout.<br><br>6. So like if we wanted to find the minimum item that's k =zero or the maximum item that's k = n - one or the medium that's k = n/2.<br><br>7. You wanted be able to go aroundthe obstacle and it turns out that the shortest path, either it's a straight linefrom s to t or it's part of the convex hull and is not hard to see why that mightbe true.<br><br>8. The bitswere really expensive, and people wanted to make sure, that they were making bestuse of the memory.<br>
rearranged|sentence cnt : 1 <br> <br>1.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br>
logs|sentence cnt : 2 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>2. And you can go ahead and extend thisalgorithm to add functions like logs and sines or other operators and haveprecedence among operators, have them associate and multiple operations, and soforth.<br>
outstanding|sentence cnt : 1 <br> <br>1. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br>
subsets|sentence cnt : 1 <br> <br>1. When we have an equivalence relationa set of objects and connections divide into subsets called connected components.<br>
typically|sentence cnt : 4 <br> <br>1. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>2. Typically, these are set up so that, the, all the data is in the externalnodes.<br><br>3. And typically, indesign rule checking, you wouldn't expect too many intersections.<br><br>4. Now typically, what we'd what a programmer would do is try to figure onmaking M about equal to the number of keys divided by five say.<br>
maintained|sentence cnt : 1 <br> <br>1. The client might have a lot of stacks thatneed to be maintained simultaneously and maybe they reached their maximumcapacities at different times and various other things.<br>
frequency|sentence cnt : 11 <br> <br>1. And now the integer that we'regoing to associate with each word is the frequency of occurrence ofthat word in the symbol table.<br><br>2. So if the word's not in the symbol table,we'll put it there with a frequency of occurrence of 1,that's the first time we saw the word.<br><br>3. [COUGH] For analysis for bigger problems, we'll use a client calleda frequency counter client.<br><br>4. And so that one is going to reada sequence of strings from standard input and print out the one thatoccurs with highest frequency.<br><br>5. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>6. And depending on the frequency of execution of the uncertain delMax operations, that might work out better.<br><br>7. So increment the frequencyin the symbol table.<br><br>8. And then print out the word that occursthe most often, along with its frequency.<br>
inserts|sentence cnt : 5 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>2.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>3. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>4. On the other hand, in a dynamic situationwhere there are a lot of inserts, this method is going to be problematic,because the cost of its insert is linear.<br><br>5. There's an advanced data structure called a Fibonacci heap, where inserts are done in constant time and delete max done in log N time, on average over all the operations.<br>
held|sentence cnt : 3 <br> <br>1. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>2. Just take the three nodesand split them into little binary search tree of size two held together by a redlink.<br><br>3. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br>
preserve|sentence cnt : 6 <br> <br>1. So a stable sort is asort that preserves the relative order of items with equal keys.<br><br>2. Then once we've exchangedit, again, we preserved our invariant.<br><br>3. so let's look at the just the global properties that thesemanipulations preserve.<br><br>4. Actually not all sorts preservethat property that is called stability.<br><br>5. If the client could change the values, how do we know that the heap order operation is preserved? If we want the client to be able to change the values, we're going to provide methods for that purpose as I just mentioned.<br><br>6. And, and in our code, if the two keys areequal, it takes from the left subarray so that means that, it will always take the,if there's a two sets of equal keys, it will preserve the relative order andthat's enough to show that the merge operation is stable and then thereforeMergesort is stable.<br>
activity|sentence cnt : 1 <br> <br>1.This is a so called eager algorithm, for solving kind activity problem.<br>
francis|sentence cnt : 1 <br> <br>1.Another quote from Francis Sullivan, says, "The great algorithms are the poetry ofcomputation.<br>
ntain|sentence cnt : 100 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>4. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>5. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>6. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>7. Nine and four, So now four is the root of the tree containing four is eight.<br><br>8. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br>
unio|sentence cnt : 54 <br> <br>1. So, how are we going to do better? Our first attempt is analternative called, Quick-union.<br><br>2. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>3. So that's a few callsto Union but that's easy to implement.<br><br>4. For the union implementation, we're going tomodify the code to check the sizes.<br><br>5. Alright, so now let's look at the code for implementing Quick-union.<br><br>6. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>7. So, say, four is supposed to be unio n with three.<br><br>8. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br>
diff|sentence cnt : 155 <br> <br>1. We have two different stacks.<br><br>2. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>3. So, one thing is we're usinga different key interface.<br><br>4. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>5. So that's three different clients, three completelydifferent types of data.<br><br>6. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>7. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>8. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br>
somewhere|sentence cnt : 3 <br> <br>1. So, we have to go down the tree somewhere.<br><br>2. Because if K were in the table it would besomewhere between it's hash point five and that empty position nine.<br><br>3. So we're looking for a piece ofinformation somewhere in a computer, and it'll give us the names of the filesthat contain that information.<br>
magical|sentence cnt : 1 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br>
experts|sentence cnt : 3 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. And experts debate about that and people who are interested can lookon the web for that kind of date.<br><br>3. The other thing that's possible to do andit's a little mind bending so recommended only for experts.<br>
initially|sentence cnt : 2 <br> <br>1.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>2. So, initially, we set upthe ID array, with each entry, equal to its index.<br>
loaded|sentence cnt : 2 <br> <br>1. Tells us where, which element is inposition, and then recursively sorts the last part that's loaded, J -one.<br><br>2. In particular,it's known that after you've thrown M balls into the M bins then the most loadedbin has about log M over log M balls.<br>
expository|sentence cnt : 1 <br> <br>1. We use the Java language, but we don'tdwell on details of Java, we mostly use it as an expository language.<br>
environments|sentence cnt : 2 <br> <br>1. So, that's true in many programming environments.<br><br>2. And you can test this out for different types of environments easily andit's representative.<br>
neighbors|sentence cnt : 1 <br> <br>1. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br>
alright|sentence cnt : 15 <br> <br>1.Alright.<br><br>2. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>3. Alright, so, let's take a look at what happens.<br><br>4. Alright, so now let's look at the code for implementing Quick-union.<br><br>5. Alright, so let's just look at each of thealgorithms that we've considered so far.<br><br>6. Alright, so with that mergeimplementation, then the sort implementation is a quite simple,recursive procedure shown here.<br><br>7. Alright, so now about, how do we do a, a search.<br><br>8. Alright so now we're gonna look tosee if we have an intersection what a.<br>
edsger|sentence cnt : 1 <br> <br>1. But, but actually it's a problem that Edsger Dijkstra had proposedin the 70s as an example of, of programming problem.<br>
root|sentence cnt : 128 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>4. Andfor example, the largest of all the keys is at the root.<br><br>5. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>6. We create the array and then set eachelement to be it's own root.<br><br>7. Nine and four, So now four is the root of the tree containing four is eight.<br><br>8. That's restoring the heap border along a path from the place where it's violated to the root.<br>
interpretation|sentence cnt : 5 <br> <br>1. So again, the geometric interpretationis the keys are points in the plane.<br><br>2. Now, in geometric interpretation, we just thinkthat the keys as points on a line.<br><br>3. The interpretation is the two objects, P and Qare connected if and only if, their entries in the array are the same.<br><br>4. It uses the same datastructure or array ID with size M but now it has a different interpretation.<br><br>5. So it's a regular binary search tree butit's got this interpretation based on the geometric data,where we switch which key we use for the comparison, the x coordinate orthe y coordinate at each level.<br>
areal|sentence cnt : 5 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br><br>3. So now,we've got a heap with nine elements and two of the elements in the array arealready in their final position.<br><br>4. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>5. Algorithms arealso interesting to study, because they, they have ancient roots.<br>
applied|sentence cnt : 2 <br> <br>1. This things exist but they're not sowidely applied at in practice.<br><br>2. Now that we've seen efficientimplementations of algorithms that can solve the unifying problem for hugeproblem instances let's look to see how that might be applied.<br>
figured|sentence cnt : 3 <br> <br>1. And it's only in this edition that we figuredout how to make the code this simple.<br><br>2. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>3. But in the1990s we figured out that really this was going to be an effective way to sort.<br>
colors|sentence cnt : 25 <br> <br>1. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>2. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>3. And then we rotate thetop link right and then, we flip the colors.<br><br>4. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>5. Well, you can see from this structure that we'reall set to do that all we need to do actually is not change any links, justchange all the colors.<br><br>6. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>7. And we flip the colors and we have a single fournode.<br><br>8. We have to work through other cases that can arise but there's nottoo many so we'll work through and we have the basic operations, left rotate, rightrotate, and flip colors.<br>
mentality|sentence cnt : 1 <br> <br>1. And our basic search tree mentality and APIs, and binary searchtree data structure give us efficient solutions to these important practicalproblems.<br>
efficiency|sentence cnt : 7 <br> <br>1. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>2. Very little code toimplement the convex hull given that you have a sort and that's our main point forthis lecture - there is many natural applications of sorting but also will beable to develop new algorithms that use sort that gain efficiency because of theefficiency of sorting.<br><br>3. But most people will accept thatand it's a fact and that's how Shellsort gains efficiency.<br><br>4. The idea of complexity is it's a framework for studying the efficiency of all the algorithms for solving a particularproblem.<br><br>5. Our algorithms willgain efficiency by maintaining connected components and using that knowledge toefficiently answer the query that's, that they're presented with.<br><br>6. And this is a fine example anduseful example, of amortized analysis to getefficiency in a stack implementation.<br><br>7. What kindof efficiency might we expect in a selection algorithm.<br>
formalized|sentence cnt : 1 <br> <br>1. Theconcept of an algorithm was formalized actually here at Princeton, by Church andTuring, in the 1930s.<br>
stimulation|sentence cnt : 4 <br> <br>1. This, this kind of stimulation is enabledby priority queues.<br><br>2. Another reason to studyalgorithms is for intellectual stimulation.<br><br>3. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br><br>4. Algorithms are interesting for intellectual stimulation.<br>
deleted|sentence cnt : 3 <br> <br>1. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>2. Each point has to be inserted, deleted.<br><br>3. So maybe a node got deleted down there, but always the invariant is, that the count of the node is one plus size the left and right, and then return x and fix the links from the counts on the way up.<br>
tends|sentence cnt : 5 <br> <br>1. We say that our generic type Key extendsComparable of Key.<br><br>2. And as we'll see this extendsto a practical problem in a number of situations.<br><br>3. There's ways toimplement that don't involve this, but its, the code is so simple and it extendsto more powerful data structures later on that we'll introduce this right now and,and you'll see how it works.<br><br>4. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br><br>5. Linear probing tends to make better use of space.<br>
resort|sentence cnt : 1 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br>
incorporated|sentence cnt : 1 <br> <br>1. Andthis was taking a look at the Qsort that a user found was broken and, and now, thismethod is incorporated into some plenty of system sorts.<br>
accurate|sentence cnt : 6 <br> <br>1. But use the center of mass andyou get a very accurate [COUGH] approximation tothe N-body doing that.<br><br>2. With this fast algorithm we can get an accurate answer to the scientificquestion.<br><br>3. Not an easyanalysis, but we actually could make precise accurate statements about theperformance of this algorithm.<br><br>4.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br><br>5. If we use a slow Union-find algorithm we won't be able to run it forvery big problems and we won't get a very accurate answer.<br><br>6. The problem is nobody knows an accurate model for describingthe number of compares taken by Shellsort for any interesting increment sequence.<br>
advance|sentence cnt : 9 <br> <br>1. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>2. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>3. We pull out the current item and then advance the current reference andreturn item.<br><br>4. We do somemath, but not advanced math.<br><br>5. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>6. Then, to get rid of the first node,we just advance our pointer to the first item on the listto point to the next item.<br><br>7. These are so simple that wewon't go in too much detail, but still it's worthwhile to takea look at them to set the stage for the more advanced implementationswe'll consider next.<br><br>8. There's an advanced data structure called a Fibonacci heap, where inserts are done in constant time and delete max done in log N time, on average over all the operations.<br>
students|sentence cnt : 8 <br> <br>1. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>2. Andso, I think most students have had high school Physics and will be able to do, dothis Math or at least be convinced that the code that does this Math is correct.<br><br>3. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br><br>4. So our insistence in this course is thatstudents should not use the library until we've implemented it in class.<br><br>5. And the firstone called by name implements a comparator for students and when you compare twostudents by name, it's going to use the string comparative method.<br><br>6.Always, in this class, we have an exercise or exam question is this version of thissort stable or not? So, students learn to recognize whether the code is stable.<br><br>7. Here's a war story fromstudents Programming assignments not that long ago.<br><br>8. So[cough] here is just an example of what happens if would those implementedcomparators for that class student using the Java system sort, if you call arraythat sort with your a rray of students and you give it this by name comparator, itwill put them in order alphabetical order by the name field.<br>
reasonably|sentence cnt : 1 <br> <br>1. And also, itwouldn't be reasonably efficient at all for large data sets.<br>
consequence|sentence cnt : 4 <br> <br>1. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. [COUGH] So, the idea andthe consequence of this is, if you insert N items into an array, intoa stack with this array representation, the time will be proportional to N,not N squared.<br><br>4. So the mistake happens if we put all the items equal to thepartitioning item on one side which is a natural way to implement it and theconsequence is if you have all the keys equal, then partitioning doesn't really doanything.<br>
turning|sentence cnt : 6 <br> <br>1. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>2.>> So red turning to black means what? >> Budget deficits, red ink, black ink.<br><br>3. It's turning the wrong way and it's turning to the right.<br><br>4. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br><br>5. So now, we go on to 5 - turning the wrong way.<br><br>6. Again, when we look at moresophisticated values we'll be returning something else.<br>
coordinate|sentence cnt : 24 <br> <br>1.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>2. So, we're going to keep trackof y coordinates in a binary search tree.<br><br>3. Sosweeping from left to right means we consider each x coordinate as an event.<br><br>4. The other thing is, ifyou take the point with the lowest y coordinate.<br><br>5. And again, to keep the code simplewe're going to assume that all the coordinates are distinct.<br><br>6. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>7. Well we're going to hit the leftendpoint first, and so what we'll do when we hit the left, endpoint is, insert, they coordinate of that line into a binary search tree.<br><br>8. What's the next smallest xcoordinate? In this case it's the line number one there, and we'll remember its ycoordinate in a binary search tree.<br>
consult|sentence cnt : 1 <br> <br>1. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br>
contains|sentence cnt : 21 <br> <br>1. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>2. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>3. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>4. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>5. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>6. We're going to read every word in the fileif the symbol contains does not contain theword.<br><br>7. Now we search the left sub-tree andwe want to check if it contains point 3.<br><br>8. We search for the node that contains the key.<br>
whereas|sentence cnt : 9 <br> <br>1. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>2. Whereas what we can hope for and what weactually will achieve is to get log N time for all operations, time proportion to log Nfor all operations.<br><br>3. Whereas on the other hand, sometimes the whole purpose of a data type is to maintain a changing value.<br><br>4. Whereas binary search, you just iterate through, the things in order.<br><br>5. And also it'llperform better for huge tables whereas caching is involved.<br><br>6. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br><br>7.So what is the Quicksort method? It's also a recursive method, but thebasic idea behind Quicksort is that it does the recursion after it does the work,whereas Mergesort did it before it did the work.<br><br>8. Whereas, Mergesort has to move the itemsinto and out of the auxiliary array, which is more expensive.<br>
topm|sentence cnt : 1 <br> <br>1. So we're going to look at a client program called TopM that takes thecommand-line argument, how many and this case, it's going to say five and thenit's going to take from standard input the transactions and it will print out the topfive.<br>
remarkably|sentence cnt : 1 <br> <br>1.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br>
mechanism|sentence cnt : 8 <br> <br>1. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>2. Differentlanguages have different mechanisms.<br><br>3. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>4. So the Java language helps us with thisComparable mechanism so that we can sort data of any type.<br><br>5.Next we'll take a look at comparatorswhich is a Java mechanism that helps us sort.<br><br>6.In the way that, that happens is a mechanism known as a callback.<br><br>7. So, that'sour basic question, how can sort, now, how to compare data of all those differenttypes without being given any information about the type of an item's key? And theanswer is that what is we set up a mechanism known as a callback or referenceto executable code where the client, by passing an array of objects to the sortfunction.<br><br>8. So what are we going to do with those two links? Well, the Hibbard deletion mechanism which is pretty old, 50 years ago it was proposed, says go ahead and find the next smallest node in the right sub-tree of that tree.<br>
crashes|sentence cnt : 1 <br> <br>1. Actually it usually crashes because it's recursive andit crashes the system stack.<br>
till|sentence cnt : 43 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. So first we exchange it with the 10,it's still not in place, so we exchange it with the 7.<br><br>3. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>4. That's still a BST.<br><br>5. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>6. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>7. X's color is stillgoing to be h's color.<br><br>8. That doesn't work i, t still becomes square root of n.<br>
forest|sentence cnt : 1 <br> <br>1. We aregoing to think of that array as representing a set of trees that's calleda forest as depicted at right.<br>
bolt|sentence cnt : 13 <br> <br>1. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>2. And a good way to think of a symboltable is as shown in the right here.<br><br>3. It's possible to implement symboltables that allow multiple values with the same key and so forth.<br><br>4. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>5. So now we're going to build a symboltable.<br><br>6. So, in that case, it'll build a symboltable with IP addresses as keys and we can type in an IP address and get theassociated URL.<br><br>7. We saw that we can use binary search to get an efficient symboltable implementation.<br><br>8. So that's a straightforward and simple scheme for implementing symboltables with hashing.<br>
execution|sentence cnt : 1 <br> <br>1. And depending on the frequency of execution of the uncertain delMax operations, that might work out better.<br>
super|sentence cnt : 4 <br> <br>1.And again, a good algorithm is much better than having a super computer.<br><br>2. And a supercomputer can do it in aninstant.<br><br>3. Even on a super computer, if you're usinginsertion sort nowadays it'd maybe take a week ormore.<br><br>4. You could spendmillions on a super computer, and maybe you could get it done in six years insteadof 30, or in two months but with a fast logarithm, you can do it in seconds, inseconds on your own PC.<br>
introduce|sentence cnt : 3 <br> <br>1. And really it doesn't makesense if you don't know about comparators which we just introduced.<br><br>2. There's ways toimplement that don't involve this, but its, the code is so simple and it extendsto more powerful data structures later on that we'll introduce this right now and,and you'll see how it works.<br><br>3.That's the only time the height of a 2-3 tree changes, when the roots splits theheight introduces increases by one.<br>
achieving|sentence cnt : 1 <br> <br>1. And one of the things we'll look at is algorithms thatcome very, very close to achieving that goal.<br>
presented|sentence cnt : 7 <br> <br>1. The thing is remember represented in array one two three and so forth.<br><br>2. So that's a basic implementation of priority queues using the heap data structure represented as an array.<br><br>3. And maybe the way the keys are represented.<br><br>4. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>5. So that's complete binary trees represented in array with keys in the nodes, satisfying heap order property.<br><br>6. So if we go left and then left, thatmeans all the points to the left of 1 and above 3, so the square in the upper leftis represented by that node in the tree.<br><br>7. Our algorithms willgain efficiency by maintaining connected components and using that knowledge toefficiently answer the query that's, that they're presented with.<br>
checked|sentence cnt : 3 <br> <br>1. Now if we get our, our eight and nineconnected, we just checked that they have the same root and they both have the sameroot eight and so they're connected.<br><br>2. It says that we're using unchecked or unsafe operations and we shouldrecompile with a minus -Xlint equals unchecked for details.<br><br>3. So, we can go aheadand do that and it says that you have put in, in your code an unchecked cast andwe're warning you about that cuz you shouldn't be putting in unchecked cast.<br>
josh|sentence cnt : 1 <br> <br>1. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br>
stick|sentence cnt : 1 <br> <br>1. We're going to stick to thisassociative array abstraction and no duplicate keys in the symbol table, because it both simplifies implementationsand leads to simpler client code.<br>
guide|sentence cnt : 6 <br> <br>1. Now, here's an example where we want to use theory as a guide.<br><br>2. But still again, using theory as a guide maybe there's a way to decrease costs a little bit from binary heaps.<br><br>3. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br><br>4. This is another example where we use theory as a guide.<br><br>5. Say well, we'll leave the key in the tree to guide searches, but we won't count it as being in the symbol table.<br><br>6. So , what we want to take from thesetheoretical results is, is a guide when we're looking at implementations andtrying to solve practical problems.<br>
transformation|sentence cnt : 10 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. But now you can see that, that localtransformation on the 2-3 tree completes the insertion.<br><br>3.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>4. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br><br>5.If the parent was a 2-node then the transformation is a local transformationand if you look at where the links are, then it's easy to see by induction that ifthere was perfect balance before there's perfect balance afterward,Because we didn't change anything about the perfect balance in any of thosesubtrees.<br><br>6. And youcan see from this transformation that it's easy to perform this, see thiscorrespondence the middle link between A and B, those are the keys that are lessthan B and larger than A.<br><br>7. So as I've mentioned and this diagramshows, the splitting of 4-node and a 2-3 tree is a local transformation.<br><br>8. And also wemaintain perfect black balance because we didn't change the black height, height ofanything by doing this transformation.<br>
binary|sentence cnt : 117 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>3. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>4. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>5. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>6. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>7. So, we're going to keep trackof y coordinates in a binary search tree.<br><br>8. [COUGH] All right, so this is the code for the get operation andthis rank which is binary search.<br>
went|sentence cnt : 17 <br> <br>1. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>2. So, here's a bunch of reasons that I justwent through for studying algorithms.<br><br>3. It was named as one of the most importantalgorithms of the twentieth century and it's widely used for system sorts and manyother applications.<br><br>4. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br><br>5. Now, that element which went from the bottom to the top is most likely going to violate the heap order, it's going to be smaller than one or its both of its children, so we do a sink.<br><br>6.And, and, so for, if N is a thousand, that's going to be ten, if N is a millionthat's twenty, if N is a billion that's 30.<br><br>7. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br><br>8. If Ngrows from a million to a billion, that cost goes from twenty to 30, which isquite not acceptable.<br>
sorted|sentence cnt : 85 <br> <br>1. You can see it's got the first half sorted, now it's working on the secondhalf.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>4. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>5. Suppose we want to test if an array is sorted.<br><br>6. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>7. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>8. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br>
radix|sentence cnt : 1 <br> <br>1. That's quicksort, mergesort, heapsort and radix sorts.<br>
even|sentence cnt : 135 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>3. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>4. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>5. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>6. Even though we know we're not using it,the Java system doesn't know that.<br><br>7. But even if you take the absolute value.<br><br>8. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br>
suspect|sentence cnt : 1 <br> <br>1. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br>
index|sentence cnt : 70 <br> <br>1. It says thatindex one has got 0.<br><br>2. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>3. To push an item,we use N to index into the array, put the item there and then increment N.<br><br>4. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>5. In the third case now,when i is at the third entry in the array, now we start a index j, andwe move that starting at i to the left.<br><br>6. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>7. Then wehave a for loop that goes through every element in the array, we keep a variablemin in that is the index of the going to be the index of the smallest element tothe right of pointer i.<br><br>8. And to pop, we decrement the index and then use it to returnthe item in the array.<br>
rearranges|sentence cnt : 1 <br> <br>1.sort is a method that takes anarray a as its parameter and it, it's the first argument and it rearranges thestrings in that array to be in sorted order.<br>
forces|sentence cnt : 2 <br> <br>1. And there's no other forces involved.<br><br>2. It gets more complicated ifthere's more forces, like gravity involved.<br>
solve|sentence cnt : 40 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>2. Nowhow we are going implement or solve this problem or you can think of lots of waysto go ahead and solve this problem of finding the largest M items in the streamof N items.<br><br>3.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br><br>4. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>5. It soonbecame clear that those mathematical models were difficult to solve.<br><br>6. And the other thing we can do with this is just use a red-black BSTto guarantee that we solved this in time proportional to log in.<br><br>7. Now that we've seen efficientimplementations of algorithms that can solve the unifying problem for hugeproblem instances let's look to see how that might be applied.<br><br>8. We modeled theproblem to try to understand precisely what kinds of data structures andalgorithms we'd need to solve it.<br>
anywhere|sentence cnt : 2 <br> <br>1.Or, did we use comparators anywhere here? In, this Index will tell us no.<br><br>2. Anywhere between ten and twenty willimprove the running time by maybe twenty%.<br>
necessary|sentence cnt : 5 <br> <br>1. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>2. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br><br>3. And the very first thing that we actually do is just compare and exchange if necessary the first twoelements.<br><br>4. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br><br>5.But that's not really necessary nowadays, as long as you've done the, random shuffleOh, and by the way, Quicksort is not stable cuz partitioning does one of thoselong range exchanges that might put a, a key with equal value over a key anotherkey with the same value.<br>
adapt|sentence cnt : 4 <br> <br>1. So people have developed all differentkinds of methods for adapting in this way.<br><br>2. The way wemaintain, there's a number of ways we can maintain the thing but the one that we'lladopt un iformly because it adapts to more complicated situations is just beforewe're done with the put operation we'll say, okay we've done all our work andbefore we return the pointer to the given subtree we're going to take the size ofwhat's on the left and the size of what's on the right and add one for us and that'sgoing to be our count.<br><br>3. We need to adapt to the data.<br><br>4. So we need a data-structurethat more gracefully adapts to the distribution of the data.<br>
maximal|sentence cnt : 1 <br> <br>1.A connected component is a maximal set of objects that's mutually connected.<br>
dates|sentence cnt : 9 <br> <br>1. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>2. So, that's an example of animplementation of Comparable by implementing the compareTo() method to putdates in order as you might expect.<br><br>3. So now, if you want to compare two different dates then the first thing to dois to check if this year is less than that year, over that is the year given, thedate given in the argument.<br><br>4. So, after the classdeclaration, we write implements Comparable and then we fill in the genericwith the same type because we're only going to compare dates to other dates.<br><br>5. Just go ahead and return the link to that child, and that updates the link and everything works fine.<br><br>6.Now, again, many of Java's standard types for numbers and dates and files and soforth implement compareTo() by convention.<br><br>7. Two dates should be equal if they havethe same day, month, and year and if any one of those are not the samevalue then just returns false.<br><br>8. Like theintegers or natural numbers or real numbers or alphabetical order for strings,chronological order for dates or times and so forth.<br>
prerequisite|sentence cnt : 2 <br> <br>1. People often ask aboutprerequisites.<br><br>2. If you want to review the material that we think isprerequisite for the material in this course, you can do a quick review bylooking at sections 1.<br>
label|sentence cnt : 1 <br> <br>1. Down atthe bottom is one of those important one is in image processing for understandinghow to label areas in images.<br>
degenerate|sentence cnt : 2 <br> <br>1. If we allow delete, in fact everything degenerates to square root of n.<br><br>2. This points out examples of howdifficult computational geometry can sometimes be because degenerate caseslike these are difficult to deal with in code.<br>
powers|sentence cnt : 3 <br> <br>1. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>2. Shell's original idea is to try powers to two minus one andthat works okay.<br><br>3. One of the firstthings you might think of is let's try powers of two.<br>
leipzig|sentence cnt : 1 <br> <br>1. And we'll want this client towork well for huge data sets, so leipzig is a data set fromthe web of 20 million orders.<br>
driven|sentence cnt : 9 <br> <br>1. So figuring outthe value of dt that would really work is a huge problem for the time drivensimulation.<br><br>2. So, now we canlook finally at the main event driven simulation loop.<br><br>3. Instead, what we want to do is called an event driven simulation.<br><br>4. So now,let's look at the main loop for the event driven simulation.<br><br>5. But what's nice about data driven code is now that the code's workingand again we, we're not saying that this is a trivial code to write but it'sdefinitely manageable.<br><br>6. So this is data driven code.<br><br>7. So, one idea is the so-called time drivensimulation.<br><br>8. Today, we're goingto talk about event-driven simulation which is an interesting idea that is basedon priority queues but it's also used in numerical computation and we'll see inalgorithms for data compression and graph searching that it's useful.<br>
cutting|sentence cnt : 1 <br> <br>1. And this is going to be very efficientbecause as we get closer and closer to the query point, we're cuttingout all the sub queries that are away.<br>
flajolet|sentence cnt : 1 <br> <br>1. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br>
unlikely|sentence cnt : 3 <br> <br>1. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>2. Quadratic time worstcase but that's unlikely to occur if you do the random shuffling.<br><br>3. Ittakes quadratic time in a worse case even though we make that unlikely by randomshuffling.<br>
throws|sentence cnt : 1 <br> <br>1. And all it does is divides by 2 again andthen throws out another 1.<br>
hits|sentence cnt : 10 <br> <br>1. When it hits the wall is, is just going to change the velocity.<br><br>2. Consider it as aevery time it hits some line segment as an event where we have to do something.<br><br>3. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br><br>4.So, if you know that you have a particle that's at a certain position or x or y andhas got a certain velocity, the x in the x-direction and y in the y-direction, thenyou can from the distance to the pro, vertical wall you can figure out how manyseconds this is going to take until it hits it.<br><br>5. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>6. And then these tests are for whether it hits the walls in which case, you haveto flip the x or y velocity.<br><br>7. So that's read this loop,reads in all the data and associates each word withits frequency of occurrence.<br><br>8.Why is it redundant? Well, the partitioning element is sittingthere and it'll stop when it hits the partitioning element.<br>
terminology|sentence cnt : 1 <br> <br>1. The terminology that we use ispushed to in certain items and pop to remove the itemmost recently added.<br>
subtle|sentence cnt : 1 <br> <br>1. This is oneof those mathematical facts that seems obvious but then if you try to prove thatmaybe it's a little more subtle than you think.<br>
upside|sentence cnt : 1 <br> <br>1.And this one is kind of upside down as compared to Mergesort.<br>
vector|sentence cnt : 15 <br> <br>1. So, here's what the implementation of a sparsevector might look like.<br><br>2. So let's start by just looking at vectors.<br><br>3. So, it's a dot product that takestime proportional to the number of non-zero entries in the vector.<br><br>4. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>5. And so a constructor for an immutable vector data type, it might take an array as its argument.<br><br>6.As a final example of a symbol tableclient, we'll take a look at a mathematical application where we want toimplement sparse vectors and matrices.<br><br>7. And we just use that for every non-zeroentry in the vector.<br><br>8. So now if wehave a sparse matrix times a vector our running time is going to be constant foreach row or proportional to the number of non-zero entries for each row which meansthat the running time is going to be linear for a sparse matrix just by the useof a symbol table.<br>
require|sentence cnt : 24 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>5. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>6. And it's a requirement that if x and y are equal then theirhash code should be equal.<br><br>7. So there is going tobe situations that are going to require an understanding of what it takes to engineera, a sort method that's appropriate for your application.<br><br>8. So that kind of meets thesetwo requirements for Java.<br>
bushes|sentence cnt : 1 <br> <br>1. So 16 bushes at the end there.<br>
shortcut|sentence cnt : 2 <br> <br>1. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>2. And so client programs andsystem programs on the Java system were having terrible performance on theirsymbol table because of the shortcut in hashing.<br>
tracks|sentence cnt : 2 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. A red black tree tracks everysimple path from a node to a descendant leaf with the same number of black nodesthey got that rig ht.<br>
faster|sentence cnt : 25 <br> <br>1. And the question is, can we do better? Can we have a faster way to shuffle? Do we really need to pay the cost of a full sort? The answer to that question is, no.<br><br>2. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>3. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>4. We have less wasted space and probablyfaster implementation of each operation.<br><br>5. And it'll probably be faster for simple keys to use hashing.<br><br>6. So in the first case, it's much, much faster than selection sort,linear instead of quadratic.<br><br>7. So now we're going to have tolook at can this code be effective for large problems? Well unfortunatelyQuick-union is faster but it's also too slow.<br><br>8. And since stack is used inthe inner loop of some algorithms, it's important to think abouteven faster implementations.<br>
appended|sentence cnt : 1 <br> <br>1. For example, if you have a large arraywith just a few, that's sorted except for just a few unsorted elementsappended at the end, it's going to be partially sorted.<br>
crash|sentence cnt : 4 <br> <br>1. Actually it usually crashes because it's recursive andit crashes the system stack.<br><br>2. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br><br>3. And somebody's implemented a service in Java that it uses a simp letable that takes string keys, you can cause that to crash in this way.<br><br>4. And, and in the real world you cannowadays find on the web particular sequences of keys that will causeparticular services to crash.<br>
generalizes|sentence cnt : 7 <br> <br>1. And that one generalizes to help us insert into a two node at thebottom.<br><br>2. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>3. It generalizes thestack and the queue and gives us a data structure that we can use to effectivelydesign algorithm of all sorts.<br><br>4. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>5. Today, we're going to lookat Priority Queues which is a variant of sorting that generalizes the idea toprovide more flexible data structure that we can use for all sorts of applications.<br><br>6. And the reason we do this is that it generalizes to giveus more efficient data structures later on.<br><br>7. And then the proof is generalizes what I talked about on thedecision tree on the last side, slide.<br>
really|sentence cnt : 103 <br> <br>1. The client really can'tknow how big the stack is.<br><br>2. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>3.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>4. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>5. And the question is, can we do better? Can we have a faster way to shuffle? Do we really need to pay the cost of a full sort? The answer to that question is, no.<br><br>6. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>7. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>8. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br>
ition|sentence cnt : 234 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>4. So the goal is socalled three way partitioning.<br><br>5. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>6.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>7. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>8. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br>
described|sentence cnt : 5 <br> <br>1. There's an easy way to do this based on CCW that is described here inthis text.<br><br>2. The whole partitioning process forthree-way partitioning and the modern programming language like Java simplymaintains the invariances described in the demo.<br><br>3. And the bottom line is that we can articulate anAPI for generic stacks that works for any type of data and we've got twoimplementations, link list and arrays that, that performed very well for [cough]any type of data using the, the resizing or link list as we've described.<br><br>4. But, the bottom line is, you should be able t oprogram, and the quick exercise to get ready is, to write a java program on yourcomputer perhaps using a programming model, as described on the book site.<br><br>5. We've described the operations we want toimplement all the way down to code and we have client code that we're going to haveto be able to service with our.<br>
counting|sentence cnt : 4 <br> <br>1. We're only counting the number oftimes we access the pages.<br><br>2. So [cough] so, for example whatabout one-dimensional range counting? Well, what we're going to do is just keepthe keys in a binary search tree and we looked at the implementation of the rankfunction for binary search trees where for every key, we can compute how many keysare there that are strictly less than that key.<br><br>3. We build a data structure containingpoints that can efficiently support range searching and range counting.<br><br>4. For insert and, and for counting.<br>
adapting|sentence cnt : 1 <br> <br>1. So people have developed all differentkinds of methods for adapting in this way.<br>
evaluating|sentence cnt : 1 <br> <br>1. A way of evaluating a polynomial ora number.<br>
reduces|sentence cnt : 4 <br> <br>1. It reduces to this case.<br><br>2. Slightly reduces the number of compares.<br><br>3. And what we do is use a function known asa hash function that takes the key that our symbol table key andreduces it to an integer, an array index, and we use that array index to storethe key and the value in an array.<br><br>4. So, the bottom line is that the sweep linealgorithm takes this rectangle intersection problem and reduces it to 1Dinterval search and we have an efficient algorithm for that problem and thatenables us to solve the problem in linear rhythmic time instead of quadratic time.<br>
billions|sentence cnt : 4 <br> <br>1. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br><br>2. So we could have,billions of objects, and hope to do billions of union commands on them.<br><br>3. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br><br>4. A very rough standard, say for now, is that people have computers that can runbillions of operations per second, and they have billions of entries in mainmemory.<br>
simulating|sentence cnt : 2 <br> <br>1. And the idea is we want to study some property of thenatural world by simulating it.<br><br>2. How good is that? [MUSIC] >> So, this is a simple model developedby Craig Reynolds a while ago for simulating the situation called the boid.<br>
transaction|sentence cnt : 11 <br> <br>1. And that willfill in the fields and then, we put that transaction on the priority queue.<br><br>2. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>3. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>4. So how about implementing a hash code forour own type of data? And so our transaction type might have a couple of instance variables,a string, a date, and a double.<br><br>5. We readthe line, build the transaction from the information on that line.<br><br>6. So and this is just some test datawhere we've got all, all these transactions and so we are going to beable to take in data like this and again an unbounded stream of data.<br><br>7. And just a very, very huge number of transactions.<br><br>8. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br>
operand|sentence cnt : 3 <br> <br>1. The operandstack the operator stack is string, it could be characters which is just ouroperator.<br><br>2. We have operands andoperators and you want to evaluate it.<br><br>3. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br>
layer|sentence cnt : 2 <br> <br>1. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>2. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br>
initialized|sentence cnt : 3 <br> <br>1. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>2. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>3. For convenience, we'll provide a constructor that takes the key and valueas argument and fills in the key and value instance variables then the left and rightlinks are initialized to null.<br>
during|sentence cnt : 9 <br> <br>1. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>2. This gives exactly what happens duringeach of the calls to merge.<br><br>3. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>4.In the, all during the partitioning process, the code is maintaining thisinvariant.<br><br>5. Number of items that have to be touchedduring quick sort.<br><br>6. And the idea isthat during the construction of a tree, or during an insertion operation, sometimeswe wind up with red links that are leaning in the wrong direction.<br><br>7.During and after partitioning.<br><br>8. So, during this course you'll be referring tothe book site frequently while working online.<br>
depends|sentence cnt : 8 <br> <br>1.Plus what happens next depends on what the partitioning element was.<br><br>2. Notice again that it depends on the randomshuffle at the beginning that's going to be important for performance.<br><br>3.Now, the constant depends on the implementation, exactly what kind ofmanipulations we need to do to convert, 3-nodes to 4-nodes and so forth.<br><br>4. It depends on the arraybeing randomly ordered.<br><br>5. Then, how about space usage? That depends very much onthe implementation and the machine so this is a typical Java implementationthat we do the analysis for.<br><br>6. So it depends on how the keyscome in.<br><br>7. In fact,almost any computer application system is going to have a symbol table ormultiple symbol tables at its core all the way down to the basicmemory system of the computer or the networking system that your computeraccess to information depends on.<br><br>8. But the point is, the tree shape depends onthe order of insertion.<br>
location|sentence cnt : 2 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. To use an array, we just keep the nitems on the stack in the array and the array locationwith index N is the place, the top of the stack,where the next item is going to go.<br>
linear|sentence cnt : 65 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>3. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>4. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br><br>5. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>6. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>7. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>8. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br>
questionable|sentence cnt : 1 <br> <br>1. But in the middle, when it's medium, it's questionable whether itpercolates or not.<br>
clean|sentence cnt : 2 <br> <br>1. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br><br>2. So, it's going to go through every particleand call the time to hit method for that particle.<br>
knowledge|sentence cnt : 2 <br> <br>1. So here's the Java library implementationsfor a few standard types and they are what they are andwhat we'll do is we acknowledge that that'swhat the hash code is.<br><br>2. Our algorithms willgain efficiency by maintaining connected components and using that knowledge toefficiently answer the query that's, that they're presented with.<br>
number|sentence cnt : 187 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>3. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>4. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>5. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>6. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>7. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>8. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br>
midpoint|sentence cnt : 2 <br> <br>1. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br><br>2. Then it computes the value of the midpointsame way as we did for a binary search.<br>
fourth|sentence cnt : 3 <br> <br>1. So, an h-sorted array is h different inter leaves sortedsub-sequences so in this case with h=4 if we start at L and look at everyfourth element - M, P, T - then it's sorted.<br><br>2. Howdo we arrange to do something is natural as this in our Java sorts? Now, we use thefourth in order to be able to implement sorts that can sort any type of data, weuse Java's Comparable interface.<br><br>3. If we start in the second place at E and lookat every fourth element, it's sorted.<br>
horizontal|sentence cnt : 27 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>3. Sofirst thing is if we hit a horizontal line segment.<br><br>4. So now 5 comes in, that's to the left of 4because it was partitioned at a vertical and 5's going to partitionin a horizontal.<br><br>5.So, any point that's inside that interval, is going to represent a horizontal linesegment that is an intersection.<br><br>6. They're alloriented horizontal or vertical.<br><br>7.So say your geometric objects are points in the plane and you specify a rectanglethat's oriented with the horizontal/vertical axes.<br><br>8. Another kind of eventis that we hit the right endpoint of a horizontal line segment.<br>
functions|sentence cnt : 16 <br> <br>1. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>2. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>3. We have the swim and sink functions that we showed earlier.<br><br>4. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>5. That's the summary for hash functions.<br><br>6. And so the, it's the concept of so called one way hash functions whichmean that we, we, use it for secure to try to be, have some secure fingerprints foruse on the web.<br><br>7. Now for standard keys like integers andstrings and doubles and so forth,we can count on the designers and implementors at Java toimplement good hash functions.<br><br>8. So, so the way the compilers implement functions is using stacks.<br>
textbook|sentence cnt : 3 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. And then supporting that textbook, is free onlinematerial that we call the book site.<br><br>3.And you'll find textbook implementations or implementations out on the web thatwind up running in quadratic time in certain situations.<br>
lesson|sentence cnt : 1 <br> <br>1. So, the lesson isthat we can develop good algorithms or good implementations without much code butthere are some out there that are still waiting discovery.<br>
undergraduates|sentence cnt : 1 <br> <br>1. In fact, some were discovered by undergraduates in a course,course like this.<br>
trace|sentence cnt : 20 <br> <br>1.If you look at this visual trace you can see how it works.<br><br>2. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>3. So this is a trace of whatwould happen for our trace.<br><br>4.Again, studying this, a, a trace like this, gives a, a good feeling for exactlywhat's going on in the recursive program.<br><br>5. So we can do about twice as many itemsin the trace in the same amount of time.<br><br>6. So that's a trace of implementing binarysearch to find the rank of a key in ordered array.<br><br>7. This is a bigger trace that shows, again, about half the elements belowthe diagonal are involved in the sort.<br><br>8. [cough] And actually, in typical applications with any kind ofrandomness or even if there is a lot of order its difficult to find situationsorders of keys that build the trace of height is bigger than actually one log Nin, in a real application, its very close to fully balanced all the time.<br>
carta|sentence cnt : 1 <br> <br>1. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br>
obstacle|sentence cnt : 2 <br> <br>1. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br><br>2. You wanted be able to go aroundthe obstacle and it turns out that the shortest path, either it's a straight linefrom s to t or it's part of the convex hull and is not hard to see why that mightbe true.<br>
concepts|sentence cnt : 1 <br> <br>1. Those are some basic data structuresand implementations and it seem quite elementary and simple but actually rightaway we can get to some very sophisticated applications of these basic concepts andthat's what we're going to consider next.<br>
section|sentence cnt : 61 <br> <br>1. And now 2123 does intersect 1622, so wereturn and intersection.<br><br>2. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>3. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>4. Say, for this fictionalclass Student, that's got two instance variables - name and section.<br><br>5. Just check for anintersection, if we find it ret urn if left is no we go right.<br><br>6. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>7. Alright so now we're gonna look tosee if we have an intersection what a.<br><br>8. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br>
structure|sentence cnt : 115 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>3. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>4. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>5. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>6. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>7. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>8. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br>
leaf|sentence cnt : 3 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. And there's got to be atleast one leaf for each possible ordering.<br><br>3. A red black tree tracks everysimple path from a node to a descendant leaf with the same number of black nodesthey got that rig ht.<br>
external|sentence cnt : 9 <br> <br>1. So, for example, this is a external, this is M = six.<br><br>2. And we're, we're going to look at a more general model forexternal storage.<br><br>3. Typically, these are set up so that, the, all the data is in the externalnodes.<br><br>4. And those have to have ex, externallinks or tree links connecting them to some other node.<br><br>5. Sothe real property of external storage that not your local memory, is that the timerequired to get to a page is way larger than the time to access data within apage.<br><br>6. So what we want to do is try to access data that's out, externally, usinga minimum number of probes.<br><br>7. Thisis an external five node.<br><br>8. And then when you get to anexternal node you just look for and so that's a, that's the all searchesterminated in external node, in other words that's just a generalization of whatwe just did.<br>
engineer|sentence cnt : 2 <br> <br>1. So there is going tobe situations that are going to require an understanding of what it takes to engineera, a sort method that's appropriate for your application.<br><br>2. In fact Quicksort, which we'll consider next time, was honored as one of the top 10 algorithms of the 20th century inscience and engineering.<br>
illustration|sentence cnt : 1 <br> <br>1. Anillustration of all the different operations that a client might want.<br>
stops|sentence cnt : 3 <br> <br>1. But this general purpose implementationstops the pointers on keys equal to the partitioning items key and we'll take alook at why that's important in a minute.<br><br>2.So, in this example the i pointer stops right away because it's pointing to an rwhich is bigger than the partitioning element.<br><br>3.The j pointer decrements until it gets to the c which it stops there which is lessthan the partitioning element.<br>
object|sentence cnt : 97 <br> <br>1. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>2. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>3. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>4. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>5. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>6. And then a series of pairs of object names.<br><br>7. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>8. That is, every object's connected to itself, it'ssymmetric.<br>
relative|sentence cnt : 8 <br> <br>1. And there's a relatively easy wayto do that.<br><br>2. So a stable sort is asort that preserves the relative order of items with equal keys.<br><br>3. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>4. All those subtrees, those three subtrees areexactly the same relative to the top and bottom of the tree, as they were beforethe rotation.<br><br>5. And this is a fine data structure forsymbol tables where there is, [COUGH] that are relatively static, where the values don't change much,and most of the operations are search.<br><br>6. In a new method called, relativelynew method called Cuckoo Hashing.<br><br>7. And to just show that this thing gets thesort done with touching relatively few elements.<br><br>8. And, and in our code, if the two keys areequal, it takes from the left subarray so that means that, it will always take the,if there's a two sets of equal keys, it will preserve the relative order andthat's enough to show that the merge operation is stable and then thereforeMergesort is stable.<br>
heavily|sentence cnt : 1 <br> <br>1. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br>
milliseconds|sentence cnt : 2 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br>
eighth|sentence cnt : 1 <br> <br>1. And so what they decided in the first implementationwas let's just look at every eighth or ninth character, and that way, we don'thave to spend a lot of time computing the hash function.<br>
been|sentence cnt : 28 <br> <br>1. So, that's an answer to the question for people t hat have beenasking.<br><br>2. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>3. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>4. It would have beenvery exciting.<br><br>5. So this is, we'll start withone dimension as before and right away you can see that it's a more complicatedproblem than we've been dealing with.<br><br>6. Sothe, search is, you know, just the same as we've been doing, just generalized.<br><br>7. And there's also a variable called count, which is the number ofcollisions of particles have been involved in.<br><br>8. In this one of many different algorithmsthat have been studied for this.<br>
exactly|sentence cnt : 35 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. This gives exactly what happens duringeach of the calls to merge.<br><br>3. Again, exactly as what would happen in a2-3 tree.<br><br>4. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br><br>5. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>6. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br><br>7. Sothat, that means you'd have, if you did exactly and [inaudible] + n/2 + n/4 and soforth which adds up to about two N compare so linear cross.<br><br>8.Again, studying this, a, a trace like this, gives a, a good feeling for exactlywhat's going on in the recursive program.<br>
involving|sentence cnt : 4 <br> <br>1. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>2. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>3. So rest assured these types ofalgorithms lie at the heart of any program you use that isinvolving a lot of geometric data.<br><br>4. Costing involving in the ray axises justto do the find operation and that's going to be too slow if you have a lot ofoperations.<br>
probably|sentence cnt : 12 <br> <br>1. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>2. We have less wasted space and probablyfaster implementation of each operation.<br><br>3. And it'll probably be faster for simple keys to use hashing.<br><br>4. Probably should do that.<br><br>5. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br><br>6. So Integer with the capitalized rapid typefor int and so forth and many of you were probably familiar with that.<br><br>7. The other thingthat is probably more significant on modern machines is.<br><br>8. Probably a bad idea to use the first threedigits of the phone number as a hash function because so many phonenumbers will have the same area code.<br>
multiplicand|sentence cnt : 1 <br> <br>1. We have atwo-dimensional matrix one-dimensional column vector for the multiplicand and theresult.<br>
download|sentence cnt : 3 <br> <br>1.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>2. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>3. Nowadays you more likelyto do that online or when you're trying to find the song todownload, you provide the name of the song and then the value will tell youwhat computer got her to get that.<br>
interview|sentence cnt : 3 <br> <br>1. Another importantreason is that if you know effect, how to effectively use algorithms and datastructures you're going to have a much better chance at interviewing for a job inthe technology industry then if you don't.<br><br>2. And they might ask you theseon your job interview too.<br><br>3.Now there is more complicated versions of Mergesort and Quicksort that can do thisin theory but Heapsort is pretty simple algorithm that gets both done, so in a jobinterview somebody asks you what's an in-place sorting algorithm that'sguaranteed N lg n? Your answer's going to be Heapsort.<br>
were|sentence cnt : 53 <br> <br>1. And now 2123 does intersect 1622, so wereturn and intersection.<br><br>2. In fact, some were discovered by undergraduates in a course,course like this.<br><br>3. So here's the review of where we were withsingle tables.<br><br>4. But most algorithms that we consider, were discovered inrecent decades.<br><br>5. So, now suppose we were supposed to add S.<br><br>6. Ourproblem we were treating partitioning, equal of partitioning element as one valueless than as another and greater than as another.<br><br>7.Now, if that parent were a 3-node, it would become a temporary 4-node and wouldcontinue the process moving up the tree.<br><br>8.And so, for example, what this table shows, if you were to tryto use a insertion sort for a huge file, say a file with a billion elements,on your PC it'd take a few centuries tofinish.<br>
prescriptive|sentence cnt : 1 <br> <br>1. So with that note please don't think there's something wrong with yourcode if you follow our prescriptive and, and get this warning message.<br>
porous|sentence cnt : 1 <br> <br>1. Or, you could think of it as, as water flowing through a poroussubstance of some kind.<br>
symmetry|sentence cnt : 1 <br> <br>1. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br>
warm|sentence cnt : 3 <br> <br>1. As a warm up, let's suppose that wehave a string, a collection of stings.<br><br>2. So now, let's look at the second warm-up.<br><br>3. Alright, so first, warm up, insert into a tree withexactly one node.<br>
circuit|sentence cnt : 3 <br> <br>1. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>2. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>3. So, we get to use the faster and bigger computer to build faster and biggercircuits but that doesn't help if you're using a quadratic algorithm.<br>
vacant|sentence cnt : 4 <br> <br>1.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>2. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>3. Where a vacant side is just empty and a block side hasgot some material, and either the water flows through from top to bottom, or not.<br><br>4. So if we, we aretalking abouta randomized model where the sites are vacant with the givenprobability.<br>
graphics|sentence cnt : 3 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>2. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>3. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
andrew|sentence cnt : 1 <br> <br>1. So, another undergraduate in an algorithmsclass discovered this idea for N-body simulation and that's Andrew Appel.<br>
some|sentence cnt : 238 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>3. At leastthat some indication that you understand the performance characteristics.<br><br>4. In fact, some were discovered by undergraduates in a course,course like this.<br><br>5. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>6. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>7. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>8. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br>
nuclear|sentence cnt : 1 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
canadian|sentence cnt : 1 <br> <br>1. He was quiteexcited because he was watching a re-run on, of an English actually Canadian TVshow on French TV.<br>
sert|sentence cnt : 243 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2. So to insert N items,it's about three array accesses.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. So,without any extra special code we insert a node into an empty tree.<br><br>5.Suppose we're inserting K.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. Just put them in anarray, and then, well, insertion is, is fast.<br><br>8. So, with just two exchanges we insert that new element into the heap in this case.<br>
returned|sentence cnt : 10 <br> <br>1. So in this case, that first callwill return a link and whatever link gets returned, that will be set to root.<br><br>2. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>3. But otherwise, it's a simple modification ofrecursive tree search to find all the keys and it's easy to see the running time tothat is going to be proportional to the number of keys returned plus log N.<br><br>4. It's going to be cre ated a new node and the link to that node will be returnedand that's the link that we'll put in the left.<br><br>5. So they just returned the value.<br><br>6. But what we'll do is invoke a recursive method starting at the root andwhatever link gets returned, we'll set that to root.<br><br>7. Now,when it's returned then that's the point at which we're going to check whether theleft, the links are leaning to the left as they are suppose to and whether or notthere are any double links or not.<br><br>8. And the running time will be proportionalto the number of points returned, plus log N.<br>
comes|sentence cnt : 33 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>3. So in this case, we have an example where T, the node T here its value changes and it becomes larger than its parent key, P.<br><br>4. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>5. For whatever reason a parent becomes the key and decreases, it might become smaller than one or both of its children's.<br><br>6. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>7. That doesn't work i, t still becomes square root of n.<br><br>8. It comesinto the node on the left.<br>
enables|sentence cnt : 4 <br> <br>1. So that's something that isa convention that's built into Java and that enables the hash code to be used forhashing.<br><br>2. Next we're going to talkabout Binary Search Trees, a classic data structures that'll enables us to provideefficient implementation of symbol table and out rhythms.<br><br>3. Now, and what's mostimportant to recognize about this is that its the algorithm design that enables thesolution to the problem.<br><br>4. So, the bottom line is that the sweep linealgorithm takes this rectangle intersection problem and reduces it to 1Dinterval search and we have an efficient algorithm for that problem and thatenables us to solve the problem in linear rhythmic time instead of quadratic time.<br>
beginning|sentence cnt : 31 <br> <br>1. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>2. And to implement a stack when we do a push operation, we insert a new node atthe beginning of the linked list.<br><br>3. Atthe beginning, 0->1 is a line that's on the convex hull.<br><br>4. So after this operation, we're firstpointing to the beginning of the list.<br><br>5. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>6. And we start the k Pointer at thebeginning lo.<br><br>7. So atthe beginning we're going to be fine.<br><br>8. But, in linear probing, to insert what we do is when we put it inposition I if that's free, if not we just look at I plus one, and I plus two, andwrap around to the beginning if we reach the end.<br>
scientifc|sentence cnt : 1 <br> <br>1. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br>
possibilities|sentence cnt : 1 <br> <br>1. So those are the basic operationsthat we're going to want to implement to get the associative arrayabstraction and then there's many, many possibilities for clients andwe'll look at some later on.<br>
choose|sentence cnt : 10 <br> <br>1.The idea is to arbitrarily choose the first element to be the partitioningelement.<br><br>2. And then, it's easy to seethat what you should choose is M to be about square root of N.<br><br>3. The client can have many differentimplementations from which to choose, but the client code should onlyperform the basic operations.<br><br>4. So what we want to choose is this squaresize that would best balance these two needs.<br><br>5. And it's important for us to know that theory and that willhelp us decide how to choose which algorithms we're going to use in practice,and where to concentrate our effort in trying to find better algorithms.<br><br>6. And on the other thing is it's not stable,sometimes people choose to use Mergesort in practice because of the stability butHeapsort isnot stable for the usual reason that it does long distance exchanges thatmight bring items that have equal keys back out of order.<br><br>7. And then, the data structuresdiffer on the basis of which item we choose to delete.<br><br>8. And arbitrarily we choose to change the ones that are thesame as P to the ones that are same as Q.<br>
testing|sentence cnt : 7 <br> <br>1. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>2. And if it's array of objects,you can see that testing for equals can actually involvea lot of code and a lot of cost.<br><br>3. If we have a full stack,which we know by testing N, which is the number of items inthe stack versus the array length, then we just resize the array into one of twicethe length before inserting the item.<br><br>4. And then isEmpty is just testing whetherthe first note on the list is null.<br><br>5. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br><br>6. The client is always going to betesting hasNext() as I showed as I showed and that stub code before and so when itgets to null it will return false in the iterational stop.<br><br>7.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br>
importance|sentence cnt : 1 <br> <br>1.And that definitely enabled new progress in technology and it's a fine example ofthe importance of algorithmic technology.<br>
couple|sentence cnt : 23 <br> <br>1. Now there's a couple ofconventions around null.<br><br>2. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>3. And that's useful for a couple ofpurposes.<br><br>4. They have to be in the same class and well there's a couple of differentways to check about the same class and that's another religiousdebate that we'll ignore.<br><br>5. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>6. So how about implementing a hash code forour own type of data? And so our transaction type might have a couple of instance variables,a string, a date, and a double.<br><br>7. We'll look at couple of elementary priority queue implementationsthat are straightforward.<br><br>8. Okay, so now, let's look at a coupleof test clients before we look at any particular implementation.<br>
vans|sentence cnt : 1 <br> <br>1. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br>
continuing|sentence cnt : 3 <br> <br>1. So now continuing along we put a star on.<br><br>2. In continuing on the right perhaps the nextcompare is a less than c and maybe if c is less than a, then another compare, b lessthan c.<br><br>3. So now, we have the two andthree in order, continuing that way.<br>
link|sentence cnt : 197 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. B and this b treewould go down the left link.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>5. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>6. But we have to use a little extra time andspace to deal with the links.<br><br>7. Links can be null.<br><br>8. And to implement a stack when we do a push operation, we insert a new node atthe beginning of the linked list.<br>
analyzed|sentence cnt : 1 <br> <br>1. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br>
sufficiently|sentence cnt : 1 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br>
trap|sentence cnt : 1 <br> <br>1. We'll read a new word, andwe'll ignore the short strings, just trap out if the wordlength is too small.<br>
processors|sentence cnt : 1 <br> <br>1. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br>
characterize|sentence cnt : 1 <br> <br>1. Sothere needs to be a mathematical analysis to, to characterize the running time ofthis program in the fact is that quick select this method takes linear time onthe average.<br>
aircraft|sentence cnt : 1 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
objects|sentence cnt : 63 <br> <br>1. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>2. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>3. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>4. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>5. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>6. They're going to have a set of N objects.<br><br>7. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>8. In particular if you just haveN union commands on N objects which is not unreasonable.<br>
simulations|sentence cnt : 5 <br> <br>1.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>2. And those simulations are only enable by fast union findalgorithms, that's our motivating example for why we might need fast union findalgorithms, so let's look at that.<br><br>3. And that's where we get the result that, by runningenough simulations for a big-enough n, that this, percolation threshold is about.<br><br>4. The only solution we have comes from acomputational model, where we run simulations to try and determine the valueof that probability.<br><br>5. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
consistent|sentence cnt : 2 <br> <br>1. And also, we have to update the count, something happened down below, and we use that code to update the counts in a consistent way.<br><br>2. And you're also going to want to makecompareTo consistent with equals.<br>
concatenation|sentence cnt : 1 <br> <br>1. If you want a new string, you have to create a new string using concatenation or some other operation.<br>
brute|sentence cnt : 3 <br> <br>1. Problem with that is, that would be a brute forcealgorithm.<br><br>2. So, how are we going to be able to determinethese intersections efficiently? Now, the natural algorithm, or the naivebrute-force algorithm, is quadratic in time.<br><br>3. And the [cough] Naive Brute-Force Algorithminvolves checking each pair of rectangles for intersection.<br>
occupy|sentence cnt : 2 <br> <br>1.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>2. And then since it has to go down by one, the place to remove the element from the heap is at the end of the array because it's now going to have to not occupy that position.<br>
hashing|sentence cnt : 45 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>3. So you have to use hashing if you don't havethe comparison.<br><br>4. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>5. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>6. And it'll probably be faster for simple keys to use hashing.<br><br>7. Hashing really at its core isa classic space-time tradeoff.<br><br>8. So here's just simple example onhashing in java.<br>
turns|sentence cnt : 29 <br> <br>1. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>2. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>3. If they're equal, it returnstrue.<br><br>4. If get returns in non null value, then there's a value correspondingto that key in the table.<br><br>5. In particular,all Java classes inherit a method called hash code which is returnsa 32-bit int value.<br><br>6. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>7. So, we're goingto use a method less() that takes two Comparable objects as arguments and itjust returns, v.<br><br>8. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br>
worked|sentence cnt : 5 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>3. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>4. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br><br>5. Andagain nobody's claiming that this is easy but this is the Physics part and it'sworked out and it comes from Newton's Second Law.<br>
tells|sentence cnt : 11 <br> <br>1. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>2. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>3. So, then that tells uswhat time it's going to be next.<br><br>4. Tells us where, which element is inposition, and then recursively sorts the last part that's loaded, J -one.<br><br>5.And what about the analysis? Well, again this the [cough] standard probabilisticanalysis of the balls and bins problem tells us a lot of information of what goeson.<br><br>6. And then, what the priority queue tells us is - let's organize it in some ways that we are always taking the best one to processnext.<br><br>7. So, what arewe supposed to do when two different keys hash to the same index? The birthdayproblem tells us that we're going to have collisions.<br><br>8. And contains a simpler operation than get its convenient for manyclients where it just tells us whether there's some value paired with thatkey in the table is empty in size.<br>
cannot|sentence cnt : 3 <br> <br>1.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>2. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>3. Of course, we cannot get down to having constant time for all operations.<br>
continuous|sentence cnt : 2 <br> <br>1. Where, we work with continuous blocks of data that are big.<br><br>2.Group of four key, continuous keys in a table space there is called a cluster andclearly we want to keep those clusters small.<br>
inversions|sentence cnt : 4 <br> <br>1. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>2. And the proof is, the number ofcomparisons and the number of exchanges is equal to the number of exchanges equalto the number of inversions, and there's an extra compare forevery element except the first.<br><br>3. This array has six inversions.<br><br>4. So this array has six inversions, T and R are out of order,because R should go before T.<br>
successful|sentence cnt : 7 <br> <br>1. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>2. And if it's unsuccessful, you can use that rank to figureout where to insert the new key.<br><br>3. So, for example, for Q,that's an unsuccessful search.<br><br>4. If you try to do it without it, you're not going to besuccessful.<br><br>5. What about an unsuccessful search? Well the same rules follow.<br><br>6.Let's take another example for unsuccessful search, a key that's not inthe tree.<br><br>7. And again, for successful,you can use that rank to return the value.<br>
purpose|sentence cnt : 7 <br> <br>1. So, in, in fact, often, the purpose of a sort isto bring items with equal keys together for like the example that I gave where wehad cities and time.<br><br>2. Whereas on the other hand, sometimes the whole purpose of a data type is to maintain a changing value.<br><br>3. And that's useful for a couple ofpurposes.<br><br>4. But this general purpose implementationstops the pointers on keys equal to the partitioning items key and we'll take alook at why that's important in a minute.<br><br>5.sort and it's intended to be ageneral purpose sorting method for use by Java programmers.<br><br>6. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br><br>7. If the client could change the values, how do we know that the heap order operation is preserved? If we want the client to be able to change the values, we're going to provide methods for that purpose as I just mentioned.<br>
looks|sentence cnt : 11 <br> <br>1. So let's look ata demo of how it looks.<br><br>2. And we'll see how that looks in just a second.<br><br>3. So let's look at how itlooks now.<br><br>4. So let's see how that looks in a demo.<br><br>5. That data structure iscalled a bag and so let's look at what that API looks like.<br><br>6. Here's what it looks like for a bigger array.<br><br>7.This looks like a fairly daunting equation, but actually it's not toodifficult to solve.<br><br>8. So let's look at whatthat code looks like.<br>
deletes|sentence cnt : 2 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>2. And since as with stack and queue operations, theseinsert and deletes might be intermixed in arbitrary ways and there might be hugenumbers of them either one of these is very attractive because they're going totake N times the number of operations.<br>
requirement|sentence cnt : 7 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>3. And it's a requirement that if x and y are equal then theirhash code should be equal.<br><br>4. So that kind of meets thesetwo requirements for Java.<br><br>5. How do we test if two objects are equal? So Java has got requirements as forcomparative and here's the basic requirement about equals.<br><br>6. And also no object is equal to null, so those are absolute requirements for Java.<br><br>7. In a few applications, this might be fine, but in many many applications,that's too onerous of requirement.<br>
visual|sentence cnt : 8 <br> <br>1.If you look at this visual trace you can see how it works.<br><br>2. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>3.So you got a visual feeling of how this sort getsthe job done.<br><br>4. It's a good visual representation of how Mergesort gets its job done.<br><br>5. Now, but let's look at what's happened or visualize whathappens when keys come in, in random order.<br><br>6. So, let's look at avisualization.<br><br>7.Here's a visual trace of 3-way Quicksort for situation with plenty of equal keys.<br><br>8. Andjust looking at this trace of selection sort and operation really is a proof,visual proof of this proposition.<br>
selections|sentence cnt : 4 <br> <br>1.Selections or uses about N^2 / 2 compares and exactly n exchanges.<br><br>2. [cough] and that gives us immediately our code for the selectionsort implementation.<br><br>3. The quickbottom line is that insertion sort and mergesort are stable but not selectionsort or Shellsort.<br><br>4. But then, once wefound it, we only have to swap two cards those are both key properties of selectionsort.<br>
prune|sentence cnt : 1 <br> <br>1. Supposed to search the right subtreeat 1 next, but we can prune that.<br>
property|sentence cnt : 18 <br> <br>1. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>2.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>3. And then we can use, that property of the trees, in theanalysis to, show that, it's not going to be very many probes to get to any key.<br><br>4. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br><br>5.Actually, some implementations of Quick Sort out in the wild don't have thisproperty, and they suffer a little bit in performance.<br><br>6. And another property is that youcan't sort moving less data because selection sort does just a linear numberof exchanges.<br><br>7. So we have to again prove that property by induction.<br><br>8. Stability is an important property in sorting algorithms.<br>
interesting|sentence cnt : 33 <br> <br>1. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>2. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>3.Now, what's interesting about binary search trees is that there are manydifferent binary search trees that correspond to the same set of keys.<br><br>4. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>5. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>6. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br><br>7.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br><br>8. So, it's an interesting question to think about forsure.<br>
store|sentence cnt : 28 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>3. In this case we, wefind H as the left sub tree of R in [cough] that's a search hit and then forthe get operation, we can return the value that's stored in that node along with thekey H.<br><br>4. And another natural way to implementa stack is to use an array to store the items on a stack, solet's take a look at that.<br><br>5. But we're gonna store the, largest endpoint inthe subtree rooted at that node.<br><br>6. And so we can pick some numbers that we can store.<br><br>7. But we're also in the, each node of the tree, we'regonna store, not just the interval.<br><br>8. So, maybe we can store millions or thousands of them.<br>
averaged|sentence cnt : 2 <br> <br>1. We have a good amortized time, so totalaveraged over the whole process is good.<br><br>2. So that's called amortized analysis, where we consider the total costaveraged over all operations.<br>
shape|sentence cnt : 3 <br> <br>1. But the point is, the tree shape depends onthe order of insertion.<br><br>2. We don't get any benefit from having it in a treeshape.<br><br>3. The shape of the, of the tree could be well in the best case so it wouldbe perfectly balanced.<br>
graphic|sentence cnt : 9 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>2.And as this graphic integrates, it just does it by saving the information on astack.<br><br>3.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br><br>4. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>5. Again, it's not too good to use the firstthree digits because they're associated with some geographic region andit's better to use the last three digits.<br><br>6. So this is just a graphical representationif we want to compute D of N we want to computeD of N over 2 twice.<br><br>7. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>8. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
instance|sentence cnt : 28 <br> <br>1. And then we set its instance variables.<br><br>2. In the instance, methods won't change them and the client can't change them.<br><br>3. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>4. Say, for this fictionalclass Student, that's got two instance variables - name and section.<br><br>5. And that will reset our instance variable, which is our stack,to this new, bigger array.<br><br>6. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>7. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>8. And thenthe sort code can just use that compareTo() method, invoked in a sense of theobject like an entry in the array and as argument and another instance in theobject like another entry in the array to test whether the first is less than thesecond as in this example.<br>
vertices|sentence cnt : 4 <br> <br>1. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>2. And then if you look at thepolar angle with respect for every other point with the respect to that one, so theangle you get from of the x-axis through p up to the point, then the vertices appear inincreasing order of that angle.<br><br>3. If we've got some points that are on the boundary but aren'treally vertices they shouldn't be included.<br><br>4. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br>
either|sentence cnt : 31 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. They're either connectedor not then that will take quadratic time in squared time.<br><br>3. Sopoint 2 can't be on the convex hull either.<br><br>4. The first thing to check is find out which one is bigger, it's either 2k or 2k plus one and so set J accordingly.<br><br>5. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>6. If neither one exhausts, we need exactly Ncompares.<br><br>7. Now, because it's 7-sortedand a 3-sort elements are either already in placed or on a go back a fewstrides.<br><br>8.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br>
ordered|sentence cnt : 50 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>3. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>4. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>5. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>8. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br>
watching|sentence cnt : 2 <br> <br>1. Watching the [unknown], this is a balanced tree gettingconstructed in the worst case where everything that comes in is in ascendingorder.<br><br>2. He was quiteexcited because he was watching a re-run on, of an English actually Canadian TVshow on French TV.<br>
markers|sentence cnt : 1 <br> <br>1. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br>
opportunity|sentence cnt : 1 <br> <br>1.with mergesort is a good opportunity totake a look at the intrinsic difficulty in the sorting problem, now that is calledcomplexiting and we'll look at that next.<br>
pointing|sentence cnt : 19 <br> <br>1. So after this operation, we're firstpointing to the beginning of the list.<br><br>2. And then what we can do, is just return that node's right link, then that old node, nobody's pointing to it, so it's available for garbage collection.<br><br>3. We have only one link and we can get rid of the node, but we have only one link pointing to it, but we have two links pointing down from it.<br><br>4. Now with i equals two, i pointing to the second card, we generate a random integer between zero and i.<br><br>5. And again it 's pointing to one that'sequal of partitioning element increment i.<br><br>6. So nowwhat happens here, now i is pointing to a bigger one so we're going to exchange itwith the one at gt and decrement gt again.<br><br>7. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>8. Now we increment I, as long as it'spointing to an element that's less than the partitioning element.<br>
make|sentence cnt : 140 <br> <br>1. So the clustering in the data is going tomake the implementation inefficient.<br><br>2.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>3. Make sure that both first andlast are always what we want them to be.<br><br>4. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>5. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>6. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>7. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>8. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br>
credit|sentence cnt : 4 <br> <br>1. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>2. He's widely accredited as being theinventor of Mergesort.<br><br>3. Or like the one at the bottom credit cards.<br><br>4. Maybe, you runa credit card company and you want to check for stolen cards then your keyswould be numbers.<br>
alternating|sentence cnt : 3 <br> <br>1. It's guaranteed that the longest path which is alternating red andblack can be no more than twice as long as the shortest path which is all blacks.<br><br>2. If the client happens to dopush-pop-push-pop alternating when the array is full, then it's going tobe doubling, having, doubling, having, doubling, having.<br><br>3. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br>
billi|sentence cnt : 13 <br> <br>1. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>2. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br><br>3. So we could have,billions of objects, and hope to do billions of union commands on them.<br><br>4.And so, for example, what this table shows, if you were to tryto use a insertion sort for a huge file, say a file with a billion elements,on your PC it'd take a few centuries tofinish.<br><br>5.And, and, so for, if N is a thousand, that's going to be ten, if N is a millionthat's twenty, if N is a billion that's 30.<br><br>6. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br><br>7. If Ngrows from a million to a billion, that cost goes from twenty to 30, which isquite not acceptable.<br><br>8. Andalso nobody racks up a, a set of billiard balls such that all fifteen are touchingin all places.<br>
vectors|sentence cnt : 3 <br> <br>1. So let's start by just looking at vectors.<br><br>2.As a final example of a symbol tableclient, we'll take a look at a mathematical application where we want toimplement sparse vectors and matrices.<br><br>3. So, here's an example, say using the data type for vectors, might be a way to implement vectors.<br>
unbounded|sentence cnt : 1 <br> <br>1. So and this is just some test datawhere we've got all, all these transactions and so we are going to beable to take in data like this and again an unbounded stream of data.<br>
performance|sentence cnt : 54 <br> <br>1. And how close it could get to full withoutsacrificing performance.<br><br>2. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>3. At leastthat some indication that you understand the performance characteristics.<br><br>4. For detailed information ona performance, eval grievance.<br><br>5. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>6. And that has profound impact on theperformance of this algorithm.<br><br>7. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br><br>8. And so that's the st ory of red-black BST's guaranteedlogarithmic performance for all symbol table operations.<br>
wisdom|sentence cnt : 1 <br> <br>1. Nowuntil the 1990s, conventional wisdom among people implementing system was, wasn'tworth doing this.<br>
felt|sentence cnt : 1 <br> <br>1. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br>
subdivision|sentence cnt : 1 <br> <br>1. And what we're going to look atas one of the most widely used, which is basically to usea tree to represent a recursive subdivision of the plain,of two-dimensional space.<br>
miles|sentence cnt : 1 <br> <br>1. [MUSIC] And it happens everyday,right through the winter, just a couple of miles from my doorstep.<br>
completes|sentence cnt : 6 <br> <br>1. But now you can see that, that localtransformation on the 2-3 tree completes the insertion.<br><br>2.And that completes our treatment of sorting algorithms with the Heapsortalgorithm.<br><br>3. So that, that, that'sour full summary of sorting algorithms to and completes our treatment of sortingalgorithms with Heapsort.<br><br>4. It's a little mind bending atfirst because of the recursive structure but it won't take you long to convinceyourself that this little bit of extra code completes the implementation ofleft-leaning red-black trees.<br><br>5. So, thatcompletes our summary for a symbol table implementations with red-black BSTs.<br><br>6. As soon as we hit 12 we seethat 11 can't be on the convex hull and 10 can't be on the convex hull andthat completes the computation of the convex hull with the Graham Scan.<br>
resources|sentence cnt : 2 <br> <br>1. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>2. [cough] So, for this course we have two resources that I wantto talk about and make sure that people are familiar with before entering into thecontent.<br>
look|sentence cnt : 366 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3.If you look at this visual trace you can see how it works.<br><br>4. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>5.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>6. Like using anotherhatch function rather than looking at the next entry.<br><br>7. So, let's look at the proof of that.<br><br>8. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br>
positions|sentence cnt : 16 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>3. And so the first way we'll look at is called Separate Chainingand it's a very diagonal idea back1953, and the idea is just build a link list foreach of the table positions.<br><br>4. The one that it doesn'tmaybe meet is the idea that every table positionshould be equally likely.<br><br>5. And then we 1-sortand again because of the fact that it's been 7-sorted and 3-sorted, thearrays are almost in order when it comes time to do the 1-sort and most of theitems only go back one or two positions.<br><br>6. So, that's a, asimple simulation to just generate random positions.<br><br>7. It's another variant of linear probing where wehash a key to two positions and insert the key in either one.<br><br>8. We've removed the maximum and we still have our data structure heap order and our N keys stored in the first N positions in the array.<br>
programmings|sentence cnt : 3 <br> <br>1. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>2. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>3. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br>
unto|sentence cnt : 2 <br> <br>1. The amount used is between 8N and 32N, depending on how full the array is and just a quick analysis of the amountof space that arrays take in Java.<br><br>2. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br>
structures|sentence cnt : 39 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>3. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>4. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>5. We use to implementlinked list in all linked data structures throughout the course, weuse what's called an inner class in Java.<br><br>6. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br><br>7. Those are some basic data structuresand implementations and it seem quite elementary and simple but actually rightaway we can get to some very sophisticated applications of these basic concepts andthat's what we're going to consider next.<br><br>8. Next we're going to talkabout Binary Search Trees, a classic data structures that'll enables us to provideefficient implementation of symbol table and out rhythms.<br>
winds|sentence cnt : 6 <br> <br>1. So, it goes down to the middle, and windsup needing to be inserted in the, 3-node in the middle.<br><br>2.So the easy case is if the key winds up in a 2-node at the bottom, like this one.<br><br>3. And in the worst case if the randomshuffle winds up putting the items exactly in order, then partitioning doesn't,doesn't really do anything except find the smallest, peel off the smallest item.<br><br>4. Even though they came in, in ascending order, the treewinds up being perfectly balanced.<br><br>5. And then after it gets to that worse case it also winds up beingcompletely balanced when we have a power of two.<br><br>6. Actually that one doesn'twork at all, very well at all because it winds up not comparing elements in evenpositions with elements in the odd positions until the 1-sort which meansperformance can be bad.<br>
urls|sentence cnt : 3 <br> <br>1. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br><br>2. And then, if we want to look up theIP address associated with a given URL we can just type in URLs and the client willreturn the IP address, it'll do the look up.<br><br>3. In this example or CSV file relates URLs to IP addresses.<br>
looked|sentence cnt : 29 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. Is there a simple algorithm that is linear? And people, looked for along time for that, and actually it works out to be the case that we can prove thatthere is no such algorithm.<br><br>3. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>4. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br><br>5. We have an inter-for loop that for j, if it finds asmaller one, resets min and then once we've looked at all the elements to theright of i we exchange the smallest one with i.<br><br>6. It's actually not so different from the elementary implementations that we looked at in the last section.<br><br>7. So [cough] so, for example whatabout one-dimensional range counting? Well, what we're going to do is just keepthe keys in a binary search tree and we looked at the implementation of the rankfunction for binary search trees where for every key, we can compute how many keysare there that are strictly less than that key.<br><br>8. And we've already looked atan algorithm that can do this, and that's binary search.<br>
overlap|sentence cnt : 3 <br> <br>1. So given a queryinterval, we want to find all intervals in the data structure that overlap thatinterval or find any interval we'll start with that simpler problem.<br><br>2.The first one is that you have t o check all pairs of balls for overlap so that'squadratic, so it's going to be really, really lot of overall texture you're notgoing to be able to do it for a huge, huge value of N.<br><br>3. And it's easy to tell whether anyof them could fall in the range by just checking whether they're range overlapsthe root or not.<br>
seek|sentence cnt : 3 <br> <br>1. You can figure out from the last index when you don't find yourelement that you're seeking.<br><br>2. So, what we want to find is so say, we're seeking the floorof G.<br><br>3. Now, what we seek ideallyis what's called an optimal algorithm where we prove that the upper bound andthe lower bound are the same.<br>
disastrous|sentence cnt : 2 <br> <br>1. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>2. There's akiller input for the system sort and, and it can be disastrous in various systemsand the reason is, they didn't do the random shuffling.<br>
triggered|sentence cnt : 1 <br> <br>1. And they had a complex error recovery process that,that got triggered if the height limit got too big.<br>
perfectly|sentence cnt : 6 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. Interesting to think just, justabout this case and to prove to yourself that it's always going to be perfectlybalanced when it's descending.<br><br>3. Now, we could use a interval bag or some data structure likethat and hide the link list structure underneath and that's a perfectly fine wayto proceed in modern programming.<br><br>4. Even though they came in, in ascending order, the treewinds up being perfectly balanced.<br><br>5. A complete binary tree is one that's perfectly balanced, except possibly for the bottom level.<br><br>6. The shape of the, of the tree could be well in the best case so it wouldbe perfectly balanced.<br>
profound|sentence cnt : 1 <br> <br>1. And that has profound impact on theperformance of this algorithm.<br>
entries|sentence cnt : 34 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2. All have entries eight.<br><br>3. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>4. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>5.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>6. And so, symbol tables provide us with a way to provide a moreefficient implementation of, of this process when we have lots of zero entries.<br><br>7. And fiveand zero have different entries.<br><br>8. So if we're going to union six and one,then we have to change entries zero, five, and six.<br>
taxpayers|sentence cnt : 1 <br> <br>1. Youwant to return how many taxpayers have salaries between one million and tenmillion and then which ones are they and so forth.<br>
iterate|sentence cnt : 16 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. And then another thing that you mightwant to do is iterate through all the keys in the table.<br><br>3. To remove a key, and maybereturn the number of keys in the set, and also have an iterator to iterate throughkeys in the set.<br><br>4. So, what we do is try to figure out why, find a way to addresswhatever's causing that problem, find a new algorithm and iterate until we'resatisfied.<br><br>5. Whereas binary search, you just iterate through, the things in order.<br><br>6. And the iterable just returns allthe key to iterate.<br><br>7. So, what we want to do is to allow the client to iteratethrough the items in the collection.<br><br>8. We want to add something to thecollection, maybe remove something from the collection and iterate throughthe objects in a collection, performing some operation on them,and of course test if it's empty.<br>
interdisciplinary|sentence cnt : 1 <br> <br>1. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br>
degenerates|sentence cnt : 1 <br> <br>1. If we allow delete, in fact everything degenerates to square root of n.<br>
fair|sentence cnt : 7 <br> <br>1. And usually that's fairly straightforward.<br><br>2. Actuallyfairly easy to understand why it works.<br><br>3. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>4. So again, that's, fairly little code, to implement, a fastsymbol table and insert, search and insert.<br><br>5.This looks like a fairly daunting equation, but actually it's not toodifficult to solve.<br><br>6. Well, each one of these operations are fairly straightforward but just to check our ability to manipulate this data structure, we'll takea look at each.<br><br>7. You can see in the top the big tree has some trees, some nodes, a fairdistance from the root.<br>
converting|sentence cnt : 1 <br> <br>1. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br>
complications|sentence cnt : 1 <br> <br>1. As we'll see, all symbol table implementations lead to complications when we try to do this operation.<br>
customer|sentence cnt : 1 <br> <br>1. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br>
separated|sentence cnt : 5 <br> <br>1. And in general, a CSVfile might have many fields separated by comma, comma.<br><br>2. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>3. So we take the file name as thefirst command line argument, read in array of string from that file separated byblanks, call an Insertion.<br><br>4. The first will be a file name, a so-called common separated value fileand the next two arguments are integers which will tell us what to treat as keysand values in the file.<br><br>5. So,each line has a URL and IP address and are separated by commas.<br>
list|sentence cnt : 109 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>3. In this case, we'll have the word, the file list.<br><br>4. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>5. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>6. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>7. And to implement a stack when we do a push operation, we insert a new node atthe beginning of the linked list.<br><br>8. So a blacklist clientwould print out all the words in our source file, tinyTale.<br>
apply|sentence cnt : 10 <br> <br>1.We apply for n - one we get one less here and we can throw out a lot two over n.<br><br>2. We can associate the keywith null internally then apply or know the differencewhether that's in there or not.<br><br>3. So this code is thebasis for applying the sort, system sort method or any sort method for the Grahamscan for the convex hull that we did at the end of the last lecture.<br><br>4. Then if you have a field that'sit's an array you can go ahead and try applying it to each entry andthere's implementations in Java.<br><br>5. If it's a reference type,use that hashCode and apply recursively.<br><br>6. The first term on the right hand side isexactly the same as the left hand side so we can apply thesame formula.<br><br>7.So we can apply the same equation so its two over n + one.<br><br>8. And if you have an array,you have to apply it to each entry.<br>
normal|sentence cnt : 4 <br> <br>1. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>2. So, normally we have a bunch of dot java files when we're working on anapplication.<br><br>3. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>4. Okay, so again start out in our normal starting position, whereeverybody's in their own tree.<br>
listiterator|sentence cnt : 1 <br> <br>1. In this case, we'll call itListIterator that implements Iterator and it's generic.<br>
representation|sentence cnt : 24 <br> <br>1. The array representation, all we do is we put, we start with indices at 1.<br><br>2. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>3. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>4. But we don't have the client to know whetherwe're using an array or link list or whatever internal representation we mighthave in mind.<br><br>5. So first before we get to the code for insertion, we haveto look at the representation.<br><br>6. [cough] Let's look at thebasic Binary Search Tree data structure with Heaps we talk about implicitrepresentation of trees with an array.<br><br>7. Our representation is an array of keys and a size, that's the number of items in the heap.<br><br>8. [COUGH] So, the idea andthe consequence of this is, if you insert N items into an array, intoa stack with this array representation, the time will be proportional to N,not N squared.<br>
arranged|sentence cnt : 4 <br> <br>1.Once we have it arranged in that way, then we recursively sort the two parts.<br><br>2. For example,if they're all arranged in a circle and your query point's in the center orsomething of that sort.<br><br>3.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br><br>4. With geometric data,the worse case can be bad, so like all the points couldbe arranged in a circle.<br>
interpreting|sentence cnt : 1 <br> <br>1. One, having to deal with compiling from aprogramming language or interpreting into an actual computation and then the otherone is the PostScript language which is widely used for, for printing andpublishing.<br>
aspect|sentence cnt : 2 <br> <br>1. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>2.So this aspect of red-black BSTs is an extremely nice one because of theoperations that we implemented for regular BSTs that involves some complicated codefor floor and ceiling and rank and so forth, and we don't have to change thatcode at all.<br>
address|sentence cnt : 26 <br> <br>1. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>2. And then, if we want to look up theIP address associated with a given URL we can just type in URLs and the client willreturn the IP address, it'll do the look up.<br><br>3. Maybe there's a class number, there is a grade, there's a phone numbermaybe an address so we refer to an item and it has a record or the informationthat we're going to sort.<br><br>4.com has got this IP addressthat's shown if this line here in the table, and so forth.<br><br>5. So, what we do is try to figure out why, find a way to addresswhatever's causing that problem, find a new algorithm and iterate until we'resatisfied.<br><br>6. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>7. Today, we're gonna take alook at a number of interesting applications of symbol tables and thebinary search tree data structure to address problems with processing geometricdata.<br><br>8. One other client might want touse the IP address' key, have an IP address give methe corresponding client.<br>
rooted|sentence cnt : 3 <br> <br>1. But we're gonna store the, largest endpoint inthe subtree rooted at that node.<br><br>2. So at every node, we're gonna store the maximumendpoint and subtree rooted at that node.<br><br>3. So now, what about operationslike rank and select? How many keys are there less than a given key? And, give usthe seventh largest key to facilitate implementing those operations and alsosize all we do is keep an extra field in each node, which is the number of thenodes in the subtree rooted at that node.<br>
tarjan|sentence cnt : 1 <br> <br>1. And what was provedby Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of Munion and find operations will touch the array at most a c (N + M lg star N) times.<br>
library|sentence cnt : 11 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. Or actually Java implementsthat in its arrays library.<br><br>3. Your music librarymaybe I, at one point, you sort it by the artist's name.<br><br>4. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>5. So,why not just use those? Why use our own implementations? Well, the problem isoften in such library code is kind of designed by committee phenomenon that moreand more operations get added and the API becomes too broad or bloated.<br><br>6. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>7. So here's the Java library implementationsfor a few standard types and they are what they are andwhat we'll do is we acknowledge that that'swhat the hash code is.<br><br>8. So our insistence in this course is thatstudents should not use the library until we've implemented it in class.<br>
similarly|sentence cnt : 4 <br> <br>1. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>2. And similarly, maybe we want to build a, abook index, maybe for a real book, or maybe foran ebook.<br><br>3.As long as it's pointing to a bigger element that's similarly just a wide loopwe put in to test to make sure we don't run off the left end of the array.<br><br>4. And then similarly, dot product of this with that column is 0.<br>
diversing|sentence cnt : 1 <br> <br>1. So wepick that number, I and then we just go to that list and this is the standard codefor diversing a link list start at the first node as long as it is not null go x= x dot x.<br>
knows|sentence cnt : 6 <br> <br>1. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>2. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>3. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br><br>4. And if you find that b is lessthan c and a is less than b, then you know that they're in the, any algorithm thatdoes that knows that the items are in the order a, b, c.<br><br>5.Here's an increment sequence that I found after maybe a year's work and it workswell but nobody knows if that's the best one.<br><br>6. The problem is nobody knows an accurate model for describingthe number of compares taken by Shellsort for any interesting increment sequence.<br>
rather|sentence cnt : 11 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>3. Anoth er thing they did was rather thanshuffling the array.<br><br>4. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br><br>5. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>6. We can make the heap d way rather than just two way.<br><br>7. Now in practice, this construction is, is rather high.<br><br>8. So,for example this is a rather complicated formula but not too bad but in a sensethat if you know that the i-th key, it occurs xi times you can write down a lowerbound for the number of comparisons that are going to be required in the worstcase.<br>
postscript|sentence cnt : 1 <br> <br>1. One, having to deal with compiling from aprogramming language or interpreting into an actual computation and then the otherone is the PostScript language which is widely used for, for printing andpublishing.<br>
mathematical|sentence cnt : 28 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>3. We do some mathematical proofs in, in thiscourse when they're critical such as this one.<br><br>4. And we point that outbecause that helps with the mathematical analysis.<br><br>5. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>6. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>7. And all that is, it's a mathematicalreflection of what's going on in the code.<br><br>8. Some of them very mathematical, that extend thehigher dimensions.<br>
recursively|sentence cnt : 13 <br> <br>1. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>2.Once we have it arranged in that way, then we recursively sort the two parts.<br><br>3. Tells us where, which element is inposition, and then recursively sorts the last part that's loaded, J -one.<br><br>4. And follow the link corresponding to theinterval that we know must contain the search key by definition of the tree andthen we recursively continue the search.<br><br>5. And the idea is to build a tree that corresponds torecursively partitioning the plane.<br><br>6. And to believe this method, you just have to think recursivelyand prove by induction that this in order method puts all the keys in the datastructure on the queue in their natural order.<br><br>7. So, whether or not there was a new node added we don't haveto test for that this recursively takes care of the problem of maintaining thesize in every node when there's a new node inserted.<br><br>8. If it's a reference type,use that hashCode and apply recursively.<br>
directory|sentence cnt : 3 <br> <br>1. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>2. This isthe example of the client program that sorts the files in a given directory byfile name.<br><br>3. In this one, we're going to sort file, file's namein a given directory.<br>
recently|sentence cnt : 11 <br> <br>1. That's the most recently added item.<br><br>2. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>3. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>4. Then it'll put be on the top ofthe stack and then pop the top item on the stack which is now be, andthen pop the item most recently added.<br><br>5. For queue,we examine the item least recently added.<br><br>6. We looked to the push downstack where we removed the item that was most recently added, And the queue where weremove the item that was least recently added.<br><br>7. For the stack, we take out the itemthat was most recently added.<br><br>8. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br>
preprocessed|sentence cnt : 1 <br> <br>1. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
examples|sentence cnt : 16 <br> <br>1. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>2. And we'll see some examples of this in this course.<br><br>3. All of these operations are very useful forclients and we'll see plenty of examples later on.<br><br>4. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>5. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>6. It moves keys pastother keys that could be equal and so its easy to construct examples showing thatSelection Sort is not stable.<br><br>7. So those are just two examples.<br><br>8. And those are just examples ofclassic results from combinatorial analysis that help us understandwhat happens when we do this, which is what we're doing with hashing.<br>
solution|sentence cnt : 27 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>3. And then, theresolution.<br><br>4. And so we have twophases, we have prediction and resolution.<br><br>5. Idon't want to spend a lot of time with this cuz I think this is a unsatisfactorysolution.<br><br>6.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>7. Well in his original paper in 1961 Hoare gave a solution to the selectionproblem based on partitioning.<br><br>8. That's our first collision resolution method, hashing with separatechaining.<br>
visited|sentence cnt : 1 <br> <br>1. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br>
present|sentence cnt : 54 <br> <br>1. The thing is remember represented in array one two three and so forth.<br><br>2. The array representation, all we do is we put, we start with indices at 1.<br><br>3. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>4. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>5. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>6. So, from this datastructure we can associate with each item a root, which is representative, say, ofit's connected component.<br><br>7. But we don't have the client to know whetherwe're using an array or link list or whatever internal representation we mighthave in mind.<br><br>8. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br>
picking|sentence cnt : 4 <br> <br>1. And then we pass through picking out from low to low+size-1,and then the next part is low+size+size-1 until we run to the end of the arraywhere we might not have a full subarray of size sz.<br><br>2. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br><br>3. So we start again by picking K as thepartitioning element.<br><br>4. The mistake we might make is to put ID of P here rather than first pickingout, that value.<br>
difficulty|sentence cnt : 3 <br> <br>1.with mergesort is a good opportunity totake a look at the intrinsic difficulty in the sorting problem, now that is calledcomplexiting and we'll look at that next.<br><br>2. Nowin framing of the difficulty of problems were only two things.<br><br>3. With arrays, it doesn't quite work andagain all programming languages and, you know, many programming languages nowadayshave difficulties with this and Java's got a particular difficulty.<br>
budget|sentence cnt : 1 <br> <br>1.>> So red turning to black means what? >> Budget deficits, red ink, black ink.<br>
code|sentence cnt : 250 <br> <br>1.Delete code is a bit more complicated but it's on the book side and in the book.<br><br>2. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>3. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>4. It's just complicated code to understand.<br><br>5. But more important, there's code, there's exercises, tere's agreat deal of information there.<br><br>6. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>7. So,without any extra special code we insert a node into an empty tree.<br><br>8. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br>
integer|sentence cnt : 42 <br> <br>1. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>2. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>3. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>4.So let's start with the constructor, well we have a, a private integer array.<br><br>5. And now the integer that we'regoing to associate with each word is the frequency of occurrence ofthat word in the symbol table.<br><br>6. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br><br>7. Now with i equals two, i pointing to the second card, we generate a random integer between zero and i.<br><br>8. So, what we are going to do with thisclient is specify with integers which field is the key, and which is the value.<br>
consider|sentence cnt : 39 <br> <br>1. Sosweeping from left to right means we consider each x coordinate as an event.<br><br>2. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>3. Alright, so let's just look at each of thealgorithms that we've considered so far.<br><br>4. But most algorithms that we consider, were discovered inrecent decades.<br><br>5. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>6. Any uses of the resizing array,so many of the principles that we consider does also a, a link list interface.<br><br>7. So, again, considering it forthis simple case will pay off later on.<br><br>8. Consider it as aevery time it hits some line segment as an event where we have to do something.<br>
optimization|sentence cnt : 1 <br> <br>1. And that's a good optimization forlots of situations, why go through all that rest of that codeif you know right away they are equal.<br>
quarter|sentence cnt : 3 <br> <br>1. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>2. We can just test if the arrayis one quarter full, if it is, we resize it to half full.<br><br>3. The efficient solution is to wait until the array getsone-quarter full before you have it.<br>
avoid|sentence cnt : 15 <br> <br>1. This is so called lazy approach to algorithmdesign where we try to avoid doing work until we have to.<br><br>2. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>3. So, we want to avoid cast as much as possible because it,it, it really is declaring some kind of weakness in what we're doing.<br><br>4. So, we, we avoid this firstsituation here where we put the larger tree lower.<br><br>5. The idea is to when implementing the quick union algorithmtake steps to avoid having tall trees.<br><br>6. Actually since we copied, we couldoptimize by avoiding these moves.<br><br>7. You need a quadratic amount ofmemory to avoid collisions.<br><br>8. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
construction|sentence cnt : 6 <br> <br>1. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>2. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br><br>3. And the idea isthat during the construction of a tree, or during an insertion operation, sometimeswe wind up with red links that are leaning in the wrong direction.<br><br>4. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br><br>5. Now in practice, this construction is, is rather high.<br><br>6. This, slide summarizes the code for, heap construction.<br>
attach|sentence cnt : 5 <br> <br>1. If it goes on the right, then we attach a new node with thered link on the right but we have to rotate it to the left to make a legalthree node.<br><br>2. If that's true, then we attach the new node with thered link as always.<br><br>3. Now, we attach a new link at the left of the smallernode.<br><br>4. [cough] or in, in youknow, in the case when we're just inserting a new node and it's turns out tobe the right red link attached to a black one, if that handles that case.<br><br>5. So, that's adding a new node with a red linkat the bottom inserting that into whatever the two or three node it's attached to.<br>
converted|sentence cnt : 1 <br> <br>1.That 3-node gets converted into a 4-node.<br>
rapid|sentence cnt : 1 <br> <br>1. So Integer with the capitalized rapid typefor int and so forth and many of you were probably familiar with that.<br>
compilers|sentence cnt : 1 <br> <br>1. So, so the way the compilers implement functions is using stacks.<br>
drawings|sentence cnt : 3 <br> <br>1. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>2. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>3. And, there werevarious rules about what you can do on these drawings.<br>
classes|sentence cnt : 4 <br> <br>1. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>2. In particular,all Java classes inherit a method called hash code which is returnsa 32-bit int value.<br><br>3. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>4. I won't go through it all in detail just to point out that thisimplements two different comparators as nested classes.<br>
roman|sentence cnt : 1 <br> <br>1.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br>
enclosing|sentence cnt : 1 <br> <br>1. It's the smallest convex set that contain all the points,the smallest area of convex polygon enclosing the points.<br>
adjacent|sentence cnt : 1 <br> <br>1. So how do we model opening a new site? Well to open asite we just connect it to all it's adjacent open sites.<br>
iteration|sentence cnt : 16 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>3. If we're not done we're supposed to return true and the next() is supposed togive the next item in the iteration.<br><br>4. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br><br>5. And the quicksummary is that every one of those operations, while ordered iteration isoptimal, it just gets them in linear time.<br><br>6. But Java does provide a nicea solution to this called iteration.<br><br>7. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>8. For insertion sort, what we'regoing to do is we'll move an index i from left to right as before,but now, in the i'th iteration, we're going to move a[i] into positionamong the elements to its left.<br>
instructions|sentence cnt : 2 <br> <br>1. There's only a few instructions foreach one of the operations.<br><br>2. We have instructions on the web on how to do that.<br>
inject|sentence cnt : 1 <br> <br>1. There's another family of methodswhere there's no ordering, and there's a special methodcalled hashCode that helps us inject randomness into the process.<br>
packets|sentence cnt : 1 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br>
explicitly|sentence cnt : 3 <br> <br>1. But it's worthwhile to state them explicitly andmake sure that our algorithms maintain them.<br><br>2. Butthis time, we h ave some guarantee that no item is too far from the root and we'lltalk about that explicitly in a second.<br><br>3. It's just going to be able toanswer the question, is there a path? In part two of the course, we'll consideralgorithms that explicitly find paths.<br>
tokens|sentence cnt : 1 <br> <br>1. Then there there's a while loopwhere we just read a new line in that read line, read line and then split accordingto comma into tokens in an array.<br>
compute|sentence cnt : 86 <br> <br>1. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>2. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>3. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>4. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>5. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>6. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>7. We'll start with the 1, 4, 13, 40, 121, 364 like thatand that's good because it's easy to compute.<br><br>8. Maybe the way yourcomputer's memory is organized make a difference.<br>
secrets|sentence cnt : 1 <br> <br>1. They might unlockthe secrets of life in the universe, and they're good for fun and profit.<br>
edition|sentence cnt : 2 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. And it's only in this edition that we figuredout how to make the code this simple.<br>
peter|sentence cnt : 1 <br> <br>1. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br>
song|sentence cnt : 2 <br> <br>1. But in another situation, you might want to sort it by song names tolook through it by song names.<br><br>2. Nowadays you more likelyto do that online or when you're trying to find the song todownload, you provide the name of the song and then the value will tell youwhat computer got her to get that.<br>
deletemin|sentence cnt : 5 <br> <br>1. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>2. That's a fine implementation for deleteMin and it also works for deleteMax.<br><br>3. The next most difficult case is like the deleteMin case.<br><br>4. So this code implements deleteMin, not too bad at all.<br><br>5.left equals deleteMin x.<br>
scenario|sentence cnt : 3 <br> <br>1. Now, there's another scenario where a key becomes smaller.<br><br>2. So one scenario shown here is, if for whatever reason a child's key becomes larger than its parents key.<br><br>3. And now, what we are going to do is take a look at just a couple of different scenarios that we violate that invariant temporarily, and then fix it.<br>
vertical|sentence cnt : 22 <br> <br>1. At the even levels, we think ofa vertical line, and the left sub-tree is all the points to the left and the rightsub-tree is all the points to the right.<br><br>2. So now 5 comes in, that's to the left of 4because it was partitioned at a vertical and 5's going to partitionin a horizontal.<br><br>3. And then the third kind ofevent is what happens when we hit a vertical line segment? Well, in that caseall we want, need to do is just do a range search, for the interval of y end points.<br><br>4. They're alloriented horizontal or vertical.<br><br>5. Again, now when we go to one level below,we switch again to vertical.<br><br>6.So say your geometric objects are points in the plane and you specify a rectanglethat's oriented with the horizontal/vertical axes.<br><br>7. So, it's called the orthogonal line segment, segment intersection searchwhere the lines segments or constrained to be either horizontal or vertical.<br><br>8.So, if you know that you have a particle that's at a certain position or x or y andhas got a certain velocity, the x in the x-direction and y in the y-direction, thenyou can from the distance to the pro, vertical wall you can figure out how manyseconds this is going to take until it hits it.<br>
behave|sentence cnt : 1 <br> <br>1. >> And then, when the moment is right, they behave in a way thatshould be impossible.<br>
expanding|sentence cnt : 1 <br> <br>1. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br>
giving|sentence cnt : 2 <br> <br>1. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>2. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br>
networking|sentence cnt : 1 <br> <br>1. In fact,almost any computer application system is going to have a symbol table ormultiple symbol tables at its core all the way down to the basicmemory system of the computer or the networking system that your computeraccess to information depends on.<br>
part|sentence cnt : 231 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>4. So the goal is socalled three way partitioning.<br><br>5. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>6. The first part is data typesorting and searching.<br><br>7. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>8. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br>
amortized|sentence cnt : 4 <br> <br>1. We have a good amortized time, so totalaveraged over the whole process is good.<br><br>2. And this is a fine example anduseful example, of amortized analysis to getefficiency in a stack implementation.<br><br>3. And number two, that every time youresize, you've already paid for it in an amortized sense by inserting,pushing or popping.<br><br>4. So that's called amortized analysis, where we consider the total costaveraged over all operations.<br>
compile|sentence cnt : 10 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>3.And okay, that's fine and you're going to see that when you do compiles using codelike these.<br><br>4. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>5. It doesn't have this highly desirableattribute but everything would compile.<br><br>6. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>7. So, so the way the compilers implement functions is using stacks.<br><br>8. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
reverse|sentence cnt : 4 <br> <br>1. So this is when the itemscome in in reverse order.<br><br>2. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>3. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>4. Now but there is this problem that theactual worst case height if the keys come in, in order and reverse order and othernatural orders that the time could be proportional to n.<br>
count|sentence cnt : 62 <br> <br>1. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>2. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>3. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>4. Now, we want to talk about deletion andthen range search and range count.<br><br>5. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>6. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>7. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br><br>8. So,that's a, a really 1d range count is a very easy computation to perform in, inlog time with a binary search tree.<br>
meets|sentence cnt : 1 <br> <br>1. So that kind of meets thesetwo requirements for Java.<br>
compareto|sentence cnt : 17 <br> <br>1.compareTo(w) less than zero.<br><br>2. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>3. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>4. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>5. And thenthe sort code can just use that compareTo() method, invoked in a sense of theobject like an entry in the array and as argument and another instance in theobject like another entry in the array to test whether the first is less than thesecond as in this example.<br><br>6. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>7. So, that's an example of animplementation of Comparable by implementing the compareTo() method to putdates in order as you might expect.<br><br>8. And all that means is that,that data type has an instance method that will implement the compareTo() method.<br>
growing|sentence cnt : 4 <br> <br>1. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>2. And another pointabout this is it< /i> seems that this is</i> so close to being linear that is t imeproportional to N instead of time proportional to N times the slowly growingfunction in N.<br><br>3. This is a simulation that shows a, agrowing B-tree so when a page, at the top, there's just one page that fills up.<br><br>4. Now as alpha gets close toone, you can see these things are going to grow, and particularly the search miss isgrowing to grow quite, quite a bit.<br>
classical|sentence cnt : 7 <br> <br>1. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>2. We'll look at two classicalgorithms.<br><br>3. And these things are studied inclassical combinatorial analysis.<br><br>4.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br><br>5. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br><br>6. And then wow, what are we getting the sortefficient, done efficiently? Well, we could use Shellsort but actually in thenext couple of lectures and we'll look at classical sorts - Mergesort and Quicksort -that we could use.<br><br>7. It's going to beat even theclassical sophisticated methods for medium sized arrays.<br>
assumes|sentence cnt : 1 <br> <br>1. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br>
ancient|sentence cnt : 2 <br> <br>1. Algorithms arealso interesting to study, because they, they have ancient roots.<br><br>2. In ancient times, memory was, at quite apremium and so people were very concerned in m-m-making sure that the hash tablenever, got too empty.<br>
lookup|sentence cnt : 5 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. So, in this case, we aregoing to write a client called Lookup CSV that [cough] is going to take threearguments.<br><br>3. And that's an association that'swell known to biologist and then you can use this lookup CSV client to quickly getthe name associated with any given codon.<br><br>4. So, with one client we can handle lookups of all kinds in CSV files.<br><br>5. So for example,a domain name server might have a lookup where you've got a tablethat's got an IP address and URL associated with that IP address.<br>
generation|sentence cnt : 1 <br> <br>1. A famous quote and there's many similar quotes, 'The generation of random numbers is too important to be left to chance'.<br>
unreasonable|sentence cnt : 2 <br> <br>1. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>2. Unreasonable to expectthe implementation to work well if the client can change the valuesof keys that are in the table.<br>
supposedly|sentence cnt : 1 <br> <br>1. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br>
collide|sentence cnt : 11 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>3. In such a waythat, it's hard for someone else to find another key that collides with that.<br><br>4. So that's a key method t hat gets used in thesimulation for each of the two particles that are going to collide.<br><br>5. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br><br>6. So there's simple formulas to tell us what todo and we can also figure out the formulas for what we do o nce they do collide.<br><br>7. So, this is just extending our ball data type that we use for thebouncing balls that didn't collide to take in, into account these extra things.<br><br>8. And if there is, then we couldroll back time just a little bit and I'll try to figure out exactly, the moment ofwhich they collided and then figure out how the position and velocity shouldchange accordingly and then continue the simulation.<br>
fascinating|sentence cnt : 2 <br> <br>1. A fundamental andextremely important data type that have led to all kinds offascinating implementations and we're going to look at severalof them in this course.<br><br>2. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br>
site|sentence cnt : 31 <br> <br>1.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>2. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>3. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>4. If they're connected by open sites.<br><br>5. There is abook site and text book as well.<br><br>6. There's not enough open site for there to be a connection from the topto the bottom.<br><br>7. People often ask aboutprerequisites.<br><br>8. So, we have an assignment whereyou need to generate a random open sites in a percolation system.<br>
rely|sentence cnt : 2 <br> <br>1. In the standard built-in types ofthe Java language we're going to have those customized implementations andwe can rely on them doing what we expect.<br><br>2. And again the default implementation is tocheck whether we refer to the same object and that's rarely what we want,Java system's programs may be want that.<br>
studied|sentence cnt : 7 <br> <br>1. In this one of many different algorithmsthat have been studied for this.<br><br>2. And these things are studied inclassical combinatorial analysis.<br><br>3. Now this was studied in detail by Knauf, DonKnauf, in the 1960's and actually this problem, Knauf says, was the origin of theorigin of analysis of algorithms.<br><br>4. [COUGH] here's a trace of what Mergesortdoes and if you haven't studied a recursive program before it's worthwhilestudying this thing in, in some detail.<br><br>5. Now the firstalgorithm we studied goes back to 300 B.<br><br>6. The other thing is that the lower bound isfor the particular model of computation being studied.<br><br>7. And as I mentioned, there's been many, many improved versions ofhashing that have been studied.<br>
accredited|sentence cnt : 1 <br> <br>1. He's widely accredited as being theinventor of Mergesort.<br>
violate|sentence cnt : 13 <br> <br>1. That's restoring the heap border along a path from the place where it's violated to the root.<br><br>2. But in general, we have to check whether the heap condition is violated and exchange it with its parent as long as it's smaller.<br><br>3. So,now the invariant might be violated so we have to fix it.<br><br>4. Now, that element which went from the bottom to the top is most likely going to violate the heap order, it's going to be smaller than one or its both of its children, so we do a sink.<br><br>5. It might be violatedbecause you might have an element to the right of the pointer that is smaller than some, the element on the pointer.<br><br>6. So now, we have to bring the heap order back because it might be violated at the root.<br><br>7. But the heap conditional will be violated because T is still smaller than S.<br><br>8. Swims up to the top, and if we have a node at index k and we know the heap condition is violated there.<br>
actually|sentence cnt : 122 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>3. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>4. Or actually Java implementsthat in its arrays library.<br><br>5. And it's actually a prototype foralgorithm design that we'll see come up again and again.<br><br>6. Actually less code thanfor Quick Find, no fore loops.<br><br>7. What about deleting the minimum? Well actually, that's maybe not too difficult.<br><br>8. It uses actually both quicksort and mergesort.<br>
ignore|sentence cnt : 8 <br> <br>1. If they are connected it'll ignore.<br><br>2. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>3. They have to be in the same class and well there's a couple of differentways to check about the same class and that's another religiousdebate that we'll ignore.<br><br>4.Left parenthesis, we ignore.<br><br>5. We'll read a new word, andwe'll ignore the short strings, just trap out if the wordlength is too small.<br><br>6. And this first argument is just ignorewords fewer than this many letters.<br><br>7.Left parenthesis you ignore.<br><br>8. So, and those are the a top is summarize the four type of thingsthat we could wind up with and what to do so the left parenthesis we've ignored, avalue we put on to the value stack.<br>
layers|sentence cnt : 1 <br> <br>1. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br>
visualize|sentence cnt : 1 <br> <br>1. Now, but let's look at what's happened or visualize whathappens when keys come in, in random order.<br>
many|sentence cnt : 109 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>3.And in fact, in many real applications, they're not very random.<br><br>4. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>5. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>6. And, and in many applications evensetting M = 100 or 1,000 is going to be very effective.<br><br>7." And many programmers live by that kind of preset.<br><br>8. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br>
colored|sentence cnt : 1 <br> <br>1. So, given a BST with someof the links colored red that has those properties that's going to correspond to a2-3 tree.<br>
tries|sentence cnt : 36 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2. All have entries eight.<br><br>3. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>4. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>5.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>6. And so, symbol tables provide us with a way to provide a moreefficient implementation of, of this process when we have lots of zero entries.<br><br>7. And fiveand zero have different entries.<br><br>8. So if we're going to union six and one,then we have to change entries zero, five, and six.<br>
gave|sentence cnt : 5 <br> <br>1. So, in, in fact, often, the purpose of a sort isto bring items with equal keys together for like the example that I gave where wehad cities and time.<br><br>2. It's a little bit of anextension of the ordered symbol table API that we gave before and we're going tohave operations range-search and range-count.<br><br>3. Well in his original paper in 1961 Hoare gave a solution to the selectionproblem based on partitioning.<br><br>4. And then push is the four lines of codethat I gave on the previous line and pop is the three lines of code thatI gave on the slide before that.<br><br>5. So here's just an overview of twoelementary implementations for priority queues using the example operations that Igave before.<br>
cared|sentence cnt : 1 <br> <br>1. Thing to be researchers in the 1950's who cared so much about memoryand nowadays a little extra memory is not something that people care about so muchand most people just go with the easy algorithm except for really performancecritical applications.<br>
file|sentence cnt : 83 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. In this case, we'll have the word, the file list.<br><br>3. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>4. That's building a symbol table associatingkeys with sets of files.<br><br>5. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>6. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>7. So, this value loop just builds thesymbol table from the file.<br><br>8. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br>
illustrate|sentence cnt : 7 <br> <br>1. The idea though is that this example illustrates that good sortingalgorithm gives us a good convex hull algorithm.<br><br>2. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>3. But we mentioned this example to illustrate how even asimple algorithmah, can have interesting and complex analysis.<br><br>4. So this well illustrates that youneed to use all of the data in the hash function and sometime we do a closeranalysis.<br><br>5. So forexample in this example with our ten objects the idea array that describes thesituation after seven connections is illustrated in the middle of the slide.<br><br>6. Now a specific example that really shows this off and also will illustratethe utility of being able to process multiple types of data with the same codeis this example is Dijkstra's two-stack algorithm for arithmetic expressionevaluation.<br><br>7. And so this, this traceillustrates how we always make some progress and eventually we get the filesorted.<br>
xerox|sentence cnt : 2 <br> <br>1. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>2. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br>
norman|sentence cnt : 1 <br> <br>1. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br>
disable|sentence cnt : 2 <br> <br>1. So by default, insertions are disabled.<br><br>2. Now the thing about assertions in Java is that you can enable or disable them atruntime.<br>
combinations|sentence cnt : 3 <br> <br>1. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>2. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>3. But the thing is, there is way morepossible combinations of attributes than there are algorithms.<br>
invokes|sentence cnt : 1 <br> <br>1. Then, the less method will take that comparator asan argument and this is the one that actually invokes the method compare twodifferent keys.<br>
guiding|sentence cnt : 1 <br> <br>1. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
writing|sentence cnt : 1 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
prioritized|sentence cnt : 1 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br>
helper|sentence cnt : 1 <br> <br>1. And then we have helper functions less and exchange that access the array directly so that the code doesn't have to access it directly.<br>
difference|sentence cnt : 18 <br> <br>1. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>2. Maybe the way yourcomputer's memory is organized make a difference.<br><br>3. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>4. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br><br>5. So, the API will look very similar to our stack or queue API with adifference that we want to have generic items that are comparable.<br><br>6. We can associate the keywith null internally then apply or know the differencewhether that's in there or not.<br><br>7. Maybe your computer is parallel and the sort has to be paralleland we found that equal keys make a huge difference.<br><br>8.If it's partially sorted it doesn't make much difference - does the higher sorts alittle bit faster.<br>
modify|sentence cnt : 1 <br> <br>1. For the union implementation, we're going tomodify the code to check the sizes.<br>
retrieve|sentence cnt : 1 <br> <br>1. But it's a good way to think about it and then to retrieve it you just give thatsame key and it'll return the value.<br>
actual|sentence cnt : 128 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>3. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>4. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>5. Or actually Java implementsthat in its arrays library.<br><br>6. And it's actually a prototype foralgorithm design that we'll see come up again and again.<br><br>7. Actually less code thanfor Quick Find, no fore loops.<br><br>8. What about deleting the minimum? Well actually, that's maybe not too difficult.<br>
discover|sentence cnt : 18 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2. In fact, some were discovered by undergraduates in a course,course like this.<br><br>3. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>4. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>5. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>6. But most algorithms that we consider, were discovered inrecent decades.<br><br>7. Try some technique to discover one and try to saysomething about the average-case performance of Shellsort.<br><br>8. So, the lesson isthat we can develop good algorithms or good implementations without much code butthere are some out there that are still waiting discovery.<br>
arguments|sentence cnt : 10 <br> <br>1. So, we're goingto use a method less() that takes two Comparable objects as arguments and itjust returns, v.<br><br>2. So, in this case, we aregoing to write a client called Lookup CSV that [cough] is going to take threearguments.<br><br>3.And then it calls the recursive method that takes as arguments the limits of thesubarray that's gonna be sorted.<br><br>4. So it simply takes its two arguments, P and Q, and checks whethertheir ID entries are equal, and returns that value.<br><br>5. And then there is a constructorand maybe we have a constructor that takes arguments that would initialize theposition and the velocity or maybe initialize them to a random position ifthere's no arguments.<br><br>6. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br><br>7. The first will be a file name, a so-called common separated value fileand the next two arguments are integers which will tell us what to treat as keysand values in the file.<br><br>8. But now, when we have eight to merge with fourand three, we put the eight as the child, no matter which order their argumentscame, because it's the smaller tree.<br>
bytes|sentence cnt : 5 <br> <br>1. If we have a stack of size N,we have about 40 N bytes.<br><br>2. And then there's 2 referencesthat we built in our class node, 1 to a string and another 1 to a node andthose are each 8 bytes.<br><br>3. So we have 40 bytes per stack note.<br><br>4. There's some extra overhead, 8 bytes,because it's an inner class.<br><br>5. So, in Java, in inner class there is, for every object there's 16 bytes of overhead.<br>
band|sentence cnt : 1 <br> <br>1. Well, there'sactually a way to compute the convex hull just mechanically if you put the nailsaround the points and put a rubber band around it, that gives you the convex hull.<br>
only|sentence cnt : 117 <br> <br>1. And the reason is that you only createa new array every time it doubles.<br><br>2. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>3. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br><br>4. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>5. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>6. There's only a few instructions foreach one of the operations.<br><br>7. So like deleting R in this tree, it only has one child.<br><br>8.Mergesort is not only efficient, it's also.<br>
wrong|sentence cnt : 19 <br> <br>1. The partitioning elements in between themand they're in the wrong order.<br><br>2. And I mentioned that a lot of us would get uswrong.<br><br>3. So, H is a three node leaning the wrong way.<br><br>4. It's turning the wrong way and it's turning to the right.<br><br>5. But if we have a situation wherethere are a lot of equal keys, that model is wrong.<br><br>6. And now, if we insert C into this one, it goesless than E, greater than A it's a red link connecting A and C but it's leaningthe wrong way.<br><br>7. And the idea isthat during the construction of a tree, or during an insertion operation, sometimeswe wind up with red links that are leaning in the wrong direction.<br><br>8. Again, t and I are in the wrong places.<br>
awhile|sentence cnt : 1 <br> <br>1. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br>
utmost|sentence cnt : 1 <br> <br>1. So, this three has to have at least N factorial leaves and ifthe three of height h, it has utmost two^h leaves.<br>
visualization|sentence cnt : 2 <br> <br>1. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>2. So, let's look at avisualization.<br>
copied|sentence cnt : 2 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. Actually since we copied, we couldoptimize by avoiding these moves.<br>
struc|sentence cnt : 150 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>3. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>4. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>5. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>6. There's only a few instructions foreach one of the operations.<br><br>7. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>8. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br>
friedman|sentence cnt : 1 <br> <br>1. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br>
keeping|sentence cnt : 6 <br> <br>1. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br><br>2. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>3.So, even with this huge stream of items coming through, we're only keeping trackof the M largest items and that's a fine canonical client for priority queue.<br><br>4. Wemight consider keeping the things in an unordered array.<br><br>5. So you can imagine keeping the item, say, in a linked list or ina doubling array and just keeping just an order just as we would in the, in thestack just keeping in the way that they come in.<br><br>6. So, we're movingthe smaller ones than the partitioning element to the left of lt and keeping ltpointing on a partitioning element.<br>
reflection|sentence cnt : 1 <br> <br>1. And all that is, it's a mathematicalreflection of what's going on in the code.<br>
algorithm|sentence cnt : 285 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. This is the Quick-findalgorithm.<br><br>3.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>4. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>5. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>6. And, I might add, the algorithms that process them.<br><br>7. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>8. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br>
introducing|sentence cnt : 1 <br> <br>1.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br>
possibility|sentence cnt : 4 <br> <br>1. And if M is prime,it gives us some comfort that we have some possibility of each table positionappearing with equal likelihood.<br><br>2.That is, we allow for the possibility of something called a 3-node that can holdtwo keys, But then it has to have three children.<br><br>3. The only possibility is c, a, b.<br><br>4. And we'll only worry about the possibilityof finding something closer than that.<br>
software|sentence cnt : 2 <br> <br>1. So, this isn't just an example about software security, there's a lot of difficult and deep issues to worry about in software security, and we're not going to worry about all of them.<br><br>2. Now,years after, we have to deploy our software and be extremely difficult oneveryone.<br>
handle|sentence cnt : 16 <br> <br>1. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>2.And again, when there's a lot of equal keys then there's going to be place whereone of those is chosen, it's partitioning element then a big chunk of the array getshandled just in a partitioning process.<br><br>3. So, we'll build a new array of keys and we have to use an ugly cast because of generic arrays in Java, and that's where it's comparable and we need one more than the capacity to handle this thing where we don't use position zero.<br><br>4.You might think it would be better to handle equal keys in some special way.<br><br>5. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>6. [cough] or in, in youknow, in the case when we're just inserting a new node and it's turns out tobe the right red link attached to a black one, if that handles that case.<br><br>7. It expands like binary search to handle all these convenient clientoperations in a very natural manner.<br><br>8. We have to take track, keep track thelinks as we go up and down the tree to take, handle the splitting,And there's, and there's a lot of cases.<br>
editions|sentence cnt : 1 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br>
validate|sentence cnt : 6 <br> <br>1. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>2. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>3. But it might be the case thatthere's a third particle that knocks one of those out before that thing happens andthat event would be invalidated.<br><br>4.And also, it allows us to develop a math model that we can go ahead and validatewith experimentation.<br><br>5. Then, we test whether that event has been invalidated.<br><br>6. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
stores|sentence cnt : 1 <br> <br>1. Once it computes the hash code,it stores it as an instance variable.<br>
what|sentence cnt : 419 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>4. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>5. Rankoperation, that is essentially what binary search provides.<br><br>6. Make sure that both first andlast are always what we want them to be.<br><br>7. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>8. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br>
filling|sentence cnt : 1 <br> <br>1. It's in it's final position and you can see down at thebottom, the large elements in the array filling in, in their final position, inthe, the left part of the array is representing the heap.<br>
maintains|sentence cnt : 5 <br> <br>1. The whole partitioning process forthree-way partitioning and the modern programming language like Java simplymaintains the invariances described in the demo.<br><br>2. Now, the property of this operation that's very important is itmaintains a symmetric order.<br><br>3. And to prove that, we just need to showthat each transformation maintains symmetric order and perfect balance, andthese are all the possible transformations that we could do.<br><br>4. And the algorithm maintains those invariants by finding thesmallest entry to the right and exchange it with the next one.<br><br>5. It doesn'tchange any links so it still, of course, maintains symmetric order and perfectblack balance.<br>
associates|sentence cnt : 7 <br> <br>1. And now build asimple table that associates strings with strings.<br><br>2. What we do is we sayif, if the argument is null, return a reference to a new node that associateskey with value and then that one has null links.<br><br>3. And then we're going to create a newsymbol table that associates strings with sets of integers.<br><br>4. So that's read this loop,reads in all the data and associates each word withits frequency of occurrence.<br><br>5. Again, it's similar to the other one, we're creating a symbol table thatassociates strings with integers.<br><br>6. That associates string keys with sets offiles.<br><br>7. Just a new symbol table that associates integer indices with doublevalues.<br>
commentorial|sentence cnt : 1 <br> <br>1.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br>
comma|sentence cnt : 19 <br> <br>1. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>2. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>3. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>4. So we could have,billions of objects, and hope to do billions of union commands on them.<br><br>5. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>6. And our simple client is totake some strings on standard input and some pop commands whichare indicated with hyphens.<br><br>7. Okay, so toimplement the operations, we have to find query and the union command.<br><br>8. So, that's our problem, to be ableto officially support these two commands for given set of objects.<br>
related|sentence cnt : 4 <br> <br>1. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>2.Now we'll look at the problem that'srelated to sorting called selection that's also well solved by Quicksortpartitioning.<br><br>3.Next, we're going to look at an easy application of sorting to a related problem called shuffling.<br><br>4.Here's another simple client program forsymbol tables related to indexing.<br>
example|sentence cnt : 161 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. Now, here's an example where we want to use theory as a guide.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>5. So, for example, this is a external, this is M = six.<br><br>6. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>7. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>8. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br>
concise|sentence cnt : 3 <br> <br>1. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br><br>2. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br><br>3. To start, we'll talk about 2-3 searchtrees, which is a model that underlies the concise and efficient implementation thatwe're going to look at.<br>
guaranteed|sentence cnt : 24 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>3.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>4. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>5. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>6. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>7. And so that's the st ory of red-black BST's guaranteedlogarithmic performance for all symbol table operations.<br><br>8. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br>
considering|sentence cnt : 2 <br> <br>1. So, again, considering it forthis simple case will pay off later on.<br><br>2. And that uses apush down stack for the hull, it puts the points on the hull in it goes ahead andfor every point considering I'm in the order of the polar sort it'll comparewhether the top two points on the hull and the new point implement a CCW turn or not.<br>
pick|sentence cnt : 19 <br> <br>1. So wepick that number, I and then we just go to that list and this is the standard codefor diversing a link list start at the first node as long as it is not null go x= x dot x.<br><br>2. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>3. So we pick some othersmall prime number and for each field we multiply by 31.<br><br>4. And so we can pick some numbers that we can store.<br><br>5. Any CSV file, you can pick any field as the key, any otherfield as the value.<br><br>6. And then we pass through picking out from low to low+size-1,and then the next part is low+size+size-1 until we run to the end of the arraywhere we might not have a full subarray of size sz.<br><br>7. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>8. If it's a boolean, they pick out a coupleof particular values that they return, so hashing boolean type,there's only two different values, so it's hard to think about whatyou really might want there.<br>
codes|sentence cnt : 4 <br> <br>1. It's not somethingthat you will come up with on your own and that's, and that's an undesirable feature,I think for codes so simple as this.<br><br>2. So if it's an integer the hashcodes suppose to be 32-bits, integer supposed to be 32-bits.<br><br>3. But for user defined types,you're on your own and we'll talk a little bit abouthow to implement hash codes.<br><br>4. So, the best practice is to use insertionsjust as we did in that example with merge and to assume that they're not going to be there inproduction codes.<br>
predicted|sentence cnt : 1 <br> <br>1. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br>
wilks|sentence cnt : 1 <br> <br>1. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
assert|sentence cnt : 7 <br> <br>1. And you put at the end of the code whatyou think it's going to do, again in the formof an assertion.<br><br>2. So Java is just an assert statement.<br><br>3. And what assert will do is it will throwan exception unless that condition is true.<br><br>4. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>5.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>6. Now the thing about assertions in Java is that you can enable or disable them atruntime.<br><br>7. If you put at the beginning of the codewhat you expect in the, in the form of an assertion, whichis code itself.<br>
four|sentence cnt : 94 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. And three, four, eight, and nine all have entry eight.<br><br>3. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>4. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>5. Nine and four, So now four is the root of the tree containing four is eight.<br><br>6. What about nine and four? So, now we have to change the, to connect nine andfour, we have to change, 9's entry to be the same as 4's.<br><br>7. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>8. So what power do you have toraise 500 to get bigger than N? In practice that's going to be like four orfive.<br>
dequeue|sentence cnt : 5 <br> <br>1. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>2. Instead of push we have enqueueinstead of pop we have dequeue.<br><br>3. And the semantics is different, forenqueue we add an item say at the end of the queue, and for dequeue weremove an item from the beginning.<br><br>4. And for dequeue you remove an item fora head.<br><br>5. So here's the implementation of dequeue.<br>
tests|sentence cnt : 5 <br> <br>1. So thissimple thing just tests is a node red.<br><br>2. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>3. Then the other thing is thatinstead of doing compare to's, we're going to be doing equality tests.<br><br>4.It'll compare this object against the object given as argument and depending onsome complicated tests, it'll return -1, meaning less, +1, meaning greater or0, meaning equal.<br><br>5. And then these tests are for whether it hits the walls in which case, you haveto flip the x or y velocity.<br>
gray|sentence cnt : 4 <br> <br>1. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>2.So, in gray is our, standard insertion code for binary search trees.<br><br>3. So we've drawn the data structure with the links so we have an intuition for what's going on, but all the program sees is the array in gray at the bottom where T is in position one, P and R in position two and three and so forth.<br><br>4. Entries in gray are not touched, they're in their final position.<br>
staying|sentence cnt : 1 <br> <br>1.Also staying in bounds.<br>
digital|sentence cnt : 3 <br> <br>1. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>2. And later on, we'll look at digital propertiesof keys where we can use digital character compares instead of whole key compares andgot a faster sort for certain practical applications.<br><br>3. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
lesser|sentence cnt : 1 <br> <br>1. If it's not greater or lesser it has to be equal, thanwe return the value right at that node.<br>
programmers|sentence cnt : 8 <br> <br>1." And many programmers live by that kind of preset.<br><br>2. Butinexperienced programmers often have trouble with it.<br><br>3. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>4. And an experienced programmers know thisand it's not difficult to arrange for the natural types of data that peopleare going to use for symbol table keys.<br><br>5.sort and it's intended to be ageneral purpose sorting method for use by Java programmers.<br><br>6. Bad programmers worryabout the code, good programmers worry about data structures, and theirrelationships.<br><br>7. You'll often see programmers thinking that they're implementing a shuffle and for every entry, they just choose a random place in the array to exchange it with, and that doesn't really work.<br><br>8. And actually the Javasystem and other systems include both so that programmers can make use of eitherone in diff erent situations.<br>
iterated|sentence cnt : 1 <br> <br>1. And the way to think, it's called the iterated logfunction.<br>
diffidently|sentence cnt : 1 <br> <br>1. And that's diffidently one thingto consider when using hashing is that the cost of computing the hash function for acomplicated key might exceed the cost of searching and using a simpler structurelike a binary search tree.<br>
nine|sentence cnt : 30 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. And three, four, eight, and nine all have entry eight.<br><br>3. Nine and four, So now four is the root of the tree containing four is eight.<br><br>4. What about nine and four? So, now we have to change the, to connect nine andfour, we have to change, 9's entry to be the same as 4's.<br><br>5. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br><br>6.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>7. Seventeen, nineteen is at the root, so everybody with a le ft end pointless than seventeen is to the left, the left end point greater than seventeen isto the right and so forth.<br><br>8. Thereis a path from eight to three to four to nine.<br>
beyond|sentence cnt : 6 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>3. The proof for this fact is quite beyond thescope of this course but it's still an important fact.<br><br>4. So analysis of 2d trees isa bit beyond our scope.<br><br>5.Now, we'll look at red black BSTs which isa simple data structure that allows us to implement 2-3 tree with very little extracode beyond the basic binary search tree code.<br><br>6. It's very little code beyond the basic heap code that we'velooked at can get this implemented.<br>
brownian|sentence cnt : 1 <br> <br>1. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br>
currently|sentence cnt : 1 <br> <br>1. So, the BST contains the y coordinates of all the horizontal linesthat currently might involve an intersection.<br>
textbooks|sentence cnt : 1 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br>
lightning|sentence cnt : 3 <br> <br>1. It's actually going to be quadratic in the worst case but again, thechance of that it will happen with a random shuffle is less than the chancethat we'll be struck by lightning.<br><br>2. But with random, the random shuffle it'smore likely that this lecture will end, because of a lightning strike.<br><br>3.Or your computer will be struck by a lightning bolt.<br>
referred|sentence cnt : 7 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>3. So hashing's going to be preferred for short keys where the hashfunction's easy to compute.<br><br>4. Now arereferred to this idea of a good system sort, there was a good system sort that alot of people used for many years.<br><br>5. If there is no duplicatekeys Quicksort processes them and referred them out in BSTs and if there's noduplicate keys there's a one-to-one correspondence between what happens withQuicksort and what happens with binary search trees.<br><br>6. I referred to delete the minimum just to avoid confusion, we have theimplementation separate implementation usually MinPQ, where we delete theminimum.<br><br>7. We refer to every node in the tree as the root of a sub-treeand [cough] referred to, the nodes below.<br>
publishing|sentence cnt : 2 <br> <br>1. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>2. One, having to deal with compiling from aprogramming language or interpreting into an actual computation and then the otherone is the PostScript language which is widely used for, for printing andpublishing.<br>
sudden|sentence cnt : 2 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>2. You wouldn't want it to all of a suddennot implement some operation quickly.<br>
considered|sentence cnt : 3 <br> <br>1. Alright, so let's just look at each of thealgorithms that we've considered so far.<br><br>2. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>3.Next we're going to consider addressinganother fundamental defect in the implementations we've considered so farthat those implementations are only good for strings.<br>
names|sentence cnt : 12 <br> <br>1. And then a series of pairs of object names.<br><br>2. But in another situation, you might want to sort it by song names tolook through it by song names.<br><br>3. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>4.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br><br>5. And then simply print out the set ofstrings associated with that word which is a list of filenames.<br><br>6. And certain codons have names, that's theamino acids.<br><br>7. That's an array with file names in it and Insertion.<br><br>8. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
laid|sentence cnt : 1 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br>
pioneer|sentence cnt : 2 <br> <br>1. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>2. Don Knuth who wrote several books on, on algorithmsand was a pioneer in the field said that, "An algorithm must be seen to bebelieved.<br>
deck|sentence cnt : 7 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. So, that's definitely a way to get a deck shuffled quite easily, easy to implement.<br><br>3. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br><br>4. And that just means that it's well shuffled, that every possible way of shuffling the deck appears with equal probability.<br><br>5. But the bottom line is, don't think that it's easy to shuffle a deck of cards.<br><br>6. Here's the code that you can find on the web for how to shuffle a deck of cards, that's pretty similar to our code but it's actually got more than a few bugs.<br><br>7. And at the end, we have the deck shuffled.<br>
preserves|sentence cnt : 1 <br> <br>1. So a stable sort is asort that preserves the relative order of items with equal keys.<br>
mccreight|sentence cnt : 1 <br> <br>1. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br>
labs|sentence cnt : 1 <br> <br>1. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br>
equally|sentence cnt : 6 <br> <br>1. And the other is that itshould be the case that every table index is equally likely foreach key.<br><br>2. And it's not equally likely that each phone number has the samefirst three digits.<br><br>3. The one that it doesn'tmaybe meet is the idea that every table positionshould be equally likely.<br><br>4. We'll do some extra work totry to get this extra property that every table position shouldseem to be equally likely.<br><br>5. Now in theory, it's possible to dosomething that has the property that all positions are equally likely.<br><br>6. So that's our assumption thateach key is equally likely to hash an integer between zero andM minus one.<br>
phenomenon|sentence cnt : 7 <br> <br>1. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>2. There's algorithms in physics for understanding physical phenomenon thatwe'll look at an example and many others on this list.<br><br>3. So,why not just use those? Why use our own implementations? Well, the problem isoften in such library code is kind of designed by committee phenomenon that moreand more operations get added and the API becomes too broad or bloated.<br><br>4. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br><br>5. It wasdifficult to create solutions, to be able to test hypotheses against naturalphenomenon.<br><br>6. Well, that one doesn't exactly workbecause of a phenomenon called thrashing.<br><br>7. In the twentieth century, math, scientistsdeveloped mathematical models to try to understand natural phenomenon.<br>
intersects|sentence cnt : 7 <br> <br>1. Any interval thatintersects this query interval 23 25.<br><br>2. Try to find any interval that intersects our queryinterval.<br><br>3. So insert, find,delete, and find any interval that intersects.<br><br>4. And [inaudible], and then we have delete, and then we haveintersects.<br><br>5. So that is, for every line segment,you check whether it intersects with every other line segment.<br><br>6. That does not contain point 3 butnow which sub-tree do we search? [COUGH]In this case, now the rectangle intersects our splitting line, so we have to searchboth sub-trees, both above and below.<br><br>7. It also intersects the splitting line,so we have to search both the sub-trees.<br>
very|sentence cnt : 315 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. And the reason is that you only createa new array every time it doubles.<br><br>4. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>5. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>6. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>7. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>8. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br>
inherit|sentence cnt : 4 <br> <br>1. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>2. In particular,all Java classes inherit a method called hash code which is returnsa 32-bit int value.<br><br>3. So shouldn't use it inconnection with inheritance.<br><br>4. So we don't use inheritance that much soI won't talk about that.<br>
advantages|sentence cnt : 3 <br> <br>1. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br><br>2.But one of the big advantages of Quicksort over Mergesort is that it doesn't take anyextra space.<br><br>3. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
goes|sentence cnt : 62 <br> <br>1. And plus it goes on the operator stack.<br><br>2. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>3. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>4. So the one on the left array goes to k'sposition.<br><br>5.Insert R into that, it goes to the right of E.<br><br>6. If it goes on the right, then we attach a new node with thered link on the right but we have to rotate it to the left to make a legalthree node.<br><br>7. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>8. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br>
analogs|sentence cnt : 1 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br>
becomes|sentence cnt : 12 <br> <br>1. So in this case, we have an example where T, the node T here its value changes and it becomes larger than its parent key, P.<br><br>2. For whatever reason a parent becomes the key and decreases, it might become smaller than one or both of its children's.<br><br>3. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>4. That doesn't work i, t still becomes square root of n.<br><br>5. Now, there's another scenario where a key becomes smaller.<br><br>6. 6's route is zero 1's its own route, so zero becomes a child of one.<br><br>7. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br><br>8. So,why not just use those? Why use our own implementations? Well, the problem isoften in such library code is kind of designed by committee phenomenon that moreand more operations get added and the API becomes too broad or bloated.<br>
guarantee|sentence cnt : 49 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>3. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>4.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>5. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>6. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>7. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>8. If I want that guarantee, if I want to besure that every operation's going to be fast, I'll use a linked list.<br>
treating|sentence cnt : 1 <br> <br>1. Ourproblem we were treating partitioning, equal of partitioning element as one valueless than as another and greater than as another.<br>
oldfirst|sentence cnt : 2 <br> <br>1. So first thing we do is save awaythe pointer to the beginning of the list, that's oldfirst = first.<br><br>2. And its next the oldfirstitem on the list, which is now the second item on the list.<br>
occurrences|sentence cnt : 2 <br> <br>1. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>2. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br>
description|sentence cnt : 1 <br> <br>1. So just given that high level descriptionthen the implimintation is pretty direct.<br>
data|sentence cnt : 249 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. There's a, alarge amount of data.<br><br>3. So the clustering in the data is going tomake the implementation inefficient.<br><br>4. The first part is data typesorting and searching.<br><br>5. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>6. So that's three different clients, three completelydifferent types of data.<br><br>7. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>8. But for typical data, it's very efficient.<br>
lets|sentence cnt : 4 <br> <br>1. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>2. So lets look at how we implement those,first using linked list and then arrays.<br><br>3. So, lets see what the code does.<br><br>4. So Lets suppose that there is no intersect, and that'sequivalent to saying, if there is no intersection in the left then there is nointersection in the right.<br>
resolving|sentence cnt : 1 <br> <br>1. Now we're going to look at a technique forresolving that problem.<br>
knew|sentence cnt : 2 <br> <br>1. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>2. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br>
adapts|sentence cnt : 2 <br> <br>1. The way wemaintain, there's a number of ways we can maintain the thing but the one that we'lladopt un iformly because it adapts to more complicated situations is just beforewe're done with the put operation we'll say, okay we've done all our work andbefore we return the pointer to the given subtree we're going to take the size ofwhat's on the left and the size of what's on the right and add one for us and that'sgoing to be our count.<br><br>2. So we need a data-structurethat more gracefully adapts to the distribution of the data.<br>
comfort|sentence cnt : 2 <br> <br>1.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>2. And if M is prime,it gives us some comfort that we have some possibility of each table positionappearing with equal likelihood.<br>
adding|sentence cnt : 13 <br> <br>1. And this is just adding the Heapsort line to the table.<br><br>2. It's certainly worth adding them.<br><br>3. So we say that we're dealing withkeys that are comparable by simply adding this extents comparable key to ourdeclaration.<br><br>4. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>5. And this is when this parent is a 3-node,then there's the tree cases, If we split up the last split at themiddle and split at the right, And again, changing the four node to, to a2-nodes and adding links.<br><br>6. So that's adding this one line of code toMergesort will make it quite a bit faster.<br><br>7. Wehave full code it's the regular BST code with the couple of lines adding the callsand the basic operations.<br><br>8.And then this insertion into the parent changed it from a two, a 3-node into a4-node essentially adding a length cuz of the split with the two 2-nodes where therewas only one 3-node before.<br>
login|sentence cnt : 4 <br> <br>1. And again, with the same client login is key and getthe section as a value.<br><br>2. And so in the first call over here, we might use the loginname as the key and the first name as the value.<br><br>3. So, we type in somebody's loginname we get their first name.<br><br>4. So here's still another example where we might use for aclass list, which has the person's year of graduation, last name, first name preceptname and login name.<br>
modeled|sentence cnt : 3 <br> <br>1. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br><br>2. Or if it's some application where the order of insertion of the keys is wellmodeled by random order and that's not unusual at all.<br><br>3. We modeled theproblem to try to understand precisely what kinds of data structures andalgorithms we'd need to solve it.<br>
individual|sentence cnt : 4 <br> <br>1. So, as you can see in this examplewe start out by merging the first two sub arrays of size one to make a array of sizetwo - E, M - that's sorted, and then do the same thing for the next two elements and thenext two and so forth until eventually instead of sixteen individual elements wehave eight sorted subarrays of size two.<br><br>2. Sowhether it's individual atoms and molecules or some bigger kinds ofparticles.<br><br>3. And if I don't need that guarantee, if Ijust care about the total amount of time, I'll probably use the resizing-arraybecause the total will be much less, because individual operations are fast.<br><br>4. And not do the individual forcecalculation between our particle and every one of those in the aggregate.<br>
scenarios|sentence cnt : 1 <br> <br>1. And now, what we are going to do is take a look at just a couple of different scenarios that we violate that invariant temporarily, and then fix it.<br>
broadly|sentence cnt : 1 <br> <br>1. So it's more flexible and more broadly useful.<br>
causes|sentence cnt : 4 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>2. Anadversary can learn your hash function and just send you data that causes hugeperformance problem by just making all that data hash to one particular item.<br><br>3. Be, becausesince there's no intersections in the left sub tree high has gotta be less than C.<br><br>4. And that causes us to add a newentry into this internal, node.<br>
happening|sentence cnt : 6 <br> <br>1. Most of the operations are simple ones likethis happening at the bottom.<br><br>2. If you get allthe way through the array without that happening, then you say the array is true.<br><br>3. So that's what's happening over in theright there.<br><br>4. We have a binary search tree algorithm which is fine, in that it gives us log n performance for search and insert in a situation where we can think that these things are happening randomly.<br><br>5. So, more and more and more now a days people are developing computationalmodels, where they attempt to simulate what might be happening in nature in orderto try to better understand it.<br><br>6. This is interesting because we can draw the tree to get more intuition about what's happening, but in the actual data structure representation, we don't need any links at all, it's just an array.<br>
computations|sentence cnt : 1 <br> <br>1. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br>
derive|sentence cnt : 1 <br> <br>1.So this is a mathematical formula that we derive by examining the code but itcompletely describes mathematically what we an upper bound on the number ofcompares that are going to be needed.<br>
programmer|sentence cnt : 16 <br> <br>1." And many programmers live by that kind of preset.<br><br>2. Butinexperienced programmers often have trouble with it.<br><br>3. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>4. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br><br>5. And an experienced programmers know thisand it's not difficult to arrange for the natural types of data that peopleare going to use for symbol table keys.<br><br>6.sort and it's intended to be ageneral purpose sorting method for use by Java programmers.<br><br>7. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br><br>8. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br>
paying|sentence cnt : 3 <br> <br>1. We have onestudent who was paying attention to what we're saying and uses an array and canpick the indices into that array at random check whether they're open and, andrepeat.<br><br>2. So that's anotherreason to think about maybe paying a little extra and using to guarantee thatyou get with red black search trees.<br><br>3. Now there's a few rules and there's naturalrules but they're worth talking about and paying attention to that the compareTo()method has to implement in the so called a total order.<br>
variety|sentence cnt : 1 <br> <br>1. Now, the key point is that sorting algorithms rhythms are essentialin a very broad variety of applications and, and all of us use sorting algorithmspretty much every day.<br>
material|sentence cnt : 5 <br> <br>1. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>2. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>3. And then supporting that textbook, is free onlinematerial that we call the book site.<br><br>4. Where a vacant side is just empty and a block side hasgot some material, and either the water flows through from top to bottom, or not.<br><br>5. If you want to review the material that we think isprerequisite for the material in this course, you can do a quick review bylooking at sections 1.<br>
communicating|sentence cnt : 1 <br> <br>1.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br>
avoidance|sentence cnt : 2 <br> <br>1. So, that's asummary of linear probing or second hash, collision avoidance strategy.<br><br>2. So you have collision avoidance, where you always try to pointaway from the k nearest boids.<br>
generic|sentence cnt : 31 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>3. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>4. Somehow we're going to want the valuebe any generic type at all but the key type we have to make somenatural assumptions about them.<br><br>5. So, since we're making array ofnodes, a node would have generics if we use to key in value.<br><br>6. So symbol tables are ST is the type,symbol table, they're generic in key and value.<br><br>7. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>8. So, we'll build a new array of keys and we have to use an ugly cast because of generic arrays in Java, and that's where it's comparable and we need one more than the capacity to handle this thing where we don't use position zero.<br>
interval|sentence cnt : 47 <br> <br>1. This is called intervalsearch.<br><br>2. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>3. Any interval thatintersects this query interval 23 25.<br><br>4. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>5. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>6. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>7. And then, what we're looking for is to find or count the pointsin a given interval in one dimension.<br><br>8. Try to find any interval that intersects our queryinterval.<br>
core|sentence cnt : 3 <br> <br>1. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>2. Hashing really at its core isa classic space-time tradeoff.<br><br>3. In fact,almost any computer application system is going to have a symbol table ormultiple symbol tables at its core all the way down to the basicmemory system of the computer or the networking system that your computeraccess to information depends on.<br>
association|sentence cnt : 3 <br> <br>1. And that's an association that'swell known to biologist and then you can use this lookup CSV client to quickly getthe name associated with any given codon.<br><br>2. So the client will build a symbol table that makes us associations for everyline in the file and this could be huge file.<br><br>3. So the clientmethod put of course, just is supposed to do the association so it has a voidreturn.<br>
created|sentence cnt : 5 <br> <br>1. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>2. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>3. So it's worthwhile youknow, checking that you believe that this code implements the simple binary searchtree algorithm that we demoed where when we fall off a null link we created a newnode and replaced that null link with the new node .<br><br>4. Linus Torvalds, who created lin, Linux, saysthat the difference between a bad programmer and a good one is whether heconsiders his code or his data structures more important.<br><br>5. And the idea of immutable data type is you can't change the value once it's created.<br>
issues|sentence cnt : 3 <br> <br>1. Now, there's a lot ofissues in doing this.<br><br>2. So, this isn't just an example about software security, there's a lot of difficult and deep issues to worry about in software security, and we're not going to worry about all of them.<br><br>3. And these things are not difficult but they're all worth articulating asseparate issues that we have to deal with in order to get an effectivesingle table implementation.<br>
respect|sentence cnt : 3 <br> <br>1. It's optimal with respect to both space and time.<br><br>2. And then if you look at thepolar angle with respect for every other point with the respect to that one, so theangle you get from of the x-axis through p up to the point, then the vertices appear inincreasing order of that angle.<br><br>3. Really what we proved is that mergesort is optimal withrespect to number of compares but we already know that it's not optimal withrespect to space usage.<br>
numerical|sentence cnt : 1 <br> <br>1. Today, we're goingto talk about event-driven simulation which is an interesting idea that is basedon priority queues but it's also used in numerical computation and we'll see inalgorithms for data compression and graph searching that it's useful.<br>
instantly|sentence cnt : 1 <br> <br>1. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br>
electricity|sentence cnt : 2 <br> <br>1. And so if there's a conductor from top to bottom then the thing conductselectricity.<br><br>2. You can think of for electricity.<br>
does|sentence cnt : 122 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>3. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>4. And if it does, print the value associated with the key.<br><br>5. Even though we know we're not using it,the Java system doesn't know that.<br><br>6. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>7. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>8. And now 2123 does intersect 1622, so wereturn and intersection.<br>
deals|sentence cnt : 1 <br> <br>1.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br>
done|sentence cnt : 78 <br> <br>1. So we're done with 4, and we come to 3.<br><br>2. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>3. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>4. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>5. So then we're done, andwe found that the nearest neighbor is 5.<br><br>6. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>7. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>8.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br>
amounts|sentence cnt : 5 <br> <br>1.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>2. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>3. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>4. So, as that example shows,2D trees are extremely effective in quickly processing hugeamounts of geometric data.<br><br>5. And so it's a simple idea butexpert scientists were struggling with dealing with hugeamounts of geometric data.<br>
intermediate|sentence cnt : 2 <br> <br>1. So, what is this course? It'san intermediate level survey course on algorithms.<br><br>2. Shellsort, we don'tknow it's a running time, it's not stable but it's a fast method for intermediatesize files and not much code.<br>
series|sentence cnt : 3 <br> <br>1. And then a series of pairs of object names.<br><br>2. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>3. Sowith a series of in exchange and then sync operations, we pull the sorted array outof the heap.<br>
themes|sentence cnt : 2 <br> <br>1. And that's one of our main themes in thiscourse.<br><br>2. And one of the themesthat we'll go through over and over in this course is that quadratic time is muchto slow.<br>
manage|sentence cnt : 3 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>2. But what's nice about data driven code is now that the code's workingand again we, we're not saying that this is a trivial code to write but it'sdefinitely manageable.<br><br>3. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br>
assumptions|sentence cnt : 2 <br> <br>1. Somehow we're going to want the valuebe any generic type at all but the key type we have to make somenatural assumptions about them.<br><br>2. And actually there's differentassumptions that we'd make in our implementations dependingon the application.<br>
performed|sentence cnt : 2 <br> <br>1. And the bottom line is that we can articulate anAPI for generic stacks that works for any type of data and we've got twoimplementations, link list and arrays that, that performed very well for [cough]any type of data using the, the resizing or link list as we've described.<br><br>2. So for example, in this set of ten objects, weperformed already, a bunch of union commands, connecting four and three, threeand eight, six and five, nine and four, two and one.<br>
simpl|sentence cnt : 151 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>3.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>4. So this is a simple test client thatwe can use to test our implementations.<br><br>5. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>6. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>7. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>8. And now build asimple table that associates strings with strings.<br>
cuts|sentence cnt : 2 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. That's a bit of a hack, but it cuts down on a lot ofcode.<br>
dimension|sentence cnt : 36 <br> <br>1. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>2. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>3.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>4. So this is, we'll start withone dimension as before and right away you can see that it's a more complicatedproblem than we've been dealing with.<br><br>5. And then, what we're looking for is to find or count the pointsin a given interval in one dimension.<br><br>6. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>7. We can use a two-dimensional arrayto directly index relevant squares.<br><br>8. We just use that dimension ofthe point to do the comparison.<br>
graham|sentence cnt : 10 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>3. And that method is the basis for the Graham Scan.<br><br>4. And the algorithm that we're going to look at, called the Grahamscan is based on those two facts.<br><br>5. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br><br>6. So this code is thebasis for applying the sort, system sort method or any sort method for the Grahamscan for the convex hull that we did at the end of the last lecture.<br><br>7. So that's thebasis for the Graham scan method for the convex hull that we used at the last, atthe end of the last lecture.<br><br>8. The Graham Scanuses a sort where we give two different ways to sort the points.<br>
eval|sentence cnt : 10 <br> <br>1. For detailed information ona performance, eval grievance.<br><br>2. In all possible ways, andyou can get two to the N strings, for any N of length to N that all hash to the samevalue.<br><br>3. A way of evaluating a polynomial ora number.<br><br>4. Use parallel arrays [inaudible] and thevalue array with the same index.<br><br>5. We have operands andoperators and you want to evaluate it.<br><br>6. Two dates should be equal if they havethe same day, month, and year and if any one of those are not the samevalue then just returns false.<br><br>7. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>8. Well, sorry, you have to take the absolutevalue because otherwise it'd be negative and you can't have it negative.<br>
arrays|sentence cnt : 47 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>3. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>4. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>5. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>6. Or actually Java implementsthat in its arrays library.<br><br>7. And we have four subarrays ofsize four.<br><br>8. Use parallel arrays [inaudible] and thevalue array with the same index.<br>
rectangles|sentence cnt : 12 <br> <br>1. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>2. And, and that willgive us now three rectangles on our sweep line.<br><br>3. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>4. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>5. So now, we have a bunch of rectangles.<br><br>6. We don't haveany, any equal lines that we have to worry about whether we consider rectangles thattouch to be intersecting, and so forth.<br><br>7. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br><br>8. All right, so what about the analysisof how long is this is going to take? Well, again, a typical case, rectanglesare small that we're only going to examine really the path of the tree maybea couple of other nodes along with path.<br>
usually|sentence cnt : 24 <br> <br>1.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>2. And usually that's fairly straightforward.<br><br>3. Actually it usually crashes because it's recursive andit crashes the system stack.<br><br>4. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>5. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br><br>6. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>7. But otherwise, usually it's a CCW call in this code which again Iwon't go through in detail as an implementation of a comparator for two Dpoints.<br><br>8. Usually way, the way to show that a sortis not stable and it's just to see if it has a long distance exchange that mightmove an item pass some equal item.<br>
computer|sentence cnt : 57 <br> <br>1. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>2. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>3. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>4. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>5. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>6. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>7. Maybe the way yourcomputer's memory is organized make a difference.<br><br>8. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br>
divides|sentence cnt : 2 <br> <br>1. And all it does is divides by 2 again andthen throws out another 1.<br><br>2. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br>
references|sentence cnt : 15 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>3. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>4. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>5. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>6. Well,if you think about it for just a minute, you see that what you need to do is justremove all references to value from any of the symbol table implementations that we'dlook at.<br><br>7. So how are we'regoing to represent binary search trees in Java? Well, we're going to extend ourimplementations of linked list structures to have two references instead of justone.<br><br>8. And then we want to know if two referencesrefer to objects that have the same value and we want to call that equal,now that's what equals is about.<br>
hide|sentence cnt : 2 <br> <br>1. When we continue toimplement sorting algorithms, we're actually even in a hide that beneath ourown implementations.<br><br>2. Now, we could use a interval bag or some data structure likethat and hide the link list structure underneath and that's a perfectly fine wayto proceed in modern programming.<br>
easiest|sentence cnt : 2 <br> <br>1. In the easiest case is, that node has no children.<br><br>2. This is a, one of the easiest ways toimplement the merge.<br>
tradeoff|sentence cnt : 6 <br> <br>1. Hashing really at its core isa classic space-time tradeoff.<br><br>2. So that's a tradeoffthat the client can make.<br><br>3. So even with these simple data structures,we have really important tradeoffs that actually make a differencein lots of practical situations.<br><br>4. So, what are the tradeoffs between usinga resizing array versus a linked list? Those are two differentimplementations of the same API, and the client can usethem interchangeably.<br><br>5. And for many, many clients,that's an effective tradeoff to make.<br><br>6. So what hashing is kind of inthe real word where we're trying to tradeoff this idea that wedon't have unlimited space and we also don't unlimited time sowe're trying to find something in-between.<br>
constructing|sentence cnt : 2 <br> <br>1.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>2. So, let's do a demo of constructing the red-black BST from ourstandard set of keys.<br>
belongs|sentence cnt : 1 <br> <br>1. And for insert, you just take (x,y),figure out which square it belongs to.<br>
rearrange|sentence cnt : 6 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2.sort is a method that takes anarray a as its parameter and it, it's the first argument and it rearranges thestrings in that array to be in sorted order.<br><br>3.Rearrange the terms, so we get n+1 cn-1 and then divided by n, n+1.<br><br>4. So what we have to do first is to rearrange the keys in the array to heaporder it.<br><br>5.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br><br>6. There's actually a very easy way to rearrange an array so that the result is a uniformly random permutation, and only require linear time to get the job done.<br>
needed|sentence cnt : 10 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>3.That random shuffle at the beginning is important and needed for guaranteeingperformance.<br><br>4. We needed tohave a comparison for points that orders them by the polar angle they make, makewith the given point p.<br><br>5. And that shuffle is needed to make surethat we can guarantee that the performance is gonna be good.<br><br>6. The bottom line in this is sequence of passes through thewhole array and there's no recursion needed at all.<br><br>7. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br><br>8. As you can see, only one, two,three, four, five exchanges are needed to bring this into heap order.<br>
intersection|sentence cnt : 52 <br> <br>1. And now 2123 does intersect 1622, so wereturn and intersection.<br><br>2. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>3. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>4. Just check for anintersection, if we find it ret urn if left is no we go right.<br><br>5. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>6. Alright so now we're gonna look tosee if we have an intersection what a.<br><br>7. Be, becausesince there's no intersections in the left sub tree high has gotta be less than C.<br><br>8. No intersection in the left means no intersections at all, sothose two cases is enough to show that this algebroid finds an intersection, ifthere is one.<br>
distance|sentence cnt : 17 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. So the first point that's the closestwe found so far to the query point, so we'll save our number 1 as the distance.<br><br>3. We did a long distance exchange and thatcatapulted that first item past any item that it might be equal putting them out oforder.<br><br>4. Usually way, the way to show that a sortis not stable and it's just to see if it has a long distance exchange that mightmove an item pass some equal item.<br><br>5. Whenever we're at a node, it represents apoint, so we're going to check that point and we'll compute the distance fromthat point to our query point.<br><br>6. It's basically that distancedivided by the by the velocity.<br><br>7. So, you have to take both velocities and divide theirdistance by those and, and so forth.<br><br>8. The distance from the root to the bottomis always the same.<br>
scramble|sentence cnt : 2 <br> <br>1. So idealistically, what we'd likeis to be able to take any key and uniformly scramble it toproduce a table index.<br><br>2. Trying to take all the bits andscramble all the bits and use them.<br>
seed|sentence cnt : 2 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. Another problem is in this implementation, the random uses just a 32-bit seed, if you do that, there's not enough possible shuffles.<br>
award|sentence cnt : 1 <br> <br>1. This method was invented in 1961 by TonyHore, who won the Turing Award in 1980 for this and other work.<br>
days|sentence cnt : 20 <br> <br>1. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>2. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>3. Otherwise, the year, years must be equalso we have to look at the months to do the compare and so forth down to do the days.<br><br>4. Another reason nowadays to studyalgorithms is that, they have become a common language for understanding, nature.<br><br>5. And nowadays that means priority queues.<br><br>6. So what we can do is it's pretty easy to find a family of stringsthat have the same hash code for example with just a little fooling around now daysyou can just look it up on the web, you can see that these two character keys,both have the same hash code because when you just do the math in a base 31 hashcode it'll tell you that answer.<br><br>7. In mostdatabases, nowadays that, that you might use.<br><br>8. You can't have M too large, whatwe want to use nowadays is array resizing to make sure that the array is alwaysabout half time, half full.<br>
substantial|sentence cnt : 2 <br> <br>1. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>2. So, why we are interested in this algorithm? Well, it's a simple ideathat leads to substantial performance gains.<br>
exceed|sentence cnt : 1 <br> <br>1. And that's diffidently one thingto consider when using hashing is that the cost of computing the hash function for acomplicated key might exceed the cost of searching and using a simpler structurelike a binary search tree.<br>
costly|sentence cnt : 2 <br> <br>1. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br><br>2. And so that'sdefinitely going to be costly eh, if you're doing this operation a, a lot.<br>
supercomputer|sentence cnt : 1 <br> <br>1. And a supercomputer can do it in aninstant.<br>
accordingly|sentence cnt : 4 <br> <br>1. The first thing to check is find out which one is bigger, it's either 2k or 2k plus one and so set J accordingly.<br><br>2. Or if we did the other way around and proceeded accordingly.<br><br>3. And if there is, then we couldroll back time just a little bit and I'll try to figure out exactly, the moment ofwhich they collided and then figure out how the position and velocity shouldchange accordingly and then continue the simulation.<br><br>4. Doone partition then check whether you to your k-th element is going to be on theleft part or the right part and reset lower high accordingly.<br>
counterclockwise|sentence cnt : 11 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. Example at the right, a to b to c is not counterclockwise.<br><br>3. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>4. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>5. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>6. Now that's essentially the proof that you have to have acounterclockwise turn.<br><br>7. Sothe main part of computation that we haven't really talked about and we'llcover briefly is if we have three points, a, b and c, and you go from a to b to c,are you making a counterclockwise turn or not? So, in the example at the left, a tob to c is counterclockwise.<br><br>8. And then we'll just throw awaythe ones that do not create a counterclockwise turn and you'll see howthat works when we look at the demo.<br>
proceeding|sentence cnt : 2 <br> <br>1. And then proceeding inthat way, moving bottom up or moving from right to left, the next thing we do is butthen worry about a three node heap that's heap ordered and we're fine.<br><br>2. So that's just a, a way of make suring that the simulation keepsproceeding.<br>
changing|sentence cnt : 23 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. To put it in sorted order, we have to movefrom right to left, exchanging it with every larger elements to its left, andthat's what the code at the bottom does.<br><br>3. Whereas on the other hand, sometimes the whole purpose of a data type is to maintain a changing value.<br><br>4. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br><br>5. So, it will get added to, as the right link of A and every time weadd a node we just create a red link to its parents and so, that's changing thetwo node into a three node.<br><br>6. So you wouldn't put those things on a priority queue because the value is changing, but the other ones you would.<br><br>7. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br><br>8. So we move up the tree exchanging the larger key with its smaller parent until we get to a point where it's larger than both its children.<br>
desired|sentence cnt : 1 <br> <br>1. Plugging in N log N we get the desiredresult.<br>
increasing|sentence cnt : 3 <br> <br>1. Again simulation of the naturalworld is an increasingly important application of computing and needefficient data structures like priority queues to get it done.<br><br>2. So, in a binary search tree, those rank numbers goin an increasing order as we do in an ordered traversal and that's easy tocompute.<br><br>3. And then if you look at thepolar angle with respect for every other point with the respect to that one, so theangle you get from of the x-axis through p up to the point, then the vertices appear inincreasing order of that angle.<br>
pages|sentence cnt : 7 <br> <br>1. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>2. And the full pageabout to split then right below there's two pages.<br><br>3. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>4. We're only counting the number oftimes we access the pages.<br><br>5. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br><br>6. Whenit fills up, it's red, and that splits into two half pages and then keys getadded on one side or the other so each.<br><br>7. Now we have three pages andwe keep going eventually one of them fills up and splits.<br>
underlies|sentence cnt : 1 <br> <br>1. To start, we'll talk about 2-3 searchtrees, which is a model that underlies the concise and efficient implementation thatwe're going to look at.<br>
needs|sentence cnt : 9 <br> <br>1. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>2. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br><br>3. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>4. So what we want to choose is this squaresize that would best balance these two needs.<br><br>5. And the real practical challengewith hashing is that developing a hash function is that every typeof key needs a hash function and you need a different approach forevery key type.<br><br>6. Sothere needs to be a mathematical analysis to, to characterize the running time ofthis program in the fact is that quick select this method takes linear time onthe average.<br><br>7. Well, let'slook at the other two cases and these understanding needs is crucial tounderstanding the whole algorithm.<br><br>8. Now, that compareTo() method is really all that the sortimplementation needs.<br>
experienced|sentence cnt : 3 <br> <br>1. Butinexperienced programmers often have trouble with it.<br><br>2. And an experienced programmers know thisand it's not difficult to arrange for the natural types of data that peopleare going to use for symbol table keys.<br><br>3. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br>
cheat|sentence cnt : 3 <br> <br>1. So we need to remove this cheat andwe will, but the code is nearly trivialif we have the capacity.<br><br>2. Now, we're cheating in thisimplementation to keep it simple, and we'll take care of thischeat in a little while, by requiring the client to providethe capacity of the stack.<br><br>3. We didn't put in the this is thecheat version where we require the client to provide a capacity but we could easilychange this to a resizing array.<br>
links|sentence cnt : 53 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. But we have to use a little extra time andspace to deal with the links.<br><br>3. Links can be null.<br><br>4. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>5. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>6. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>7. So, what we are going to do is use internalleft-leaning links to glue the three nodes together.<br><br>8. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br>
increasingly|sentence cnt : 1 <br> <br>1. Again simulation of the naturalworld is an increasingly important application of computing and needefficient data structures like priority queues to get it done.<br>
honored|sentence cnt : 1 <br> <br>1. In fact Quicksort, which we'll consider next time, was honored as one of the top 10 algorithms of the 20th century inscience and engineering.<br>
nowadays|sentence cnt : 16 <br> <br>1. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>2. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>3. Another reason nowadays to studyalgorithms is that, they have become a common language for understanding, nature.<br><br>4. And nowadays that means priority queues.<br><br>5. In mostdatabases, nowadays that, that you might use.<br><br>6. You can't have M too large, whatwe want to use nowadays is array resizing to make sure that the array is alwaysabout half time, half full.<br><br>7. Or, even nowadays youmight have matrices that are, are even bigger.<br><br>8. With arrays, it doesn't quite work andagain all programming languages and, you know, many programming languages nowadayshave difficulties with this and Java's got a particular difficulty.<br>
statement|sentence cnt : 9 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>3. So Java is just an assert statement.<br><br>4. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>5. Not an easyanalysis, but we actually could make precise accurate statements about theperformance of this algorithm.<br><br>6. Like these are all the ones associatedwith this, lecture, so we might build an indexfrom that set of files, and then we might wonder well where do we use the importstatements.<br><br>7. I, I think maybe they might have added to this warning statement "We apologize for making you do this".<br><br>8. So that's J now is after this statement, is the larger of the two children.<br>
increases|sentence cnt : 7 <br> <br>1. That's the swim operation to eliminate violation when a key value increases.<br><br>2.Increases the number of exchanges paradoxically, cuz more exchanges arerequired when the partition is right in the middle.<br><br>3. And that's really easy to convince yourself that that's true because the height if we add nodes one at a time going from left to right on the bottom level say, the height only increases when N is the power of 2.<br><br>4. So, when the depth of x increases, the size of its tree at least doubles.<br><br>5. And in this case there is no paren, so wecreate a new one and the height of the tree increases by one.<br><br>6.That's the only time the height of a 2-3 tree changes, when the roots splits theheight introduces increases by one.<br><br>7.We convert that 3-node into a temporary 4-node, but then we need to split that4-node moving E to the parent and that creates a new, root node and increases thesize of the tree by one, But now that's a legal 2-3 tree so we stop.<br>
plugging|sentence cnt : 1 <br> <br>1. Plugging in N log N we get the desiredresult.<br>
flexible|sentence cnt : 3 <br> <br>1. And it's very flexible andvery useful in lots of applications.<br><br>2. Today, we're going to lookat Priority Queues which is a variant of sorting that generalizes the idea toprovide more flexible data structure that we can use for all sorts of applications.<br><br>3. So it's more flexible and more broadly useful.<br>
nature|sentence cnt : 5 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. Another reason nowadays to studyalgorithms is that, they have become a common language for understanding, nature.<br><br>3. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br><br>4. Complete binary trees actually happen in nature.<br><br>5. So, more and more and more now a days people are developing computationalmodels, where they attempt to simulate what might be happening in nature in orderto try to better understand it.<br>
mainly|sentence cnt : 1 <br> <br>1. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br>
matters|sentence cnt : 1 <br> <br>1. So, since the only thing thatmatters is collisions, we are going to figure the particles move in a straightline, between collisions.<br>
conductor|sentence cnt : 2 <br> <br>1.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>2. And so if there's a conductor from top to bottom then the thing conductselectricity.<br>
rotated|sentence cnt : 1 <br> <br>1. So, we do the standard BST insert color the new link red and then if that[cough] new three node happens to lean right, rotated to the left.<br>
statistical|sentence cnt : 2 <br> <br>1. And now, the statistical problems are like that or findingduplicates.<br><br>2. If you want to find the pairof points that are the farthest apart in the set of points in the plane, this issometimes important in statistical calculation or other applications.<br>
introductory|sentence cnt : 1 <br> <br>1. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br>
complexity|sentence cnt : 6 <br> <br>1.So complexity's going to tell us that it's a quadratic algorithm if that's what itsworst case is.<br><br>2. That's a lower bound on the complexity of sorting.<br><br>3. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br><br>4. The idea of complexity is it's a framework for studying the efficiency of all the algorithms for solving a particularproblem.<br><br>5. That's called Computational Complexity.<br><br>6. But the delete operation for Binary Search Trees shows us the kind of complexity that we can encounter with working with these kinds of data structures.<br>
invariant|sentence cnt : 15 <br> <br>1. Then once we've exchangedit, again, we preserved our invariant.<br><br>2. So,now the invariant might be violated so we have to fix it.<br><br>3. So we have to look at the code that'sgoing to maintain that invariant as the pointer increments.<br><br>4. So let's, one way to understand the way that an algorithm works is tothink about invariants .<br><br>5. So the invariant of that is thatthe array is always between 25% and 100% full, number one.<br><br>6.In the, all during the partitioning process, the code is maintaining thisinvariant.<br><br>7. So the codeimplements the invariants.<br><br>8. Again, we can look at insertionsort in terms of invariants.<br>
useful|sentence cnt : 30 <br> <br>1. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>2. Andthat's a very useful thing because otherwise, we might try to define such analgorithm.<br><br>3. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>4. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>5. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>6. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>7. So we can,implement these, efficiently and they are, convenient and useful for the clients.<br><br>8. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br>
totally|sentence cnt : 7 <br> <br>1. Still has to go through, even ifit's totally sorted, still has to go through to the side where that minimumelement is.<br><br>2. Now,that's not quite as good as totally flattening actually in practice that itactually is just about as good.<br><br>3. The thing is totallyunsorted, then it gets sorted until subarrays to size four, then eight,sixteen, and 32.<br><br>4. The only, the, the tree that hasthe most leaves of height h is totally complete and that one has two^h leaves.<br><br>5. But there won't be anotherresizing array operation until it either gets totally full orhalf again full.<br><br>6. All of these keys, which are totallydifferent, would wind up having the same collision.<br><br>7. That's pretty helpful although not, nottotally helpful but there's a lot of situations wherethat's helpful.<br>
compared|sentence cnt : 14 <br> <br>1. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>2. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br><br>3. It's going to be less than lg N and compares and it's got support for allthose ordered ST operations, and compared to and is pretty easy and natural functionto implement.<br><br>4. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br><br>5. It's a very small number compared toN.<br><br>6.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br><br>7.And this one is kind of upside down as compared to Mergesort.<br><br>8. Notice that we didn't increment ibecause that element z that is over in the right, really hasn't been compared to thepartitioning element yet.<br>
centuries|sentence cnt : 1 <br> <br>1.And so, for example, what this table shows, if you were to tryto use a insertion sort for a huge file, say a file with a billion elements,on your PC it'd take a few centuries tofinish.<br>
denominator|sentence cnt : 1 <br> <br>1. So, this is so when we have the GCD function, computing thegreatest common denominator, greatest common denominator p and q is greatestcommon denominator of q and p mod q and it just calls itself until q gets to be zero.<br>
gotta|sentence cnt : 8 <br> <br>1. If it's in thetree, it's gotta be according to the left or right, according to whether it'ssmaller or larger than the key at the route.<br><br>2. And now, we've gotta find BST.<br><br>3. Be, becausesince there's no intersections in the left sub tree high has gotta be less than C.<br><br>4. In this case, if we're searchingfor G, it's gotta go left, because it's less than S.<br><br>5. We'll use get class andthat's something that's gotta work or you'll get an exceptionin this later code.<br><br>6. When we come against the E,we gotta go right because it's bigger than E against the R, we have to go left,because it's less than R.<br><br>7. And well, we'vegotta have at least, two, keys at the root.<br><br>8. To make sure that if the queueis empty after we move an item we gotta set last to null.<br>
missing|sentence cnt : 2 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>2. Now,what's missing in this is what happens when the balls collide with each other.<br>
unsuccessful|sentence cnt : 4 <br> <br>1. And if it's unsuccessful, you can use that rank to figureout where to insert the new key.<br><br>2. So, for example, for Q,that's an unsuccessful search.<br><br>3. What about an unsuccessful search? Well the same rules follow.<br><br>4.Let's take another example for unsuccessful search, a key that's not inthe tree.<br>
minimum|sentence cnt : 29 <br> <br>1. And in this case it's H, and we put that node in T spot and then delete the minimum.<br><br>2. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>3. Give me the minimum key, give me the largest key, andthen I can get the value associated with that using that.<br><br>4. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>5. What about deleting the minimum? Well actually, that's maybe not too difficult.<br><br>6. So we just find that minimum node.<br><br>7. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br><br>8. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br>
skeleton|sentence cnt : 4 <br> <br>1. So that's our skeletonimplementation, let's look at the keys.<br><br>2. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>3. So, that's theskeleton.<br><br>4. So here's the skeleton ofour symbol table implementation.<br>
sinse|sentence cnt : 2 <br> <br>1. So actually once you 1-sort, that'sInsertion Sort so you're going to always get a sorted result.<br><br>2. Now, sinse the hash code can be negative,this doesn't quite work the way this arithmetic implement and Java,because it's one in a billion times.<br>
feature|sentence cnt : 2 <br> <br>1. Andthat's a key feature of binary search trees that we'll come back to again whenwe look at more sophisticated data structures.<br><br>2. It's not somethingthat you will come up with on your own and that's, and that's an undesirable feature,I think for codes so simple as this.<br>
fault|sentence cnt : 5 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>3. So by default, insertions are disabled.<br><br>4. Now, the default implementation for hashing is the memoryaddress of the object.<br><br>5. And again the default implementation is tocheck whether we refer to the same object and that's rarely what we want,Java system's programs may be want that.<br>
resulting|sentence cnt : 1 <br> <br>1. Supply that operator to those values and put theresulting value that you get back on to the operation stack.<br>
vals|sentence cnt : 13 <br> <br>1. This is called intervalsearch.<br><br>2. Do the same thing in the vals array.<br><br>3. So that's a binary search tree built, from thoseintervals.<br><br>4. And if we wanna find all intervals we just have to run thealgorithm fur Each interval that's, until we come up against no intersection, soit'll take time proportional to R log N if there's R intervals that intersect.<br><br>5. So this isthe binary search tree that's built from those five intervals, six intervals in ourexample.<br><br>6. So given a queryinterval, we want to find all intervals in the data structure that overlap thatinterval or find any interval we'll start with that simpler problem.<br><br>7. So now instead of points, our data is intervals.<br><br>8. So our, eh,our node stored intervals, but we only use our left end point as the key.<br>
made|sentence cnt : 3 <br> <br>1. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>2. But we did decrement gt so we made progress.<br><br>3. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
familiar|sentence cnt : 13 <br> <br>1. Stacks are familiar.<br><br>2. And you're familiar with this.<br><br>3. And if you're familiar with it, fine.<br><br>4. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br><br>5. In well, this is, the very special casethat you're very familiar with.<br><br>6. Here's maybe a more familiar sort client that sort strings.<br><br>7. So Integer with the capitalized rapid typefor int and so forth and many of you were probably familiar with that.<br><br>8. You may be somewhat familiar with these, but today we're going to takea careful and close look at them.<br>
distribute|sentence cnt : 8 <br> <br>1. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>2. So if the points are randomly distributed,then this is ideal.<br><br>3. Essentially if you have M entries in the hash table and Mkeys the link of list you're going to look at is about N over M cuz they're evenlydistributed.<br><br>4. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br><br>5. So it's all finesorted by name and but then in order to distribute it out to the people leading itto the sections, what we want to do is sort by the second fields, sort bysection.<br><br>6. And this is absolutely a fine methodthat is not that difficult to implement, in the case that the pointsare evenly distributed.<br><br>7. Unfortunately, it's usually the case in geometric data that the pointsare not evenly distributed.<br><br>8. And they're pretty uniformly distributed.<br>
greater|sentence cnt : 47 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. If it'sgreater we go to the right.<br><br>3.In a regular BST node, the 2-node, we have one link for the keys that are less thanthe key in the node, and one link for the keys that are greater.<br><br>4. Seventeen, nineteen is at the root, so everybody with a le ft end pointless than seventeen is to the left, the left end point greater than seventeen isto the right and so forth.<br><br>5. And what we need to do is just exchangethe 5 with every element to its left that's greater.<br><br>6. Now, what about when we get one that's greaterthan the partitioning elements? So, in that case, we exchange greater the oneover at the right with i and decrement gt.<br><br>7. Ourproblem we were treating partitioning, equal of partitioning element as one valueless than as another and greater than as another.<br><br>8.If this object is greater than the object given as argument.<br>
possibly|sentence cnt : 10 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br><br>3. So in this case, we have to search both, there might possibly be a closerpoint than 1 over in the right.<br><br>4. Now,there is a possibly that something else happened to t hem in between and we'lltalk about that change, too.<br><br>5. So, and let's take a look athow we can possibly make this happen.<br><br>6. In fact,we couldn't possibly hope to even store them all.<br><br>7. Thetheoretical best that you could possibly do would be R plus log N but in practice Rlog N is quite efficient.<br><br>8.Now, we compare H with E and J, and in this case it's between, so now we aregoing to take the middle link, that's the only place that H possibly could be.<br>
underneath|sentence cnt : 1 <br> <br>1. Now, we could use a interval bag or some data structure likethat and hide the link list structure underneath and that's a perfectly fine wayto proceed in modern programming.<br>
color|sentence cnt : 45 <br> <br>1. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>2. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>3. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>4. And then we rotate thetop link right and then, we flip the colors.<br><br>5. X's color is stillgoing to be h's color.<br><br>6. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>7. It's called a color flip.<br><br>8. What we do is put a bit, a color bit in each in the nodeclass.<br>
sparse|sentence cnt : 6 <br> <br>1. So, here's what the implementation of a sparsevector might look like.<br><br>2. But with the symbol table implementation we can ef ficientlyprocess huge sparse.<br><br>3.As a final example of a symbol tableclient, we'll take a look at a mathematical application where we want toimplement sparse vectors and matrices.<br><br>4. So now if wehave a sparse matrix times a vector our running time is going to be constant foreach row or proportional to the number of non-zero entries for each row which meansthat the running time is going to be linear for a sparse matrix just by the useof a symbol table.<br><br>5. But the fact is that in manypractical applications, the matrices are what's called sparse.<br><br>6. Now we're going touse a sparse matrix representation, where each row of the matrix is a sparse vector.<br>
moby|sentence cnt : 2 <br> <br>1. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br><br>2. The word whale is only in, Moby Dick.<br>
greatly|sentence cnt : 1 <br> <br>1. So we have to greatly expandour, our table.<br>
priorit|sentence cnt : 62 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>3. And then that's a time in the futureand we'll put that event on the priority queue with that time as the key.<br><br>4. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>5. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>6. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>7. All right, now the way we're going to use a complete binary trees to implement priority queues is to first of all associate information with each node.<br><br>8. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br>
mathematically|sentence cnt : 2 <br> <br>1. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br><br>2.So this is a mathematical formula that we derive by examining the code but itcompletely describes mathematically what we an upper bound on the number ofcompares that are going to be needed.<br>
chunk|sentence cnt : 2 <br> <br>1.And again, when there's a lot of equal keys then there's going to be place whereone of those is chosen, it's partitioning element then a big chunk of the array getshandled just in a partitioning process.<br><br>2. So it's the first little chunck and thenthe next little chunk and then merges those together, andso forth and so on.<br>
paradigm|sentence cnt : 1 <br> <br>1. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br>
variation|sentence cnt : 2 <br> <br>1. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>2.That's another variation on the team.<br>
orange|sentence cnt : 2 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2. So, in this example we have two types with two stacks one of apples andone of oranges.<br>
careful|sentence cnt : 12 <br> <br>1. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>2. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>3. So you'd have to be a little carefulthat somebody is in there doing that.<br><br>4. So, the simulation has to be careful to take thatinto account.<br><br>5.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br><br>6. You may be somewhat familiar with these, but today we're going to takea careful and close look at them.<br><br>7. You have to carefully check the code to be sure.<br><br>8.Now you have to be a little bit careful with terminating the loop.<br>
representing|sentence cnt : 3 <br> <br>1. It's in it's final position and you can see down at thebottom, the large elements in the array filling in, in their final position, inthe, the left part of the array is representing the heap.<br><br>2. And again, we wind up with a single tree representing all the objects.<br><br>3. We aregoing to think of that array as representing a set of trees that's calleda forest as depicted at right.<br>
freedom|sentence cnt : 1 <br> <br>1. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br>
killer|sentence cnt : 2 <br> <br>1. There was a killer input that will make thething run in quadratic time.<br><br>2. There's akiller input for the system sort and, and it can be disastrous in various systemsand the reason is, they didn't do the random shuffling.<br>
simplicity|sentence cnt : 2 <br> <br>1. And then, this is just for simplicity to get this done andjust part of a lecture.<br><br>2. For simplicity, we'll show the code where the client gives the capacity of the heap.<br>
context|sentence cnt : 12 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>3. Andthis is a very general concept that's useful in all kinds of context.<br><br>4.So let's just look at a little bit of thecontext of hashing in practical applications.<br><br>5. The word majesty appears in three places,and there's, there's the context.<br><br>6. That's our context for hashing algorithms.<br><br>7.The words cities actually only appears in this one place and this is [COUGH] Contextthat it appears.<br><br>8. And context just means a few words beforeand a few words after.<br>
immediate|sentence cnt : 8 <br> <br>1. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br><br>2. And that immediately gives this code forinsertion sort, which is similar to our code forselection sort and just as simple.<br><br>3. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>4.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>5. And so you can kind of immediately arrive at that performanceeven for simple clients.<br><br>6. Again, we exchange as long as the cardimmediately to the left is greater.<br><br>7. [cough] and that gives us immediately our code for the selectionsort implementation.<br><br>8. And those counts are going to notonly enable us to immediately implement the size function, just return the countat the root but also, they'll give us good implementations of rank and select.<br>
areas|sentence cnt : 1 <br> <br>1. Down atthe bottom is one of those important one is in image processing for understandinghow to label areas in images.<br>
unlock|sentence cnt : 2 <br> <br>1. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>2. They might unlockthe secrets of life in the universe, and they're good for fun and profit.<br>
theoretically|sentence cnt : 1 <br> <br>1. So it's theoretically possible, but themethods are generally too complex to be useful inpractice and their not used.<br>
trees|sentence cnt : 109 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>3. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>4. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>5. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>6. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>7. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>8. So the search is a natural generalizationof the search in, binary search trees.<br>
medium|sentence cnt : 6 <br> <br>1. But in the middle, when it's medium, it's questionable whether itpercolates or not.<br><br>2. I wanted to findthe top k or the medium or other order statistics so that's what selection is allabout.<br><br>3. So like if we wanted to find the minimum item that's k =zero or the maximum item that's k = n - one or the medium that's k = n/2.<br><br>4. Howwould we do that? Well, we just sort the array and then if we want to find thesmallest, we'll look at the first position or the largest, we'll look in the lastposition or the medium, we'll look in the middle.<br><br>5. It's going to beat even theclassical sophisticated methods for medium sized arrays.<br><br>6. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
culture|sentence cnt : 2 <br> <br>1.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br><br>2. But youreally know that your data structure and algorithm is used by a lot of people whenit appears in the popular culture.<br>
consists|sentence cnt : 3 <br> <br>1. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>2. So the idea is to keep a linked listwhich consists of nodes that have strings in them, and references,to the next item in the linked list.<br><br>3. And that's just a way to describethat we're going to be manipulating node objects that each consists ofa string and a reference to another node.<br>
deletion|sentence cnt : 14 <br> <br>1. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>2.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>3. That's Hibbard deletion.<br><br>4. Now, we want to talk about deletion andthen range search and range count.<br><br>5. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>6. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br><br>7. So, what they did in this implementation was theyjust put in regular Hibbard deletion in the binary search in the red-black BST.<br><br>8. So, people found deletion moredifficult.<br>
occurs|sentence cnt : 3 <br> <br>1. And so that one is going to reada sequence of strings from standard input and print out the one thatoccurs with highest frequency.<br><br>2. And then print out the word that occursthe most often, along with its frequency.<br><br>3. So,for example this is a rather complicated formula but not too bad but in a sensethat if you know that the i-th key, it occurs xi times you can write down a lowerbound for the number of comparisons that are going to be required in the worstcase.<br>
practical|sentence cnt : 32 <br> <br>1. These types of things ariseoften in practical applications.<br><br>2. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>3. The average case, which is extremelylikely for any practical application, is going to be about 1.<br><br>4. But for many practical applications, they're easy to implement and worth using.<br><br>5. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>6. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>7. And again, as we know,such an algorithm is not going to be practical, for huge numbers of linesegments.<br><br>8. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br>
outage|sentence cnt : 1 <br> <br>1. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br>
primary|sentence cnt : 2 <br> <br>1. So that's our two primary operations.<br><br>2. The way we do that is to takethe two primary operations, compares and exchangers that were that were, were usedto refer the data and encapsulate them just the static methods.<br>
analyze|sentence cnt : 7 <br> <br>1. In fact, that's what lead to [unknown] analyze the situation then comeup with a left-leaning variant.<br><br>2.If there's a two, a 3-node, it takes more compares than a 2-node,So, it's complicated to analyze.<br><br>3. So, we want to be sure to analyzeit in the simple case for stacks to set the stage formore complicated applications later on.<br><br>4. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br><br>5. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>6. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>7. So now we can analyze the performance ofthat so that we can provide clients with information on how well the algorithmdata structure will perform.<br>
slots|sentence cnt : 1 <br> <br>1. And we use the emptyslots in the array.<br>
measure|sentence cnt : 1 <br> <br>1. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br>
allows|sentence cnt : 13 <br> <br>1. The Java also allows remove().<br><br>2. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>3. And all of these things allow us to makebetter use of memory, allows the table to become nearly full.<br><br>4. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>5. So it has the infrastructure that allows us tobe used for all types of data types and all types of ordering so it's got a methodthat implements comparable then its got methods easy compare order.<br><br>6. There's all kinds of cases where we justhave a lot of information, maybe on our PC or all over the web, and we want to createan index that allows us to specify.<br><br>7. And that brings it down somewhat andallows us to keep the tables more full.<br><br>8. And then that allows us to processqueries, where we take a query, and then get the set of indicesassociated with that query.<br>
simplified|sentence cnt : 2 <br> <br>1. So say we have this simplified dateimplementation that we talk about before.<br><br>2. It's a simplified version of the Date class that's implemented withinJava just to show the idea of implementing Comparable.<br>
basis|sentence cnt : 11 <br> <br>1. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>2. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>3. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>4. You wouldn't work to use Shellsortas the basis for h-sorting because that always takes quadratic time no matter whatorder there is in the array.<br><br>5. And that method is the basis for the Graham Scan.<br><br>6. And itreally forms the basis for what we're going to do.<br><br>7. But that as the basis, we're able to solve the two dimensional line segmentintersection search using the sweep line algorithm.<br><br>8. So this code is thebasis for applying the sort, system sort method or any sort method for the Grahamscan for the convex hull that we did at the end of the last lecture.<br>
wrap|sentence cnt : 6 <br> <br>1. But, in linear probing, to insert what we do is when we put it inposition I if that's free, if not we just look at I plus one, and I plus two, andwrap around to the beginning if we reach the end.<br><br>2. And the same with the wrapper types like integer and double or color and lots of things.<br><br>3. If it's a primitive type,use the wrapper hashCode.<br><br>4. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br><br>5. And for primitive types takethe wrapper type and use the hash code.<br><br>6. So in order to handle generic types wehave to use Java's wrapper object types.<br>
collect|sentence cnt : 22 <br> <br>1. When does all the bins fill up? That's called the couponcollector problem.<br><br>2. As a warm up, let's suppose that wehave a string, a collection of stings.<br><br>3. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>4. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>5. And then what we can do, is just return that node's right link, then that old node, nobody's pointing to it, so it's available for garbage collection.<br><br>6. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br><br>7. Really often what we're doing is just inserting items into a collectionand then, later on, iterating through the items that we have.<br><br>8. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br>
appears|sentence cnt : 12 <br> <br>1. About half a million distinct ones andin that [COUGH] corpus, the word government appearsabout 25,000 times.<br><br>2. The word lamb appears both in Tom Sawyerand Aesop's Fables, and so forth.<br><br>3.And then these terms, every size appears twice.<br><br>4. And again the string is the key and thesets of integers are going to be the places in the arraywhere the given work appears.<br><br>5. The word majesty appears in three places,and there's, there's the context.<br><br>6. And that just means that it's well shuffled, that every possible way of shuffling the deck appears with equal probability.<br><br>7. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br><br>8. It'll say that the most frequent word,where there's no word that appears more frequently than it,which appears 10 times.<br>
thousands|sentence cnt : 1 <br> <br>1. So, maybe we can store millions or thousands of them.<br>
corresponded|sentence cnt : 1 <br> <br>1. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br>
without|sentence cnt : 16 <br> <br>1. And how close it could get to full withoutsacrificing performance.<br><br>2. So,without any extra special code we insert a node into an empty tree.<br><br>3. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>4. So, the lesson isthat we can develop good algorithms or good implementations without much code butthere are some out there that are still waiting discovery.<br><br>5.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>6. If you get allthe way through the array without that happening, then you say the array is true.<br><br>7. So without seeing all the details yo can understand that the same basic ideais going to work in this situation where we're dealing with much, much more memory.<br><br>8. If you try to do it without it, you're not going to besuccessful.<br>
literally|sentence cnt : 1 <br> <br>1. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br>
surprisingly|sentence cnt : 2 <br> <br>1.And, it's a extremely, simple algorithim, but surprisingly, complicated tounderstand, so we'll go slowly.<br><br>2. And, surprisingly binary search trees and these associatedalgorithms that we've looked at are going to provide very efficient solutions to anumber of important problems in this area.<br>
exam|sentence cnt : 173 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. Now, here's an example where we want to use theory as a guide.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>5. So, for example, this is a external, this is M = six.<br><br>6. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>7. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>8. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br>
implemented|sentence cnt : 19 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>3. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>4. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br><br>5. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br><br>6. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br><br>7. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>8. And the idea is that each of thesorts can be implemented with only a few exchanges given that the previous oneshappened.<br>
seen|sentence cnt : 14 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>3. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>4. So everything to the left of i is inascending order, everything to the right, we haven't seen it all yet.<br><br>5. You can sort from that heap and that's significance be,significant because it's the first sorting algorithm that we've seen that is both inplace.<br><br>6. Now that we've seen efficientimplementations of algorithms that can solve the unifying problem for hugeproblem instances let's look to see how that might be applied.<br><br>7. That's a summary of Quicksort, our bestsorting algorithm that we've seen to date.<br><br>8. You could do the items between i and minus one, the ones you haven't seen yet, and that would also work.<br>
somehow|sentence cnt : 5 <br> <br>1. Somehow we're going to want the valuebe any generic type at all but the key type we have to make somenatural assumptions about them.<br><br>2. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>3. And somehow algorithms take advantageof the ability to use null in this way.<br><br>4. So the challenge is to do the resizing,but somehow ensure that ithappens infrequently.<br><br>5. When you makean assumption you better be sure and you're depending on that assumption, youbetter be sure that it holds somehow.<br>
leaning|sentence cnt : 35 <br> <br>1. In fact, that's what lead to [unknown] analyze the situation then comeup with a left-leaning variant.<br><br>2. So, what we are going to do is use internalleft-leaning links to glue the three nodes together.<br><br>3. That's a legal left-leaning red-blacktree.<br><br>4. So this is, and actually the versionthat we're going to, looking at is called left-leaning red-black BSTs.<br><br>5. Now, we have athree node, but the red link is leaning right so we have to rotate.<br><br>6. So, H is a three node leaning the wrong way.<br><br>7. Well, it'sleft leaning and the process is a little bit different and sometimes the left pathcan get long but not that long.<br><br>8. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br>
temporarily|sentence cnt : 4 <br> <br>1. And then that makes that temporarily overful.<br><br>2. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br><br>3. Now, the color of the root in our code willtemporarily turn red and then we turn it black again.<br><br>4. And now, what we are going to do is take a look at just a couple of different scenarios that we violate that invariant temporarily, and then fix it.<br>
bell|sentence cnt : 1 <br> <br>1. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br>
minus|sentence cnt : 17 <br> <br>1. Now, it's key that the uniform random number be between zero and i minus one.<br><br>2. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br><br>3. Shell's original idea is to try powers to two minus one andthat works okay.<br><br>4. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>5. It gets the sorting job donewith just N minus 1 compares.<br><br>6. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br><br>7. You could do the items between i and minus one, the ones you haven't seen yet, and that would also work.<br><br>8.This sum, minus the same sum for N - one, just leaves the 2CN - one.<br>
axises|sentence cnt : 2 <br> <br>1. And,but the problem with that quick find algorithm is that, that would taketen^18th operations, or, say array axises or touching memory.<br><br>2. Costing involving in the ray axises justto do the find operation and that's going to be too slow if you have a lot ofoperations.<br>
cartoon|sentence cnt : 1 <br> <br>1. The cartoon on the right showsthat not all orders are necessarily total orders.<br>
false|sentence cnt : 9 <br> <br>1. So this isa static method that is supposed to return true if the array is sorted and false if it'snot.<br><br>2. If you have an itemthat's less than one before then it's not sorted you return false.<br><br>3. That returns true if the ported is sortedand false if it's not.<br><br>4. And [cough] otherwise if the color's red, we return true otherwisereturn false to test whether a node is red.<br><br>5. If they're not equal, it returns false.<br><br>6. The client is always going to betesting hasNext() as I showed as I showed and that stub code before and so when itgets to null it will return false in the iterational stop.<br><br>7. They're not connected, so we'd return false, inthat case, not connected.<br><br>8. hasNext() is supposed to if, if we're done is supposed to returnfalse.<br>
worry|sentence cnt : 16 <br> <br>1. Andthat's definitely something to worry about.<br><br>2. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>3. And then proceeding inthat way, moving bottom up or moving from right to left, the next thing we do is butthen worry about a three node heap that's heap ordered and we're fine.<br><br>4. So, this isn't just an example about software security, there's a lot of difficult and deep issues to worry about in software security, and we're not going to worry about all of them.<br><br>5. But we do have to worry in Javaabout a problem called Loitering and that is the idea that we havereferences to an object in our array implementation in the stackarray when we're not really using it.<br><br>6. There's this one wild loop that we have to worryabout a little bit.<br><br>7. Now for a position K, then what we need to worry about is the nodes at 2k and 2k plus one.<br><br>8. We don't haveany, any equal lines that we have to worry about whether we consider rectangles thattouch to be intersecting, and so forth.<br>
intended|sentence cnt : 1 <br> <br>1.sort and it's intended to be ageneral purpose sorting method for use by Java programmers.<br>
conquer|sentence cnt : 2 <br> <br>1. It's called divide and conquer.<br><br>2. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br>
computation|sentence cnt : 38 <br> <br>1. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br><br>2. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>3.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>4.So [cough] this is if we implement a point data type for computational geometry, youcan have a method ccw() that just with this little math calculation (b.<br><br>5. So,that's a, a really 1d range count is a very easy computation to perform in, inlog time with a binary search tree.<br><br>6. Going from a to b you turn left to get to c in the first case and you goright to get to c in the second case and we want to do a computation thatdistinguishes this.<br><br>7.Because if we have a computational process that takes quadratic time, then it's notgoing to scale, we're not going to be able to do large number of particles.<br><br>8. If you have the convex hull, this computation is easy.<br>
redundant|sentence cnt : 3 <br> <br>1. And that's a redundant connection.<br><br>2.Why is it redundant? Well, the partitioning element is sittingthere and it'll stop when it hits the partitioning element.<br><br>3. And I, actually, in our implementation thetest of the J pointer running off the left end is redundant.<br>
pairs|sentence cnt : 9 <br> <br>1. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>2. And then a series of pairs of object names.<br><br>3. So we're going to have nodes in the linkedlist that have key value pairs.<br><br>4. Now, it's essential that the array size is greaterthan the number of key value pairs N.<br><br>5. So, a one-dimensional justmeans we have one key, so we'll insert a key value pairs before and what we want todo is to be able to search for a key, and a value associated with it, want to b eable to delete.<br><br>6. And then,we'll do the same thing for all pairs of particles.<br><br>7.The first one is that you have t o check all pairs of balls for overlap so that'squadratic, so it's going to be really, really lot of overall texture you're notgoing to be able to do it for a huge, huge value of N.<br><br>8.If our symbol table is really going to be dynamic, we need to be able to delete key value pairs from the table.<br>
skinny|sentence cnt : 1 <br> <br>1. You could wind up with a long skinny tree.<br>
wrote|sentence cnt : 7 <br> <br>1. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>2. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>3. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>4. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br><br>5. If you have a sort method that can store anyvalues in an array, it could, for example, store zeros in every array entry thatmethod would pass this test, but it didn't really correctly sort the array becauseoverwrote all the values.<br><br>6. Don Knuth who wrote several books on, on algorithmsand was a pioneer in the field said that, "An algorithm must be seen to bebelieved.<br><br>7. Knuth when he wrote his books in the 60s proposed the incrementsequence 3x + 1.<br>
anoth|sentence cnt : 95 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>3. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>4.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>5. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>6. And all it does is divides by 2 again andthen throws out another 1.<br><br>7. And then another thing that you mightwant to do is iterate through all the keys in the table.<br><br>8. Then on another pass through, we can takethe E, M and the G, R and merge them together to make EGMR, and the E, S and theO, R merge those together to make EORS, and so forth.<br>
colleague|sentence cnt : 1 <br> <br>1. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br>
misspelled|sentence cnt : 1 <br> <br>1. For example, you might have a spellchecker where you want to identifymisspelled words.<br>
indices|sentence cnt : 10 <br> <br>1. The array representation, all we do is we put, we start with indices at 1.<br><br>2. Optimal representation of the data and only a little arithmetic with array indices.<br><br>3. So we don't need explicit links at all to represent these data structures, we can just use array indices.<br><br>4. And then that allows us to processqueries, where we take a query, and then get the set of indicesassociated with that query.<br><br>5. The way that we move around the tree is by doing arithmetic on the indices.<br><br>6. We have onestudent who was paying attention to what we're saying and uses an array and canpick the indices into that array at random check whether they're open and, andrepeat.<br><br>7. So,but we can take care of that in the less and exchange methods by just decrementingthe indices in those methods to have it work as if the array were zero through n.<br><br>8. The other thing is as I just mentioned, you can use the array indices to move through the tree.<br>
collections|sentence cnt : 6 <br> <br>1. The idea is that in many applications,we have collections of objects that we want to maintain andthe operations are very simple.<br><br>2. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>3. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>4. Then test isEmpty() and we also sometimes have extra method that justgives us the value of the largest key and also size which is useful sometimes incollections.<br><br>5. So at aweek or so ago, we looked at collections in Java and the idea of elementary datastructures where we insert and delete items.<br><br>6. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br>
contain|sentence cnt : 56 <br> <br>1. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>2. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>3. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>4. Nine and four, So now four is the root of the tree containing four is eight.<br><br>5. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>6. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>7. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>8. And then process all the points, and make a list of points thatare contained in each square.<br>
walls|sentence cnt : 5 <br> <br>1. And then these tests are for whether it hits the walls in which case, you haveto flip the x or y velocity.<br><br>2. And then the onlyto move [cough] operation does is to update the position of the ball by thevelocity, which is just another number and then it does the bouncing off the walls.<br><br>3. And then we, what we have to do is for those two particles is gothrough and predict the future collisions with any walls and collisions with anyother particles.<br><br>4. So,we're going to have moving particles that either collide with each other and withthe walls.<br><br>5. Okay, so that's the procedures that weneed and then they're similar ones for the horizontal and vertical walls.<br>
follows|sentence cnt : 2 <br> <br>1. So this is a dynamic data structure that kind offollows the same rule as binary search.<br><br>2. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br>
famous|sentence cnt : 8 <br> <br>1. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>2.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br><br>3.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br><br>4. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br><br>5. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br><br>6. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>7. A famous quote and there's many similar quotes, 'The generation of random numbers is too important to be left to chance'.<br><br>8. And then this isanother famous physics experiment showing diffusion.<br>
magna|sentence cnt : 1 <br> <br>1. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br>
says|sentence cnt : 34 <br> <br>1. It says thatindex one has got 0.<br><br>2. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>3. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>4. How do we, we do not implementing the API? The API says we should justbe able to create a stack and it should be able to grow andshrink to any size.<br><br>5. And so all that says is thatall the objects are independent.<br><br>6. And then wecome off a null link, and all that says is that there's no place in this tree where Gcould be so G is not there.<br><br>7. And then,also we're going to put as the first thing that happened always a, an event that saysredraw everything.<br><br>8. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br>
generalized|sentence cnt : 1 <br> <br>1. Sothe, search is, you know, just the same as we've been doing, just generalized.<br>
advertising|sentence cnt : 1 <br> <br>1. You might want to make sure that if you're advertising that you're doing a random shuffle, then you go ahead and do so.<br>
gravity|sentence cnt : 2 <br> <br>1. It gets more complicated ifthere's more forces, like gravity involved.<br><br>2. In particular, just as another example,consider the idea of N-body simulation, which isa classic problem in physics where you've got N particlesmutually affected by gravity.<br>
floating|sentence cnt : 1 <br> <br>1. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br>
interchange|sentence cnt : 2 <br> <br>1. So, what are the tradeoffs between usinga resizing array versus a linked list? Those are two differentimplementations of the same API, and the client can usethem interchangeably.<br><br>2. Now, the keys and the values caninterchange roles that's why we have the abstruction to separate them.<br>
reaching|sentence cnt : 4 <br> <br>1. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br><br>2. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>3. So, that's one importantreason to study algorithms, their impact is broad and far-reaching.<br><br>4. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br>
evidence|sentence cnt : 1 <br> <br>1. It's going thewrong way and essentially what this means is a point 4 is evidence that point,there is no way the point 3 can be on the convex hull.<br>
sink|sentence cnt : 8 <br> <br>1. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>2. Now, that element which went from the bottom to the top is most likely going to violate the heap order, it's going to be smaller than one or its both of its children, so we do a sink.<br><br>3. We have the swim and sink functions that we showed earlier.<br><br>4. So that's an implementation of the delete max operation for heap using a sink, where a key value decreases, goes down in the heap.<br><br>5. So now we invoke the sink where we exchange that node with the larger of its two children until we find a place where it's larger than both of those children.<br><br>6. N times, we're doing a sink operation, andthe size of the heap is at most lg N so it's N lg N.<br><br>7. Or sink and swim methods are good for making this happen, but we'll delay these implementations until we need them in a more complicated algorithm.<br><br>8. So given the sink implementation, we had donea one liner for the first pass and a three liner for the second pass so that gives acomplete implementation of heap sort with the code that we have given so for, sofar.<br>
parameters|sentence cnt : 2 <br> <br>1. And those are typical parameters.<br><br>2. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br>
instead|sentence cnt : 27 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2. Now instead of the initialization always takes timeproportional to N.<br><br>3. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>4. Instead, what we want to do is called an event driven simulation.<br><br>5. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>6. So in the first case, it's much, much faster than selection sort,linear instead of quadratic.<br><br>7. When we insert, we're going to add the item at the endof the list instead of at the beginning.<br><br>8. So how are we'regoing to represent binary search trees in Java? Well, we're going to extend ourimplementations of linked list structures to have two references instead of justone.<br>
ignoring|sentence cnt : 1 <br> <br>1. It seems strange to be ignoring parenthesis and we'll getback to that in a second.<br>
absolute|sentence cnt : 6 <br> <br>1. But even if you take the absolute value.<br><br>2. You really have to takethe absolute value.<br><br>3. And this is absolutely a fine methodthat is not that difficult to implement, in the case that the pointsare evenly distributed.<br><br>4. And also no object is equal to null, so those are absolute requirements for Java.<br><br>5. We're having a efficient sortas absolutely crucial.<br><br>6. Well, sorry, you have to take the absolutevalue because otherwise it'd be negative and you can't have it negative.<br>
squares|sentence cnt : 9 <br> <br>1. We can use a two-dimensional arrayto directly index relevant squares.<br><br>2. And then range search is only findthe squares that intersect the query and process the points in that square.<br><br>3. It's got 13,000 points, but if you tryto use the grid implementation for this you find that halfthe squares would be empty and half the points are injust 10% of the squares.<br><br>4. So what we want to choose is this squaresize that would best balance these two needs.<br><br>5. So, and I will pick a parameter M and divide space intoan M-by-M grid of squares.<br><br>6. So the system at the left, you can find a way to get fromthe top to the bottom through white squares, but the system to the right doesnot percolate, there's no way to get from the top to the bottom through whitesquares.<br><br>7. So let's think of an n by n grid of squares that we call sites.<br><br>8. Well one easy way to doit is to just think about dividing space into a grid of squares.<br>
hypotheses|sentence cnt : 1 <br> <br>1. It wasdifficult to create solutions, to be able to test hypotheses against naturalphenomenon.<br>
means|sentence cnt : 52 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. Sosweeping from left to right means we consider each x coordinate as an event.<br><br>3.left? So, that means H is h.<br><br>4. So, that means that you could touch everything in the main memory inabout a second.<br><br>5. So in this case, we'll change the, connect three and four means that weneed to change the four to a three.<br><br>6. Sothat, that means you'd have, if you did exactly and [inaudible] + n/2 + n/4 and soforth which adds up to about two N compare so linear cross.<br><br>7. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br><br>8. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br>
scope|sentence cnt : 7 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. So now, this is a recurrence thattelescopes.<br><br>3.Substitute the previous equation telescope.<br><br>4. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>5. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br><br>6. The proof for this fact is quite beyond thescope of this course but it's still an important fact.<br><br>7. So analysis of 2d trees isa bit beyond our scope.<br>
greatest|sentence cnt : 1 <br> <br>1. So, this is so when we have the GCD function, computing thegreatest common denominator, greatest common denominator p and q is greatestcommon denominator of q and p mod q and it just calls itself until q gets to be zero.<br>
scheme|sentence cnt : 1 <br> <br>1. So that's a straightforward and simple scheme for implementing symboltables with hashing.<br>
comparator|sentence cnt : 21 <br> <br>1. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>2. The idea is that you create acomparator object and then pass that as a second argument to Java's sort routine andwe can do the same thing for our sorts.<br><br>3. And this code is straight forward way to implement comparators that you canuse as a model.<br><br>4. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>5. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br><br>6.Or, did we use comparators anywhere here? In, this Index will tell us no.<br><br>7. But otherwise, usually it's a CCW call in this code which again Iwon't go through in detail as an implementation of a comparator for two Dpoints.<br><br>8. With comparators, we can do that outside of thedata type even at some later time.<br>
represented|sentence cnt : 6 <br> <br>1. The thing is remember represented in array one two three and so forth.<br><br>2. So that's a basic implementation of priority queues using the heap data structure represented as an array.<br><br>3. And maybe the way the keys are represented.<br><br>4. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>5. So that's complete binary trees represented in array with keys in the nodes, satisfying heap order property.<br><br>6. So if we go left and then left, thatmeans all the points to the left of 1 and above 3, so the square in the upper leftis represented by that node in the tree.<br>
dick|sentence cnt : 3 <br> <br>1. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br><br>2. The word whale is only in, Moby Dick.<br><br>3. So for this small data from the beginningof Dickens' Tale of Two Cities, if we run a FrequencyCounter,the FrequencyCounter client.<br>
reasons|sentence cnt : 8 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. There's many other reasons that people use immutable data types.<br><br>3. So, here's a bunch of reasons that I justwent through for studying algorithms.<br><br>4. And the idea is we're going to use Insertion Sortbecause of two reasons based on our understanding of how Insertion Sort works.<br><br>5. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br><br>6. In fact,a pr ogrammer might ask, why study anything else? Well, there's plenty ofgood reasons to study other things, but I'll submit there's no good reason not tostudy algorithims.<br><br>7. Now in practice Heapsort isactually not used that much for a couple of reasons.<br><br>8. This is for two reasons, one is we canget more efficient implementations if we can use the ordering of the keys to helpus find our way around the data structure.<br>
capacities|sentence cnt : 1 <br> <br>1. The client might have a lot of stacks thatneed to be maintained simultaneously and maybe they reached their maximumcapacities at different times and various other things.<br>
taking|sentence cnt : 15 <br> <br>1. But also taking care of specialcases when the queue is empty.<br><br>2. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br><br>3. Andthis was taking a look at the Qsort that a user found was broken and, and now, thismethod is incorporated into some plenty of system sorts.<br><br>4. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>5. [COUGH] The method that we're going to use isbased on taking an auxiliary array to hold thedata.<br><br>6.And it's definitely worthwhile taking implementing for a Quicksort.<br><br>7. And then, what the priority queue tells us is - let's organize it in some ways that we are always taking the best one to processnext.<br><br>8. And as you watch it go for a while, you can see that this thing about going to the right and taking the successor all the time, the trees becoming much less balanced that it was.<br>
once|sentence cnt : 46 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>3. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>4. Then once we've exchangedit, again, we preserved our invariant.<br><br>5. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>6. Once it's read in we get to read all of the page for free pretty much.<br><br>7. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>8. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br>
card|sentence cnt : 18 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. Now with i equals two, i pointing to the second card, we generate a random integer between zero and i.<br><br>3. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>4. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>5. Again, we exchange as long as the cardimmediately to the left is greater.<br><br>6. Let's look at how that workson our example with cards.<br><br>7. So, now we start by initializingi at the first card, and we take the idea that everything from ito its left is going to be sorted, and everything from the right we'renot going to look at at all.<br><br>8. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br>
ated|sentence cnt : 130 <br> <br>1.Delete code is a bit more complicated but it's on the book side and in the book.<br><br>2. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>3. It's just complicated code to understand.<br><br>4.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>5. And if it does, print the value associated with the key.<br><br>6. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>7. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>8. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br>
bases|sentence cnt : 6 <br> <br>1.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>2. And this is a very common operation, say, in databases.<br><br>3. And even if it's not points in the plane,just databases.<br><br>4. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>5. In mostdatabases, nowadays that, that you might use.<br><br>6. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br>
higher|sentence cnt : 11 <br> <br>1. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>2. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>3. Some of them very mathematical, that extend thehigher dimensions.<br><br>4. And so when we insert a new node L say in this tree we go down that path, wecreate a new node and then return the link to that node higher up.<br><br>5. We flipped the colorsand now our temporary 4-node is up higher in the tree but it's not balanced so weare going to have to do two rotations to make that balanced.<br><br>6. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>7.If it's partially sorted it doesn't make much difference - does the higher sorts alittle bit faster.<br><br>8. And then we'll pass the s plit up causing asplit up higher so the red keys in the internal nodes are copies of keys downbelow that direct the search.<br>
although|sentence cnt : 3 <br> <br>1. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>2. Although it's aninteresting programming exercise that a lot of us would get wrong the first time.<br><br>3. That's pretty helpful although not, nottotally helpful but there's a lot of situations wherethat's helpful.<br>
contained|sentence cnt : 2 <br> <br>1. And then process all the points, and make a list of points thatare contained in each square.<br><br>2. All right, so we're going to try to findall the points that are contained in that green query rectangle.<br>
officially|sentence cnt : 2 <br> <br>1. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>2. So, that's our problem, to be ableto officially support these two commands for given set of objects.<br>
dictionary|sentence cnt : 6 <br> <br>1. And it's very typical for keys to comefrom an ordered set, for example, in the dictionary application.<br><br>2. And in yourexceptional list would be words that are in the dictionary.<br><br>3. And you'd want to printout all the words that are not in the dictionary.<br><br>4. So, a very smallamount of code based on a symbol table implementation that gives us thedictionary functionality.<br><br>5. You can think of it intuitivelyas like a dictionary.<br><br>6.Now, let's look at a dictionary client,another very useful and common application of symbol tables.<br>
outperform|sentence cnt : 1 <br> <br>1. The cost of computing the hash function can mean that something like redblack trees will even outperform hashing even for just searching and insert.<br>
throwing|sentence cnt : 1 <br> <br>1.And continue that way throwing out two over decreasing numbers all the way downuntil we get down to two elements, c1 which is zero.<br>
dependent|sentence cnt : 5 <br> <br>1. And so all that says is thatall the objects are independent.<br><br>2. So, those are independent symbol table objects.<br><br>3. InQuicksort partitioning, after the random shuffling we have the partitioning elementand then we process everybody to the left independently of everybody to the right.<br><br>4. Again, dependent on the random shuffling,is going to be logarithmic.<br><br>5. If it's 9/10's full one over one minus alphasquared is 100 one over 100, so it means it's going to be 50 p robes for a searchmiss if it's 9/10's full, and that's independent of N and M, whereas if it'shalf full then we get the nice.<br>
relates|sentence cnt : 2 <br> <br>1. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>2. In this example or CSV file relates URLs to IP addresses.<br>
belong|sentence cnt : 2 <br> <br>1. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>2. And for insert, you just take (x,y),figure out which square it belongs to.<br>
exchangers|sentence cnt : 1 <br> <br>1. The way we do that is to takethe two primary operations, compares and exchangers that were that were, were usedto refer the data and encapsulate them just the static methods.<br>
stages|sentence cnt : 1 <br> <br>1. And how many stages do we have here? Well, it's the number of times you divideN by 2 to get down to 2.<br>
chain|sentence cnt : 11 <br> <br>1. And so the first way we'll look at is called Separate Chainingand it's a very diagonal idea back1953, and the idea is just build a link list foreach of the table positions.<br><br>2.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>3. That's our first collision resolution method, hashing with separatechaining.<br><br>4. So, you can't make Mtoo large, you have too much space and you'll have empty chains or short chains.<br><br>5. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>6. So we'll look at hash functions,separate chaining and then two collision resolution methods called separatechaining and linear probing.<br><br>7. You have, these clusters or these chains building.<br><br>8. In, in that case, thenthe expected length of the longest chain will be lg, lg N which is quite animprovement.<br>
brackets|sentence cnt : 2 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2.And at the top, the class declaration we declared an angle brackets that item isthe generic type that we're going to use.<br>
simulate|sentence cnt : 5 <br> <br>1. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>2. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>3. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br><br>4. So, more and more and more now a days people are developing computationalmodels, where they attempt to simulate what might be happening in nature in orderto try to better understand it.<br><br>5. So life can be complicating when you try to simulate the naturalworld.<br>
reinsert|sentence cnt : 2 <br> <br>1. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>2. If occupied you, youreinsert the displaced key into its alternative.<br>
unfortunately|sentence cnt : 5 <br> <br>1. So now we're going to have tolook at can this code be effective for large problems? Well unfortunatelyQuick-union is faster but it's also too slow.<br><br>2. Unfortunately, it's usually the case in geometric data that the pointsare not evenly distributed.<br><br>3. Unfortunately, Java does not allowgeneric array creation.<br><br>4. Now but one problem is if the keys come in and, and reallyunfortunately, if they come in, in a natural order.<br><br>5. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br>
apple|sentence cnt : 3 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2. And then, it's up to the client when it pops something off theapple stacks to cast at the apple to keep the type checking system happy.<br><br>3. So, in this example we have two types with two stacks one of apples andone of oranges.<br>
strung|sentence cnt : 1 <br> <br>1. A regular binary search tree will just be all strung out in a single lineand wouldn't have quadratic time for this input but a left-leaning red-black treeactually when, whenever it becomes a power of two is completely balanced as you cansee from this example.<br>
majesty|sentence cnt : 1 <br> <br>1. The word majesty appears in three places,and there's, there's the context.<br>
calculate|sentence cnt : 2 <br> <br>1. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>2.Now, once we can calculate these roots, then we can implement the find operationjust by checking whether the two items that we're supposed to check with areconnective where they have the same root.<br>
tickets|sentence cnt : 4 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. So that's the cut off point for, selling,seven tickets that's the cut off point.<br><br>3. So thisone is, I've only got ten tickets to sell.<br><br>4. I'm not going tosell tickets to anyone that came after that time.<br>
spaces|sentence cnt : 2 <br> <br>1. And he was able to show, and we'll talk just a little bitabout this, that if, there's, only half of the parking spaces are occupied, then, onaverage, half the people find, find it after one place and the other half have tolook one extra.<br><br>2. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br>
ranks|sentence cnt : 3 <br> <br>1. We started with one dimensionalrange search and just used regular binary search tree to compute ranks to get theanswer.<br><br>2. The [cough] number of nodes examined when wedo a search is the length of the search path to low plus the length of the searchpath to high to [cough] find their ranks and that's going to be time proportionalto log N.<br><br>3. It's actually just thedifference between the ranks plus one if the high [cough] entry in the range queryis in the table and not +one over.<br>
resource|sentence cnt : 4 <br> <br>1. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>2. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>3. But there's aproblem so you would think that the system sort would be completely solid with allthis resource with all these research and all of the development that's going intoit.<br><br>4. [cough] So, for this course we have two resources that I wantto talk about and make sure that people are familiar with before entering into thecontent.<br>
experimentation|sentence cnt : 2 <br> <br>1. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br><br>2.And also, it allows us to develop a math model that we can go ahead and validatewith experimentation.<br>
stfi|sentence cnt : 2 <br> <br>1. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>2. Now,replace STFI with a new node that links to the old STFI.<br>
ideally|sentence cnt : 1 <br> <br>1. Now, what we seek ideallyis what's called an optimal algorithm where we prove that the upper bound andthe lower bound are the same.<br>
struck|sentence cnt : 2 <br> <br>1. It's actually going to be quadratic in the worst case but again, thechance of that it will happen with a random shuffle is less than the chancethat we'll be struck by lightning.<br><br>2.Or your computer will be struck by a lightning bolt.<br>
problems|sentence cnt : 41 <br> <br>1.We think that one is bad news, we don't use it can lead to insidious debug, bugdebugging problems.<br><br>2. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>3. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>4. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br><br>5.All right so QuickFind is too slow forhuge problems.<br><br>6. So now we're going to have tolook at can this code be effective for large problems? Well unfortunatelyQuick-union is faster but it's also too slow.<br><br>7. But simply can'tsupport a huge dynamic connectivity problems.<br><br>8. So you can run a Mergesort on hugeproblems.<br>
apposition|sentence cnt : 1 <br> <br>1. In this case, the value apposition two has changed to H for whatever reason, in that smaller, in this case then both its children.<br>
stream|sentence cnt : 8 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>3. Nowhow we are going implement or solve this problem or you can think of lots of waysto go ahead and solve this problem of finding the largest M items in the streamof N items.<br><br>4. So and this is just some test datawhere we've got all, all these transactions and so we are going to beable to take in data like this and again an unbounded stream of data.<br><br>5. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br><br>6.So, even with this huge stream of items coming through, we're only keeping trackof the M largest items and that's a fine canonical client for priority queue.<br><br>7. And [COUGH] for each file we're going tocreate an input stream.<br><br>8.Reading all the strings on an input stream, on standard input,and, splitting em by blank space and putting em into array, sonow all the words, are, in the an array.<br>
articulating|sentence cnt : 1 <br> <br>1. And these things are not difficult but they're all worth articulating asseparate issues that we have to deal with in order to get an effectivesingle table implementation.<br>
finds|sentence cnt : 3 <br> <br>1. We have an inter-for loop that for j, if it finds asmaller one, resets min and then once we've looked at all the elements to theright of i we exchange the smallest one with i.<br><br>2. No intersection in the left means no intersections at all, sothose two cases is enough to show that this algebroid finds an intersection, ifthere is one.<br><br>3. [cough] Youcan see our pointer moving from right to left every time it finds the smallestelement to the right, it exchanges it into position.<br>
eights|sentence cnt : 2 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br>
length|sentence cnt : 21 <br> <br>1. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>2. And all it does is just go through the array from the one to the length ofthe array and test if each item is less than the one before.<br><br>3. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>4. In all possible ways, andyou can get two to the N strings, for any N of length to N that all hash to the samevalue.<br><br>5.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>6. If we have a full stack,which we know by testing N, which is the number of items inthe stack versus the array length, then we just resize the array into one of twicethe length before inserting the item.<br><br>7. The 4-node had four links, and the two2-nodes have four lengths, so nothing has to be changed below.<br><br>8. And so the average list length is short, this islike what we encountered with hashing.<br>
balls|sentence cnt : 18 <br> <br>1.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>2. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br><br>3.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>4. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>5. And we have some number of balls,however many keys we have.<br><br>6. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>7.And what about the analysis? Well, again this the [cough] standard probabilisticanalysis of the balls and bins problem tells us a lot of information of what goeson.<br><br>8. The Physics problem is exactly what happenswhen two balls hit and they bounce off each other according to somewell-understood physical process, and that's the high school Physics.<br>
heep|sentence cnt : 1 <br> <br>1. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br>
preserved|sentence cnt : 2 <br> <br>1. Then once we've exchangedit, again, we preserved our invariant.<br><br>2. If the client could change the values, how do we know that the heap order operation is preserved? If we want the client to be able to change the values, we're going to provide methods for that purpose as I just mentioned.<br>
unless|sentence cnt : 3 <br> <br>1. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>2. And what assert will do is it will throwan exception unless that condition is true.<br><br>3. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br>
proposition|sentence cnt : 9 <br> <br>1. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>2. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>3. So, That's a, quick sketch of the proof of this proposition.<br><br>4. And the way to prove this proposition isto from examining the code, to write down what'scalled a recurrence relation.<br><br>5. Now, what's interesting aboutthis proposition about selection sort is that, it doesn't matter what order theinput is.<br><br>6. And again, you can get a feeling for where the proposition comes fromby looking at this N by N trace.<br><br>7. So, the lower bound as a proposition, that uses the decision treelike that to prove that any compare base sorting algorithm has to use at least logbase two (N) factorial compares in the worst case.<br><br>8. Andjust looking at this trace of selection sort and operation really is a proof,visual proof of this proposition.<br>
picture|sentence cnt : 1 <br> <br>1.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br>
generalize|sentence cnt : 9 <br> <br>1. And that one generalizes to help us insert into a two node at thebottom.<br><br>2. Sothe, search is, you know, just the same as we've been doing, just generalized.<br><br>3. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>4. It generalizes thestack and the queue and gives us a data structure that we can use to effectivelydesign algorithm of all sorts.<br><br>5. So, the 2-3 tree is a way to generalizeBSTs to provide the flexibility that we need to guarantee fast performance.<br><br>6. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>7. Today, we're going to lookat Priority Queues which is a variant of sorting that generalizes the idea toprovide more flexible data structure that we can use for all sorts of applications.<br><br>8. And the reason we do this is that it generalizes to giveus more efficient data structures later on.<br>
books|sentence cnt : 6 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. You can go to books, the book site to see thelecture slides.<br><br>3. So it was more complicated and involved a lot more cases and sousually not all the cases were put in the text books.<br><br>4. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>5. Don Knuth who wrote several books on, on algorithmsand was a pioneer in the field said that, "An algorithm must be seen to bebelieved.<br><br>6. Knuth when he wrote his books in the 60s proposed the incrementsequence 3x + 1.<br>
type|sentence cnt : 140 <br> <br>1. These types of things ariseoften in practical applications.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. The first part is data typesorting and searching.<br><br>4. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>5. So that's three different clients, three completelydifferent types of data.<br><br>6. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>7. We encapsulate them in basicdata types like these.<br><br>8. That is easy for some types of data but it can get complicated formore complicated types of data.<br>
encounter|sentence cnt : 6 <br> <br>1. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>2. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>3. And so the average list length is short, this islike what we encountered with hashing.<br><br>4. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>5. But the delete operation for Binary Search Trees shows us the kind of complexity that we can encounter with working with these kinds of data structures.<br><br>6. Those are some of the situations that we encounter whendeveloping a system sort.<br>
stride|sentence cnt : 2 <br> <br>1. Now, because it's 7-sortedand a 3-sort elements are either already in placed or on a go back a fewstrides.<br><br>2. Use another hatch function todetermine the stride that we're going to use.<br>
typical|sentence cnt : 25 <br> <br>1. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>2. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>3. But for typical data, it's very efficient.<br><br>4. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>5. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>6.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>7. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>8. And it's very typical for keys to comefrom an ordered set, for example, in the dictionary application.<br>
expressions|sentence cnt : 2 <br> <br>1. So the goal is, you got an arithmetic expression this is justactually like a simple stand in for a program and we'll talk about that in asecond but let's say, arithmetic expressions.<br><br>2. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br>
negative|sentence cnt : 3 <br> <br>1. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br><br>2. Well, sorry, you have to take the absolutevalue because otherwise it'd be negative and you can't have it negative.<br><br>3. Now, sinse the hash code can be negative,this doesn't quite work the way this arithmetic implement and Java,because it's one in a billion times.<br>
animate|sentence cnt : 1 <br> <br>1. So now we can animate and againMergesort's more efficient, so we can do more and moreitems.<br>
types|sentence cnt : 63 <br> <br>1. These types of things ariseoften in practical applications.<br><br>2. The first part is data typesorting and searching.<br><br>3. So that's three different clients, three completelydifferent types of data.<br><br>4. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>5. We encapsulate them in basicdata types like these.<br><br>6. That is easy for some types of data but it can get complicated formore complicated types of data.<br><br>7. So howare we going to implement stacks and queues for that types of data.<br><br>8. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br>
implementating|sentence cnt : 1 <br> <br>1. Now next we'll look at thecode for implementating that.<br>
merging|sentence cnt : 6 <br> <br>1. But otherwise, that's a fine method for merging.<br><br>2.Alright, so here's the code for merging, which is quitestraightforward from the demo.<br><br>3. So, as you can see in this examplewe start out by merging the first two sub arrays of size one to make a array of sizetwo - E, M - that's sorted, and then do the same thing for the next two elements and thenext two and so forth until eventually instead of sixteen individual elements wehave eight sorted subarrays of size two.<br><br>4. That's another one like merging in place, that you'd think there ought to be an easy way to do it, but in 50 years, no one's really discovered one.<br><br>5. So the idea of Mergesort is, is based onthe idea of merging.<br><br>6. And so to understand how merging workswe'll think about the idea of an abstract inplace merge.<br>
precept|sentence cnt : 1 <br> <br>1. So here's still another example where we might use for aclass list, which has the person's year of graduation, last name, first name preceptname and login name.<br>
about|sentence cnt : 257 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2. So to insert N items,it's about three array accesses.<br><br>3. And you can think about the implications of that.<br><br>4. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>5. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>6. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>7. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>8. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br>
having|sentence cnt : 14 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br><br>3. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>4.And again, a good algorithm is much better than having a super computer.<br><br>5. And so client programs andsystem programs on the Java system were having terrible performance on theirsymbol table because of the shortcut in hashing.<br><br>6. The idea is to when implementing the quick union algorithmtake steps to avoid having tall trees.<br><br>7. If the client happens to dopush-pop-push-pop alternating when the array is full, then it's going tobe doubling, having, doubling, having, doubling, having.<br><br>8. So now the best way having looked at those small examples, thebest way to understand this code is recursively.<br>
equivalent|sentence cnt : 6 <br> <br>1. If we get to the bottom and our current nodeis null and that's falling off the bottom of the tree we return null and that'sequivalent to saying our buyer convention that, that key is not in our datastructure, or not in our symbol table.<br><br>2. So Lets suppose that there is no intersect, and that'sequivalent to saying, if there is no intersection in the left then there is nointersection in the right.<br><br>3. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>4. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br><br>5. [cough] There's a lot ofequivalent definitions of this.<br><br>6. That's equivalent to saying, are they inthe same connective component? So that's some work, going to find the roots of eachitem but the union operation is very easy.<br>
levels|sentence cnt : 4 <br> <br>1. At the even levels, we think ofa vertical line, and the left sub-tree is all the points to the left and the rightsub-tree is all the points to the right.<br><br>2. So there might be a few nodes on the bottom level and one level lower than the bottom level, but otherwise all the levels are full.<br><br>3. Here's an example of one that goes one, two, three, four levels at least.<br><br>4. On odd levels we use a horizontal line andthe left sub-tree is all points below and the right sub-tree is all points above.<br>
operators|sentence cnt : 3 <br> <br>1. We have operands andoperators and you want to evaluate it.<br><br>2. Put the value on to the value stack and finally, the lastright parenthesis, take the two operators of the value stack, operators of the valuestack, and operator of the operator stack, perform the operation, put the result backon the value stack.<br><br>3. And you can go ahead and extend thisalgorithm to add functions like logs and sines or other operators and haveprecedence among operators, have them associate and multiple operations, and soforth.<br>
grey|sentence cnt : 2 <br> <br>1. This is just anothertrace without the data-structure shown, to just show in our standard way, theelements in black and red are the ones that are touched and the elements in greyare the ones that are not touched at all.<br><br>2. And if it's equal we don't even have to test that,that's why it's in grey.<br>
plot|sentence cnt : 1 <br> <br>1. This plot is another way of looking at it, which is the number of array accessestaken as you implement push operations.<br>
phone|sentence cnt : 5 <br> <br>1. Maybe there's a class number, there is a grade, there's a phone numbermaybe an address so we refer to an item and it has a record or the informationthat we're going to sort.<br><br>2. And it's not equally likely that each phone number has the samefirst three digits.<br><br>3. So for example, let's supposethat our keys are phone numbers.<br><br>4. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br><br>5. Probably a bad idea to use the first threedigits of the phone number as a hash function because so many phonenumbers will have the same area code.<br>
mistake|sentence cnt : 4 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2. So the mistake happens if we put all the items equal to thepartitioning item on one side which is a natural way to implement it and theconsequence is if you have all the keys equal, then partitioning doesn't really doanything.<br><br>3.Now there are some things that you have to watch out for with Quicksort because theimplementation is a bit fragile and it's easy to make mistakes.<br><br>4. The mistake we might make is to put ID of P here rather than first pickingout, that value.<br>
frequent|sentence cnt : 3 <br> <br>1. So the challenge is to do the resizing,but somehow ensure that ithappens infrequently.<br><br>2. It'll say that the most frequent word,where there's no word that appears more frequently than it,which appears 10 times.<br><br>3. So, during this course you'll be referring tothe book site frequently while working online.<br>
wiring|sentence cnt : 1 <br> <br>1. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br>
loop|sentence cnt : 35 <br> <br>1. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>2. And so what the test client'sgoing to do is going to just go in the loop as long asstandard in is not empty.<br><br>3. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>4. Actually less code thanfor Quick Find, no fore loops.<br><br>5. So, this value loop just builds thesymbol table from the file.<br><br>6. There's no loops.<br><br>7. Then wehave a for loop that goes through every element in the array, we keep a variablemin in that is the index of the going to be the index of the smallest element tothe right of pointer i.<br><br>8. So, now we canlook finally at the main event driven simulation loop.<br>
paired|sentence cnt : 2 <br> <br>1. And contains a simpler operation than get its convenient for manyclients where it just tells us whether there's some value paired with thatkey in the table is empty in size.<br><br>2. Put a key value pair into the table so that is associate the value with key andthen get the value paired with the key.<br>
statistician|sentence cnt : 1 <br> <br>1. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br>
biology|sentence cnt : 3 <br> <br>1.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br><br>2. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>3. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
keeps|sentence cnt : 2 <br> <br>1. So that's just a, a way of make suring that the simulation keepsproceeding.<br><br>2. This version keeps it unordered.<br>
matrices|sentence cnt : 3 <br> <br>1.As a final example of a symbol tableclient, we'll take a look at a mathematical application where we want toimplement sparse vectors and matrices.<br><br>2. Or, even nowadays youmight have matrices that are, are even bigger.<br><br>3. But the fact is that in manypractical applications, the matrices are what's called sparse.<br>
read|sentence cnt : 58 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. And so, this client readsstrings from standard input.<br><br>3. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>4. And in all of these cases where we're on a node that alreadyexisted, we just want to return the link to that node.<br><br>5. Once it's read in we get to read all of the page for free pretty much.<br><br>6. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>7. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>8. Notice already that will meanwhen we get back to 0.<br>
bending|sentence cnt : 2 <br> <br>1. It's a little mind bending atfirst because of the recursive structure but it won't take you long to convinceyourself that this little bit of extra code completes the implementation ofleft-leaning red-black trees.<br><br>2. The other thing that's possible to do andit's a little mind bending so recommended only for experts.<br>
constructed|sentence cnt : 1 <br> <br>1. Watching the [unknown], this is a balanced tree gettingconstructed in the worst case where everything that comes in is in ascendingorder.<br>
incompatible|sentence cnt : 1 <br> <br>1. If the types areincompatible or if either one is null compareTo() should throw an exception.<br>
much|sentence cnt : 90 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>4. But fortunately, we can get through prettymuch everything that we're going to do in this course just knowing about this one oflay cast.<br><br>5. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>6. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>7. Once it's read in we get to read all of the page for free pretty much.<br><br>8. And one of the themesthat we'll go through over and over in this course is that quadratic time is muchto slow.<br>
transformed|sentence cnt : 2 <br> <br>1. And then we did a right rotate on the top node, and that transformed to thecase where our temporary four node is balanced.<br><br>2. We get this most complicated case we did a left rotate onthe bottom node and that, that transformed it to this case where they're both leaningleft.<br>
conditional|sentence cnt : 1 <br> <br>1. But the heap conditional will be violated because T is still smaller than S.<br>
takes|sentence cnt : 58 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2. Now instead of the initialization always takes timeproportional to N.<br><br>3.It takes it, boolean condition.<br><br>4. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br><br>5. In this case, it's easy to see that every operationtakes constant time in the worst case.<br><br>6. First thing we do is the public sortmethod that takes the array of comparable items as its argument.<br><br>7. You wouldn't work to use Shellsortas the basis for h-sorting because that always takes quadratic time no matter whatorder there is in the array.<br><br>8. It implements the compare method that takes two points as argument and withjust a little bit of calculation is able to do the compare.<br>
fraction|sentence cnt : 1 <br> <br>1. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
degeneracy|sentence cnt : 1 <br> <br>1. And again simplify the code, we are going to make the non degeneracyassumption that no two intervals have the same left end point.<br>
pretty|sentence cnt : 39 <br> <br>1. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>2. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>3. But fortunately, we can get through prettymuch everything that we're going to do in this course just knowing about this one oflay cast.<br><br>4. Once it's read in we get to read all of the page for free pretty much.<br><br>5. It's going to be less than lg N and compares and it's got support for allthose ordered ST operations, and compared to and is pretty easy and natural functionto implement.<br><br>6. And that pretty much wipes out clustering but it, it is moredifficult to implement delete for that one.<br><br>7. So it's prettywell balanced which means that our search and insert cost in this case for 255 keysis only going to be sixteen quite a bit less.<br><br>8. Howcould we guarantee that all operations are fast? Binary research is pretty good butthat's a major flaw.<br>
resets|sentence cnt : 2 <br> <br>1. We have an inter-for loop that for j, if it finds asmaller one, resets min and then once we've looked at all the elements to theright of i we exchange the smallest one with i.<br><br>2. If the key's there, it just resets the value.<br>
called|sentence cnt : 113 <br> <br>1. It's called divide and conquer.<br><br>2. So the goal is socalled three way partitioning.<br><br>3. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>4. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>5. This is called intervalsearch.<br><br>6. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>7. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>8. So, how are we going to do better? Our first attempt is analternative called, Quick-union.<br>
borne|sentence cnt : 1 <br> <br>1. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br>
successor|sentence cnt : 2 <br> <br>1. Why are we using the successor, and not the predecessor? No real reason.<br><br>2. And as you watch it go for a while, you can see that this thing about going to the right and taking the successor all the time, the trees becoming much less balanced that it was.<br>
assignments|sentence cnt : 2 <br> <br>1. Wewill provide much more detail information on that as we get into the assignments.<br><br>2. Here's a war story fromstudents Programming assignments not that long ago.<br>
endpoints|sentence cnt : 1 <br> <br>1. So, the insertion time might belinear, but then you can use binary search, to look for the two endpoints,that's only going to take time proportional to log in.<br>
those|sentence cnt : 151 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>3. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>4. So, just following those threecases, I see t hat this correspondence is going to work.<br><br>5. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>6. In thiscase, if c is less than b and a is less than c then those three compares show thatthe order has to be a, c, b and if c is less than a, then it's going to be c, a,b, those three compares that c is less than a, c less than b and a is less thanb.<br><br>7. All those zeros have to getchanged to ones.<br><br>8. Then on another pass through, we can takethe E, M and the G, R and merge them together to make EGMR, and the E, S and theO, R merge those together to make EORS, and so forth.<br>
animation|sentence cnt : 11 <br> <br>1. So that's an animation forrandomly ordered items.<br><br>2. Let's look at an animation of selection sort in operation.<br><br>3. This animation does the whole h-sort for each subarray.<br><br>4. So let's see that in the animation.<br><br>5. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br><br>6. [COUGH] Let's look at an animation.<br><br>7. So let's look at how thatlooks in the animation.<br><br>8. Here's ananimation.<br>
decrease|sentence cnt : 6 <br> <br>1. For whatever reason a parent becomes the key and decreases, it might become smaller than one or both of its children's.<br><br>2. But still again, using theory as a guide maybe there's a way to decrease costs a little bit from binary heaps.<br><br>3. So that's an implementation of the delete max operation for heap using a sink, where a key value decreases, goes down in the heap.<br><br>4. So how are we going to grow andshrink the array? Well, first thing you might think of is,when the client pushes a new item onto the stack, increase the size ofthe array by 1, and when it pops, decrease the size of the array by 1.<br><br>5. Again, we take it out by exchanging this time G with a root, and then decrease the size of the heap by one and just take that out.<br><br>6. Again just a few lines of code to eliminate the violation when a key value in a heap decreases.<br>
exchange|sentence cnt : 88 <br> <br>1. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>2. So first we exchange it with the 10,it's still not in place, so we exchange it with the 7.<br><br>3. So, with just two exchanges we insert that new element into the heap in this case.<br><br>4. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>5. Then once we've exchangedit, again, we preserved our invariant.<br><br>6. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>7. But in general, we have to check whether the heap condition is violated and exchange it with its parent as long as it's smaller.<br><br>8. As long as we're not at the root and k's parent, k over 2 is less than a of k then we just exchange it with its parent and move up.<br>
difficulties|sentence cnt : 4 <br> <br>1. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>2. All different types of problems mightoccur and with some difficulties, it's possible to prove thateven if the tree's balanced, you can get a worse caseproportional to square root of N.<br><br>3. With arrays, it doesn't quite work andagain all programming languages and, you know, many programming languages nowadayshave difficulties with this and Java's got a particular difficulty.<br><br>4. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br>
clustering|sentence cnt : 4 <br> <br>1. So the clustering in the data is going tomake the implementation inefficient.<br><br>2. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>3. And that pretty much wipes out clustering but it, it is moredifficult to implement delete for that one.<br><br>4. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br>
clock|sentence cnt : 14 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. Example at the right, a to b to c is not counterclockwise.<br><br>3. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>4.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>5. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>6. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>7. Now that's essentially the proof that you have to have acounterclockwise turn.<br><br>8. So wealready looked at the Get operation so we might want to know what city is associatedwith the event that happened at time nine o'clock, thirteenth and so that shouldreturn that value.<br>
stability|sentence cnt : 6 <br> <br>1. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>2. Stability is an important property in sorting algorithms.<br><br>3.Finally, we talk about stability.<br><br>4. And on the other thing is it's not stable,sometimes people choose to use Mergesort in practice because of the stability butHeapsort isnot stable for the usual reason that it does long distance exchanges thatmight bring items that have equal keys back out of order.<br><br>5. Actually not all sorts preservethat property that is called stability.<br><br>6. But if they use a stable sort, then it stay sorted by time and lots ofapplications you want stability.<br>
involved|sentence cnt : 13 <br> <br>1. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>2. And there's also a variable called count, which is the number ofcollisions of particles have been involved in.<br><br>3. It's often used in embedded systems or in hardware sort type systems becausethere's so little code involved to implement it.<br><br>4. Not much code involved.<br><br>5. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br><br>6. This is a bigger trace that shows, again, about half the elements belowthe diagonal are involved in the sort.<br><br>7. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>8. And also it'llperform better for huge tables whereas caching is involved.<br>
reclaimed|sentence cnt : 1 <br> <br>1. And then that first node is ready tobe reclaimed by the garbage collector.<br>
buyer|sentence cnt : 1 <br> <br>1. If we get to the bottom and our current nodeis null and that's falling off the bottom of the tree we return null and that'sequivalent to saying our buyer convention that, that key is not in our datastructure, or not in our symbol table.<br>
fully|sentence cnt : 10 <br> <br>1. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>2. [cough] And actually, in typical applications with any kind ofrandomness or even if there is a lot of order its difficult to find situationsorders of keys that build the trace of height is bigger than actually one log Nin, in a real application, its very close to fully balanced all the time.<br><br>3. You have to carefully check the code to be sure.<br><br>4. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>5. So now, we have a fully dynamic symbol table where we can insert and delete the number of nodes that we have in the tree is always proportional to the number of key value pairs in the symbol table.<br><br>6. So we need a data-structurethat more gracefully adapts to the distribution of the data.<br><br>7. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br><br>8. So, taking a look at equal keys is carefully is something thatcan lead us to very efficient Quicksort.<br>
conventions|sentence cnt : 6 <br> <br>1. Now there's a couple ofconventions around null.<br><br>2. So hashing is widely used forsystems programming and applications, so some conventions forhashing are built into Java.<br><br>3. So we need to fill in this one table, what's the cost of deletion in a binary search tree? How we're going to really do that? Well, let's take a look at a very lazy approach which we setup for in our basic conventions for symbol tables.<br><br>4. So we have a, a, a bunch of conventions just toreduce the code.<br><br>5. And if we this the, the thing called event which involves it saysbetween two particles, something is going to happen at a certain time and we'regoing to adopt the conventions that, if, neither particle is null then we'retalking about two particles.<br><br>6. And these are just conventions and some are details but it's importantto appoint them all at front.<br>
achieve|sentence cnt : 6 <br> <br>1. Whereas what we can hope for and what weactually will achieve is to get log N time for all operations, time proportion to log Nfor all operations.<br><br>2.And now we've achieved the goal of partitioning the array.<br><br>3. So we've achieved putting it inorder with less work in this case.<br><br>4. And they're easy to achieve.<br><br>5.Here's another client that we could use our sort program for, if we achieved thegoal of sorting any type of data.<br><br>6. With the clever data structure and interesting implementationwe can actually achieve that goal.<br>
critical|sentence cnt : 11 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>3. We do some mathematical proofs in, in thiscourse when they're critical such as this one.<br><br>4.And the exact number they use is not too, critical.<br><br>5. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>6. The two things that are critical is thatthe, in a, in a 2-3 tree, we always have symmetric order.<br><br>7. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br><br>8.Now, look at an interesting application ofpriority queues that is actually representative of whole family of acritically important applications in applications of computing.<br>
balance|sentence cnt : 54 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>3. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>4. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>5. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>6.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>7. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br><br>8. Balance trees, that allow for this.<br>
deployed|sentence cnt : 1 <br> <br>1. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br>
element|sentence cnt : 148 <br> <br>1. So, with just two exchanges we insert that new element into the heap in this case.<br><br>2. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>3. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>4. We create the array and then set eachelement to be it's own root.<br><br>5. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>6. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>7.The idea is to arbitrarily choose the first element to be the partitioningelement.<br><br>8. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br>
enlarged|sentence cnt : 1 <br> <br>1.And that's actually not worth the cost for enlarged samples, not usually.<br>
sweep|sentence cnt : 13 <br> <br>1. Sosweeping from left to right means we consider each x coordinate as an event.<br><br>2. And, and that willgive us now three rectangles on our sweep line.<br><br>3. So now again, sweep from left to right.<br><br>4. But that as the basis, we're able to solve the two dimensional line segmentintersection search using the sweep line algorithm.<br><br>5. That's the basic idea behind the sweep linealgorithm, to find intersections in sets of horizontal and vertical lines.<br><br>6. Really, it's a modification of the sweep line algorithmthat we looked at for intersecting lines.<br><br>7. Sort the points by polarangle with p so that is if we take a, a vertical line and sweep it in acounterclockwise direction, what order that we hit the points? The first thing wehit is 0, 1, and then we sweep counterclockwise, we get the 2 and then3 and 4 and so forth.<br><br>8. But with the basic interval search tree algorithmand the sweep line process that we've talked about, you can get the orthogonal,orthogonal rectangle intersection search problem solved in time proportional toanalog N log N + R log N, where R is the number of intersections.<br>
predictions|sentence cnt : 1 <br> <br>1. And then we'll go ahead and do thepredictions of each of those particles, A and B, against all other particles.<br>
radius|sentence cnt : 3 <br> <br>1. So, we have to do collision prediction, which is givenposition, velocity, and radius when's it going to hit with another particle or, orthe wall.<br><br>2. So, it's got position and velocityas I mentioned, and every ball has a, a radius.<br><br>3. And each particle is a disc that's got known position, velocity, mass,and radius.<br>
ones|sentence cnt : 40 <br> <br>1. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>2. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>3. About half a million distinct ones andin that [COUGH] corpus, the word government appearsabout 25,000 times.<br><br>4. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>5. All those zeros have to getchanged to ones.<br><br>6. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>7. And again, you could do this with a linked list or withthe resizing array but then, with array, you'd have to move all the larger ones overone position to fit the new item in.<br><br>8. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br>
optional|sentence cnt : 1 <br> <br>1. Down at the bottom, andit's optional for this course, we have a text book.<br>
ought|sentence cnt : 8 <br> <br>1. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>2. And so but, but they still thought that it should be balancedand it shouldn't matter much.<br><br>3. So now when we associate E with 6, we have to search throughthe list to see if there's an E.<br><br>4. We want to add something to thecollection, maybe remove something from the collection and iterate throughthe objects in a collection, performing some operation on them,and of course test if it's empty.<br><br>5. That's another one like merging in place, that you'd think there ought to be an easy way to do it, but in 50 years, no one's really discovered one.<br><br>6. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br><br>7. So the, the reason they used that is they thought they gotthem closer to the middle and they also don't like the, some system designersdon't like the idea of using random choices in a system method because of waythat it changes the state of the system.<br><br>8.>> I thought the red door was the storage container.<br>
french|sentence cnt : 2 <br> <br>1. He was quiteexcited because he was watching a re-run on, of an English actually Canadian TVshow on French TV.<br><br>2. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br>
lists|sentence cnt : 8 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. So we don't need so much any more generalprograms for manipulating linked-lists.<br><br>3. So for linked lists, every operationtakes constant time in the worst case, that's a guarantee.<br><br>4. So we haveto look through the whole list for search but you only have to look through one listout of all the lists.<br><br>5. The first implementation thatwe'll look at uses linked lists.<br><br>6. So the pop operation forlinked lists is very easy to implement.<br><br>7. Even if you are familiar with linkedlists, it's worth taking a look at this code because it's the style of codingthat we'll use throughout the course for much more complicated data structures.<br><br>8. If you're not familiar with linked lists, you'll need to review that insection 1.<br>
unstable|sentence cnt : 2 <br> <br>1. Mergesort and log N guarantee unstable but not inplace, need that auxiliary array.<br><br>2.Insertion sort best case linear, quadratic, and place unstable.<br>
assuming|sentence cnt : 5 <br> <br>1. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>2. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>3. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br><br>4. We're assuming that the client doesn't get to change the keys while they're on the priority queue.<br><br>5. We'll look at three proofs of that, justassuming that N is a power of 2.<br>
universally|sentence cnt : 1 <br> <br>1. And we'd throw them universallyat random into M bins.<br>
percolate|sentence cnt : 16 <br> <br>1. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>2. If the probability is high and there is a lot of open sides, itdefinitely is going to percolate.<br><br>3. But in the middle, when it's medium, it's questionable whether itpercolates or not.<br><br>4. When it'shigh, it is going to percolate.<br><br>5. And then, when we want to know whetherthis system percolates, we just check whether the virtual top site is connectedto the virtual bottom site.<br><br>6. And everytime we add an open site, we check to see if it makes the system percolate.<br><br>7. And actually there is avalue as N gets large that if you're less than that value it almost certainly willnot percolate, if you're greater it almost certainly will.<br><br>8. So the scientific question, or the, mathematical questionfrom this model is, how do we know, whether it's going to percolate or not? Inthis problem and in many similar problems, there's what's called a phase transition.<br>
incomes|sentence cnt : 1 <br> <br>1. You might ask for all the peoplewith incomes between 1 million and 10 million who are between 40 and50 years of age.<br>
component|sentence cnt : 27 <br> <br>1. They're in their own connected component.<br><br>2.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>3. So, from this datastructure we can associate with each item a root, which is representative, say, ofit's connected component.<br><br>4. Forexample in this small example here, there's three connected components.<br><br>5. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>6. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>7. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>8. Union is more difficult in order to merge the components, containingtwo given objects.<br>
parameter|sentence cnt : 7 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2.sort is a method that takes anarray a as its parameter and it, it's the first argument and it rearranges thestrings in that array to be in sorted order.<br><br>3. And those are typical parameters.<br><br>4. And, depending on the valueof the parameter, M, you have a space time trade-off.<br><br>5. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>6. So, and I will pick a parameter M and divide space intoan M-by-M grid of squares.<br><br>7. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br>
calculations|sentence cnt : 2 <br> <br>1. That's the nextcollision that's going to happen from all our calculations.<br><br>2. And people understand properties ofthe universe by doing these kinds of calculations and comparingagainst what's observed in space.<br>
insensitive|sentence cnt : 1 <br> <br>1. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br>
correspondence|sentence cnt : 10 <br> <br>1. So we've got M bins, that's ourcorrespondence to our hash table.<br><br>2. So, just following those threecases, I see t hat this correspondence is going to work.<br><br>3. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>4. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>5. And that's a key property is this one-to-one correspondence between 2-3trees and left-leaning red-black trees.<br><br>6. So, the basic s trategy is, with thoseoperations, maintain one-to-one correspondence with 2-3 trees when we doinsertions.<br><br>7. And youcan see from this transformation that it's easy to perform this, see thiscorrespondence the middle link between A and B, those are the keys that are lessthan B and larger than A.<br><br>8. After we do the left rotate, we have a legalleft-leaning red-black tree, and it exactly corresponds to that 2-3 tree, sothe insertion of C gives us exactly what we would want, that correspondence withthe 2-3 tree.<br>
articulated|sentence cnt : 3 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>3. What's the implementation of an exception filters?Here's a simple one using the said API that we just articulated.<br>
whichever|sentence cnt : 3 <br> <br>1. Whichever sort arestable? That's an interesting question that we'll take a look at now.<br><br>2. And whichever one is taken, we incrementits pointer.<br><br>3. So, six and five doesn't matter, whichever onegoes down doesn't matter.<br>
these|sentence cnt : 151 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. These types of things ariseoften in practical applications.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>5. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>6. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>7. We encapsulate them in basicdata types like these.<br><br>8. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br>
continues|sentence cnt : 1 <br> <br>1.And if it's not a CCW turn, it pops and then continues going.<br>
billiard|sentence cnt : 1 <br> <br>1. Andalso nobody racks up a, a set of billiard balls such that all fifteen are touchingin all places.<br>
erent|sentence cnt : 102 <br> <br>1. We have two different stacks.<br><br>2. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>3. So, one thing is we're usinga different key interface.<br><br>4. So that's three different clients, three completelydifferent types of data.<br><br>5. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>6. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>7. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>8. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br>
documents|sentence cnt : 1 <br> <br>1. Not only does it help detect bugs, but it also documents what the code is supposedto do.<br>
thru|sentence cnt : 1 <br> <br>1. 21 thru 23 to seventeen, nineteen.<br>
significant|sentence cnt : 11 <br> <br>1. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br><br>2. They convert to 64-bit, and x or the most significant 32-bits withthe least significant 32-bits.<br><br>3. You can sort from that heap and that's significance be,significant because it's the first sorting algorithm that we've seen that is both inplace.<br><br>4.Now we're going to take a look at whathappens when we have significant numbers of duplicate keys which is not at allunusual in practical applications.<br><br>5. The other thingthat is probably more significant on modern machines is.<br><br>6. Now that's also simple toimplement and it works well as long the size of the array is, significantly biggerthan the number of keys.<br><br>7. It seems like it should beeasy to implement equals, basically we're just going to check thatall the significant fields are the same.<br><br>8. Make sure they're the sametype can do the casting, and then compare all the similar andsignificant fields.<br>
queue|sentence cnt : 98 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>3. So howare we going to implement stacks and queues for that types of data.<br><br>4. But also taking care of specialcases when the queue is empty.<br><br>5. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>6. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>7. And then that's a time in the futureand we'll put that event on the priority queue with that time as the key.<br><br>8. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br>
discount|sentence cnt : 1 <br> <br>1.So we can discount that.<br>
integration|sentence cnt : 1 <br> <br>1. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br>
various|sentence cnt : 10 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>3. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br><br>4. And, there werevarious rules about what you can do on these drawings.<br><br>5. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>6. We're sorting strings but we'reimplementing a different ordering, various different orderings on that same data.<br><br>7. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br><br>8. To begin, we'll take a look at the API andsome elementary implementations and various operations that peoplewant to perform on symbol tables.<br>
sometimes|sentence cnt : 14 <br> <br>1. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>2. We're goingto be able to sort the same things in different way sometimes and this exampleis a fine motivation of that.<br><br>3. Whereas on the other hand, sometimes the whole purpose of a data type is to maintain a changing value.<br><br>4. Well, it'sleft leaning and the process is a little bit different and sometimes the left pathcan get long but not that long.<br><br>5. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br><br>6. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>7. And the idea isthat during the construction of a tree, or during an insertion operation, sometimeswe wind up with red links that are leaning in the wrong direction.<br><br>8. Then test isEmpty() and we also sometimes have extra method that justgives us the value of the largest key and also size which is useful sometimes incollections.<br>
regarding|sentence cnt : 1 <br> <br>1. In this case that involvesregarding the S and the R.<br>
text|sentence cnt : 32 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>3. There is abook site and text book as well.<br><br>4. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br><br>5. There's an easy way to do this based on CCW that is described here inthis text.<br><br>6. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>7. Down at the bottom, andit's optional for this course, we have a text book.<br><br>8. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br>
assigned|sentence cnt : 1 <br> <br>1. So that's kind of like when you create a literal value to be assigned to an integer, it has that value.<br>
date|sentence cnt : 39 <br> <br>1. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>2. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>3. It's closer, sowe update 3 to be our new champion.<br><br>4. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>5. So, E is a key candidate.<br><br>6. So say we have this simplified dateimplementation that we talk about before.<br><br>7. And we just say, we're going to update everything every dt seconds.<br><br>8. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br>
nested|sentence cnt : 5 <br> <br>1. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>2. We use the same merge code as before and we takea nested for loop.<br><br>3. I won't go through it all in detail just to point out that thisimplements two different comparators as nested classes.<br><br>4. And the key thing about this standard implementation thatit's two nested four loops that each run up to N.<br><br>5. It's got two nested for loops,selection sort had two nested for loops, a test, a comparison, andan exchange inside the for loop.<br>
initial|sentence cnt : 14 <br> <br>1.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>2. Now instead of the initialization always takes timeproportional to N.<br><br>3. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>4. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>5. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>6. Now, insertion sort does dependon the initial order of the data.<br><br>7. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>8. So, now we start by initializingi at the first card, and we take the idea that everything from ito its left is going to be sorted, and everything from the right we'renot going to look at at all.<br>
improvements|sentence cnt : 4 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>3. Quick Find and Quick Union, and some applications and improvements ofthose algorithms.<br><br>4. Now there's a, a number of practicalimprovements that we can use to make Mergesort even more efficientthan the simple one that we've looked at and we'll take a lookof those because they're examples of techniquesthat we can use for other algorithms.<br>
gradual|sentence cnt : 1 <br> <br>1. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br>
convert|sentence cnt : 12 <br> <br>1. They convert to 64-bit, and x or the most significant 32-bits withthe least significant 32-bits.<br><br>2.So we're going to convert that into a 4-node.<br><br>3.Convert into a 3-node, Now insert C into that.<br><br>4. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>5.That 3-node gets converted into a 4-node.<br><br>6. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br><br>7.Now, the constant depends on the implementation, exactly what kind ofmanipulations we need to do to convert, 3-nodes to 4-nodes and so forth.<br><br>8. So we need to convert that 2-node into a 3-node.<br>
implementors|sentence cnt : 1 <br> <br>1. Now for standard keys like integers andstrings and doubles and so forth,we can count on the designers and implementors at Java toimplement good hash functions.<br>
somebody|sentence cnt : 10 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>3. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>4. So you'd have to be a little carefulthat somebody is in there doing that.<br><br>5. And so, there is still the goal of a, of afast guaranteed linear time selection algorithm maybe somebody in this classwill invent someday.<br><br>6. And somebody's implemented a service in Java that it uses a simp letable that takes string keys, you can cause that to crash in this way.<br><br>7. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br><br>8. So, we type in somebody's loginname we get their first name.<br>
distribution|sentence cnt : 3 <br> <br>1. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br><br>2. Or it's something about thedistribution of key values if there are a lot of equal keys we can get sorted, getit sorted faster than, N log N.<br><br>3. So we need a data-structurethat more gracefully adapts to the distribution of the data.<br>
occurrence|sentence cnt : 5 <br> <br>1. And now the integer that we'regoing to associate with each word is the frequency of occurrence ofthat word in the symbol table.<br><br>2. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>3. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br><br>4. So if the word's not in the symbol table,we'll put it there with a frequency of occurrence of 1,that's the first time we saw the word.<br><br>5. So that's read this loop,reads in all the data and associates each word withits frequency of occurrence.<br>
essentially|sentence cnt : 14 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>3. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>4. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>5. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>6. Essentially if you have M entries in the hash table and Mkeys the link of list you're going to look at is about N over M cuz they're evenlydistributed.<br><br>7. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>8. Now that's essentially the proof that you have to have acounterclockwise turn.<br>
tough|sentence cnt : 1 <br> <br>1. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br>
files|sentence cnt : 33 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. That's building a symbol table associatingkeys with sets of files.<br><br>3. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>4. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>5. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br><br>6. So again we use the File class from Java and we use, we go anduse the listFiles() method from that class to get an array that contains all the filenames in the given directory.<br><br>7. So this creates a new symbol table associating string keys with sets offiles.<br><br>8.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br>
flipped|sentence cnt : 2 <br> <br>1. We flipped the colorsand now our temporary 4-node is up higher in the tree but it's not balanced so weare going to have to do two rotations to make that balanced.<br><br>2. And then we flipped colors onthat.<br>
continue|sentence cnt : 14 <br> <br>1.And if it's not a CCW turn, it pops and then continues going.<br><br>2. And we'll continue to do a few more so you'llget an idea of how it works.<br><br>3. And continue in that way, swap.<br><br>4. Now, that part of thearray to the left of i is in it's final order and we simply continue.<br><br>5. Continue until we find P.<br><br>6.Now, if that parent were a 3-node, it would become a temporary 4-node and wouldcontinue the process moving up the tree.<br><br>7. And follow the link corresponding to theinterval that we know must contain the search key by definition of the tree andthen we recursively continue the search.<br><br>8. Onevery smaller heap, now we continue just performing sync operations at the rootuntil we get a completely sorted array.<br>
complicated|sentence cnt : 39 <br> <br>1.Delete code is a bit more complicated but it's on the book side and in the book.<br><br>2. It's just complicated code to understand.<br><br>3. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>4. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>5. That is easy for some types of data but it can get complicated formore complicated types of data.<br><br>6. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>7. So this is, we'll start withone dimension as before and right away you can see that it's a more complicatedproblem than we've been dealing with.<br><br>8.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br>
slope|sentence cnt : 2 <br> <br>1. Or if theslope is infinity.<br><br>2. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br>
particle|sentence cnt : 50 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>4. There's do this prediction for every one of the particles.<br><br>5. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>6. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>7.Because if we have a computational process that takes quadratic time, then it's notgoing to scale, we're not going to be able to do large number of particles.<br><br>8. When you have two particles there's definitely moremath.<br>
processor|sentence cnt : 2 <br> <br>1. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>2. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br>
pixels|sentence cnt : 1 <br> <br>1. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
infinity|sentence cnt : 3 <br> <br>1. Or if theslope is infinity.<br><br>2. Well, actually if it's going awayfrom a wall, it's not going to hit it so that would be infinity.<br><br>3. And the other point is we're going to return infinity if there'sno collision at all so that it's going to keep, keep that on the priority queue,that ran on the priority queue forever.<br>
seeing|sentence cnt : 3 <br> <br>1. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br><br>2. So without seeing all the details yo can understand that the same basic ideais going to work in this situation where we're dealing with much, much more memory.<br><br>3. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br>
incrementing|sentence cnt : 2 <br> <br>1. And now we've added it to the heap by just incrementing in and putting it in there.<br><br>2. So, finding, incrementing I, as long asit's less is a simple while loop.<br>
mark|sentence cnt : 9 <br> <br>1. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>2.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>3. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>4. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br><br>5. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br><br>6. It's quite remarkable, actually.<br><br>7. What we can do to remove a node with a given key, is just mark it with a tombstone.<br><br>8. And one ofthe things to remark about it is that it only uses N exchanges and so forth.<br>
assessment|sentence cnt : 1 <br> <br>1. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br>
prototype|sentence cnt : 1 <br> <br>1. And it's actually a prototype foralgorithm design that we'll see come up again and again.<br>
philippe|sentence cnt : 1 <br> <br>1. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br>
inputs|sentence cnt : 2 <br> <br>1. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>2. And then there are many applications where randominputs are fine model.<br>
started|sentence cnt : 5 <br> <br>1. We'll just goahead and compute the increments that are less than n, n / 3 and then startingat that increment whatever it is and say, we started 364 then next time we need anincrement, we'll just divide it by 3, 364 integer divide by 3, 364 integer /3 it gets 121, 40 and so forth.<br><br>2. We started with one dimensionalrange search and just used regular binary search tree to compute ranks to get theanswer.<br><br>3. So, to get started, we'regoing to look at a simple problem called one-dimensional range search.<br><br>4. To get started we map a key to a integerbetween zero and m-1 where m is the sides of our array where we are storing thekeys.<br><br>5.To get started, we'll look at the API and some elementary implementations.<br>
connect|sentence cnt : 90 <br> <br>1. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>2. If they are connected it'll ignore.<br><br>3. They're in their own connected component.<br><br>4. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>5. Because it would have N^2,calls to find, to check whether they're connected.<br><br>6. And then we'll connectthem together.<br><br>7. What about nine and four? So, now we have to change the, to connect nine andfour, we have to change, 9's entry to be the same as 4's.<br><br>8. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br>
particulary|sentence cnt : 1 <br> <br>1.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br>
incur|sentence cnt : 1 <br> <br>1. But it doesn't incur any extra cost at allin production code.<br>
researchers|sentence cnt : 4 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>2. Lots of researchers havedone good work to show this.<br><br>3. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br><br>4. Thing to be researchers in the 1950's who cared so much about memoryand nowadays a little extra memory is not something that people care about so muchand most people just go with the easy algorithm except for really performancecritical applications.<br>
rotate|sentence cnt : 30 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>3. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>4. If it goes on the right, then we attach a new node with thered link on the right but we have to rotate it to the left to make a legalthree node.<br><br>5. And then we rotate thetop link right and then, we flip the colors.<br><br>6. And then we did a right rotate on the top node, and that transformed to thecase where our temporary four node is balanced.<br><br>7. Now, we have athree node, but the red link is leaning right so we have to rotate.<br><br>8. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br>
facilitate|sentence cnt : 2 <br> <br>1.So 2d tree again, it's going to be a datastructure based on a bunch of points that's going to facilitateefficient data processing at these points.<br><br>2. So now, what about operationslike rank and select? How many keys are there less than a given key? And, give usthe seventh largest key to facilitate implementing those operations and alsosize all we do is keep an extra field in each node, which is the number of thenodes in the subtree rooted at that node.<br>
default|sentence cnt : 4 <br> <br>1. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>2. So by default, insertions are disabled.<br><br>3. Now, the default implementation for hashing is the memoryaddress of the object.<br><br>4. And again the default implementation is tocheck whether we refer to the same object and that's rarely what we want,Java system's programs may be want that.<br>
comparables|sentence cnt : 1 <br> <br>1. We first in order to sort an array of comparables in this implementation we passa link to the auxiliary array, in as well.<br>
pains|sentence cnt : 1 <br> <br>1. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br>
grandparent|sentence cnt : 1 <br> <br>1.Actually to make a one liner code, we use a, a simple variant where we make everyother node in the path point to its grandparent on the way up the tree.<br>
slopes|sentence cnt : 1 <br> <br>1. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br>
anyone|sentence cnt : 1 <br> <br>1. I'm not going tosell tickets to anyone that came after that time.<br>
hang|sentence cnt : 178 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>3. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>4. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>5. So first we exchange it with the 10,it's still not in place, so we exchange it with the 7.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. So, with just two exchanges we insert that new element into the heap in this case.<br><br>8. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br>
industrial|sentence cnt : 3 <br> <br>1. We can use resizing array in industrial strength implementation, the same that we did for stacks and other data structures where we use arrays.<br><br>2. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br><br>3. That is a fullycomplete industrial strength code for sorting.<br>
knife|sentence cnt : 1 <br> <br>1. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br>
concrete|sentence cnt : 1 <br> <br>1. Okay, with this concrete demo in mind then moving tocoding up this algorithim is pretty straight forward.<br>
smaller|sentence cnt : 58 <br> <br>1. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>2. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>3. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>4. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>5. But in general, we have to check whether the heap condition is violated and exchange it with its parent as long as it's smaller.<br><br>6. Then the heap order condition is satisfied at that node because the parent was smaller, so that one's smaller.<br><br>7. Now in this case the second subarray to be sorted is smallerbut the merge routine doesn't really care about that so much.<br><br>8. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br>
your|sentence cnt : 69 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>3. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>4.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>5.Even on your PC you can sort huge array of a million items in less then a second anda million items in only a few minutes.<br><br>6. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>7. Maybe the way yourcomputer's memory is organized make a difference.<br><br>8. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br>
connective|sentence cnt : 2 <br> <br>1.Now, once we can calculate these roots, then we can implement the find operationjust by checking whether the two items that we're supposed to check with areconnective where they have the same root.<br><br>2. That's equivalent to saying, are they inthe same connective component? So that's some work, going to find the roots of eachitem but the union operation is very easy.<br>
associate|sentence cnt : 67 <br> <br>1. And if it does, print the value associated with the key.<br><br>2. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>3. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>4. And now build asimple table that associates strings with strings.<br><br>5. Give me the minimum key, give me the largest key, andthen I can get the value associated with that using that.<br><br>6. So, from this datastructure we can associate with each item a root, which is representative, say, ofit's connected component.<br><br>7. And then find the index associatedwith the key that we're searching for using binary search.<br><br>8. And now the integer that we'regoing to associate with each word is the frequency of occurrence ofthat word in the symbol table.<br>
physics|sentence cnt : 13 <br> <br>1. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>2. Andso, I think most students have had high school Physics and will be able to do, dothis Math or at least be convinced that the code that does this Math is correct.<br><br>3. There's algorithms in physics for understanding physical phenomenon thatwe'll look at an example and many others on this list.<br><br>4. We need those procedures that implement those Physics rules for everyparticle.<br><br>5. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>6. The Physics problem is exactly what happenswhen two balls hit and they bounce off each other according to somewell-understood physical process, and that's the high school Physics.<br><br>7. Andagain nobody's claiming that this is easy but this is the Physics part and it'sworked out and it comes from Newton's Second Law.<br><br>8. And again, this is high school Physics.<br>
inefficient|sentence cnt : 2 <br> <br>1. So the clustering in the data is going tomake the implementation inefficient.<br><br>2. Theidea of Shellsort is that Insertion Sort is inefficient because elements reallymove only one position at the time even when we're kind of know that they have along way to go.<br>
reusable|sentence cnt : 1 <br> <br>1. So this allows us to create modular, reusable libraries of algorithms anddata structures that we can use to build more complicated algorithms anddata structures.<br>
standpoint|sentence cnt : 1 <br> <br>1.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br>
specification|sentence cnt : 2 <br> <br>1. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>2. All of that leads up to, in a programmingworld to specifying, a data type which is simply specification of the methods thatwe are want to going to implement in order to solve this problem.<br>
routed|sentence cnt : 1 <br> <br>1. So, we used the same datastructure except, now we need an extra array, that for each item, gives thenumber of objects in the tree routed at that item.<br>
declared|sentence cnt : 2 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2.And at the top, the class declaration we declared an angle brackets that item isthe generic type that we're going to use.<br>
theoretical|sentence cnt : 4 <br> <br>1.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br><br>2. Thetheoretical best that you could possibly do would be R plus log N but in practice Rlog N is quite efficient.<br><br>3. So it's theoretically possible, but themethods are generally too complex to be useful inpractice and their not used.<br><br>4. So , what we want to take from thesetheoretical results is, is a guide when we're looking at implementations andtrying to solve practical problems.<br>
simplify|sentence cnt : 4 <br> <br>1.Easy, easy to fix but, but we don't simplify the code.<br><br>2. So, just, to simplify our code in the slides in it's off, off from thecase for geometric data processing.<br><br>3. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br><br>4. And again simplify the code, we are going to make the non degeneracyassumption that no two intervals have the same left end point.<br>
stronger|sentence cnt : 1 <br> <br>1. On the other hand, balanced searchtrees have a much stronger performance guarantee.<br>
submit|sentence cnt : 1 <br> <br>1. In fact,a pr ogrammer might ask, why study anything else? Well, there's plenty ofgood reasons to study other things, but I'll submit there's no good reason not tostudy algorithims.<br>
increment|sentence cnt : 66 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So we move that one up and increment j andk.<br><br>3. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>4. To push an item,we use N to index into the array, put the item there and then increment N.<br><br>5. And now we increment i and k.<br><br>6. Now the one pointed to my i, the G is smallest so move that and increment iand k.<br><br>7. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>8. For example we can say that the number of comparison and theworst case is O(N3/2) for the 3x + 1 increments.<br>
extending|sentence cnt : 2 <br> <br>1. So, this is just extending our ball data type that we use for thebouncing balls that didn't collide to take in, into account these extra things.<br><br>2.This is extending the table we looked at last time, and you can see over in theright column here, Quicksort is quite a bit faster than Mergesort.<br>
distinguishes|sentence cnt : 1 <br> <br>1. Going from a to b you turn left to get to c in the first case and you goright to get to c in the second case and we want to do a computation thatdistinguishes this.<br>
same|sentence cnt : 156 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>3. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>4. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>5. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>6. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>7. So, that value stays the same.<br><br>8. So, this has got the same amount of information.<br>
years|sentence cnt : 16 <br> <br>1. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>2. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>3. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>4. Otherwise, the year, years must be equalso we have to look at the months to do the compare and so forth down to do the days.<br><br>5. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br><br>6. Now,years after, we have to deploy our software and be extremely difficult oneveryone.<br><br>7. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>8. That's another one like merging in place, that you'd think there ought to be an easy way to do it, but in 50 years, no one's really discovered one.<br>
percolation|sentence cnt : 5 <br> <br>1. So, the one we're going totalk about now is called percolation.<br><br>2. So, we have an assignment whereyou need to generate a random open sites in a percolation system.<br><br>3.That's just a few examples of the percolation model.<br><br>4. And that's where we get the result that, by runningenough simulations for a big-enough n, that this, percolation threshold is about.<br><br>5. So the percolation model onthe left corresponds to the, connection model on the right, according to whatwe've been doing.<br>
abstraction|sentence cnt : 11 <br> <br>1. And also the associative arrayabstraction is the put() method will overwrite an oldvalue with a new value.<br><br>2. So those are the basic operationsthat we're going to want to implement to get the associative arrayabstraction and then there's many, many possibilities for clients andwe'll look at some later on.<br><br>3. So, with the priority queue abstraction that'snot too difficult to do.<br><br>4. So the way that it's convenient to set up a symbol table is to implement theso-called Associative array abstraction.<br><br>5. Soit's a little exercise in abstraction.<br><br>6. That's the associative array abstraction.<br><br>7. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>8. So those are just a couple of examples, this is a very fundamental andbasic abstraction.<br>
following|sentence cnt : 4 <br> <br>1. So, just following those threecases, I see t hat this correspondence is going to work.<br><br>2. So we want to support the followingoperations.<br><br>3. The idea behind symbol tables is toimplement the following abstraction.<br><br>4. That following off that nulllink and again, we'll just, for G, travel down the tree until we come to the, nulllink.<br>
resizing|sentence cnt : 21 <br> <br>1. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>2. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>3. And again, you could do this with a linked list or withthe resizing array but then, with array, you'd have to move all the larger ones overone position to fit the new item in.<br><br>4. Any uses of the resizing array,so many of the principles that we consider does also a, a link list interface.<br><br>5. We might have to use resizing to make the array grow.<br><br>6. Resizing-array implementation.<br><br>7. And the bottom line is that we can articulate anAPI for generic stacks that works for any type of data and we've got twoimplementations, link list and arrays that, that performed very well for [cough]any type of data using the, the resizing or link list as we've described.<br><br>8. So array resizing doesn'thappen that often, but it's a very effective way ofimplementing the stack API with an array where the client does not have toprovide the maximum capacity of the stack.<br>
wires|sentence cnt : 2 <br> <br>1. Somethings are wires, and some things are switches that, are used to, implementmemory bits and computer logic.<br><br>2. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br>
ideas|sentence cnt : 1 <br> <br>1. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br>
problematic|sentence cnt : 2 <br> <br>1. And this is problematicbecause the union operation is too expensive.<br><br>2. On the other hand, in a dynamic situationwhere there are a lot of inserts, this method is going to be problematic,because the cost of its insert is linear.<br>
detail|sentence cnt : 43 <br> <br>1. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>2. For detailed information ona performance, eval grievance.<br><br>3. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>4. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>5. Let's look at the Java implementation and then we'll look in moredetail at, at that quantitative information.<br><br>6.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>7. Wewill provide much more detail information on that as we get into the assignments.<br><br>8. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br>
observations|sentence cnt : 3 <br> <br>1. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br><br>2. Now the first, and really one of the mostcritical observations, is that search in a red-black BST is exactly the same as foran elementary BST, we just ignore the color.<br><br>3.And those observations give us the lower bound.<br>
printer|sentence cnt : 1 <br> <br>1. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br>
attention|sentence cnt : 2 <br> <br>1. We have onestudent who was paying attention to what we're saying and uses an array and canpick the indices into that array at random check whether they're open and, andrepeat.<br><br>2. Now there's a few rules and there's naturalrules but they're worth talking about and paying attention to that the compareTo()method has to implement in the so called a total order.<br>
rhythmic|sentence cnt : 1 <br> <br>1. So, the bottom line is that the sweep linealgorithm takes this rectangle intersection problem and reduces it to 1Dinterval search and we have an efficient algorithm for that problem and thatenables us to solve the problem in linear rhythmic time instead of quadratic time.<br>
resolution|sentence cnt : 11 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. And then, theresolution.<br><br>3. And so we have twophases, we have prediction and resolution.<br><br>4. That's our first collision resolution method, hashing with separatechaining.<br><br>5. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>6.Another popular closure resolution methodis known as linear probing.<br><br>7. So we'll look at hash functions,separate chaining and then two collision resolution methods called separatechaining and linear probing.<br><br>8. We're going to get the situation where twovalues hash to the same array index and we need a collision resolution strategy totry to figure out what to do in that case.<br>
pushed|sentence cnt : 2 <br> <br>1. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>2. The terminology that we use ispushed to in certain items and pop to remove the itemmost recently added.<br>
update|sentence cnt : 17 <br> <br>1. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>2. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>3. It's closer, sowe update 3 to be our new champion.<br><br>4. And we just say, we're going to update everything every dt seconds.<br><br>5. And then we just update that value.<br><br>6. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br><br>7. And also, we have to update the count, something happened down below, and we use that code to update the counts in a consistent way.<br><br>8. And again, update all the counts after the recursive calls.<br>
original|sentence cnt : 8 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>3. Well in his original paper in 1961 Hoare gave a solution to the selectionproblem based on partitioning.<br><br>4. Shell's original idea is to try powers to two minus one andthat works okay.<br><br>5. Now, once that's done, what we'll want todo is copy back to the original array to get it insorted order.<br><br>6. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>7. It might moveitems past some equal item and leave a result where items that are equal or indifferent order than they were originally in the file.<br><br>8. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br>
messes|sentence cnt : 1 <br> <br>1. The problem is that when we do that, it messes up the sort by name andthat's annoying.<br>
amazingly|sentence cnt : 3 <br> <br>1. We had one line of code to flatten the tree, amazingly.<br><br>2. Really amazingly simple and efficient algorithm.<br><br>3. The implementation is amazingly simple.<br>
predict|sentence cnt : 13 <br> <br>1. There's do this prediction for every one of the particles.<br><br>2. And so we have twophases, we have prediction and resolution.<br><br>3. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>4.Now, all collisions are, might not happen so we might have two particles that are ona collision course that and we're going to predict that point for both of thoseparticles, you know, even right at the beginning.<br><br>5. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>6. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br><br>7. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>8. So, we have to do collision prediction, which is givenposition, velocity, and radius when's it going to hit with another particle or, orthe wall.<br>
vulnerable|sentence cnt : 1 <br> <br>1. And so, you can just run that program and if thesort doesn't use randomness then it's vulnerable to this attack.<br>
descending|sentence cnt : 3 <br> <br>1. On the other hand,if the array is in descending order and has no duplicates,then every element goes all the way back.<br><br>2. Interesting to think just, justabout this case and to prove to yourself that it's always going to be perfectlybalanced when it's descending.<br><br>3. And what about descending order.<br>
parts|sentence cnt : 5 <br> <br>1. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br><br>2. And so that idea of getting closer andcloser to the query point is going to cut out different parts ofthe tree as we process.<br><br>3.Once we have it arranged in that way, then we recursively sort the two parts.<br><br>4. So what we want to do is get the array into threeparts so then now we have two pointers into the middle.<br><br>5. So arbitrarily our first point,we're going to divide the plane into two parts basedon a vertical line through that point.<br>
maybe|sentence cnt : 71 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>3. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>4. Maybe the value in a parallel array.<br><br>5. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>6. Maybe the way yourcomputer's memory is organized make a difference.<br><br>7. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br><br>8. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br>
graph|sentence cnt : 12 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>2.And as this graphic integrates, it just does it by saving the information on astack.<br><br>3. We'll see later Kruskal's minimum spanning treealgorithm, which is a graph processing algorithm which uses Union-find as asubroutine.<br><br>4.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br><br>5. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>6. Again, it's not too good to use the firstthree digits because they're associated with some geographic region andit's better to use the last three digits.<br><br>7. So this is just a graphical representationif we want to compute D of N we want to computeD of N over 2 twice.<br><br>8. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br>
generating|sentence cnt : 1 <br> <br>1. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br>
correctness|sentence cnt : 1 <br> <br>1. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br>
therefore|sentence cnt : 9 <br> <br>1. We compare that with seventeen andtherefore go left.<br><br>2. But if the maxendpoint in the left sub-tree is less than low, that means every interval in the leftsub-tree has a max endpoint less than mah, low, and so therefore it can't intersect.<br><br>3. But we don't to look at the leftsubtree of e because all of those are less than e and therefore are less than f.<br><br>4. And then that means that C-s got tobe less than A if it is in the right, so therefore there can't be any interesectionin the right either.<br><br>5. Take time proportional to N forevery operation, and therefore quadratic time for everything.<br><br>6. Well, it mightbe E but there's no way it's to the left of E because those keys are all smallerthan E and therefore smaller than G.<br><br>7. So,equal items never move past each other in this code so therefore insertion sort isstable.<br><br>8. So therefore, the answer is E.<br>
divide|sentence cnt : 27 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. It's called divide and conquer.<br><br>3. And all it does is divides by 2 again andthen throws out another 1.<br><br>4. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br><br>5. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>6. And then in that case, when all the keys are equal,it's going to divide at exactly in the middle.<br><br>7.Rearrange the terms, so we get n+1 cn-1 and then divided by n, n+1.<br><br>8. So let's, we have 2N over 2s and then for each one of these we have divided into Nover 4s and each one of those 4N over 4s has anextra cross for the merge of N over 4.<br>
wrappers|sentence cnt : 1 <br> <br>1. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br>
highly|sentence cnt : 2 <br> <br>1. It doesn't have this highly desirableattribute but everything would compile.<br><br>2. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br>
permutation|sentence cnt : 4 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>2. It was proved actually a long time ago even before computer implementations that if you do that, you get a uniformly random permutation and it only takes linear time.<br><br>3. That's the average number of comparisonstaken by Quicksort, and actually they for a random permutation of the elements whichis what we do with the shuffle.<br><br>4. There's actually a very easy way to rearrange an array so that the result is a uniformly random permutation, and only require linear time to get the job done.<br>
ture|sentence cnt : 159 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>3. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>4. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>5. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>6. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>7. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>8. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br>
gain|sentence cnt : 190 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>5. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>6. Then once we've exchangedit, again, we preserved our invariant.<br><br>7. Again, exactly as what would happen in a2-3 tree.<br><br>8. And you put at the end of the code whatyou think it's going to do, again in the formof an assertion.<br>
inside|sentence cnt : 8 <br> <br>1. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>2. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>3.So, any point that's inside that interval, is going to represent a horizontal linesegment that is an intersection.<br><br>4. And indeed if you just draw theline from 1 to 4, you can see the 2 inside so there is no way it could be inthe convex hull.<br><br>5. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>6. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>7. It's got two nested for loops,selection sort had two nested for loops, a test, a comparison, andan exchange inside the for loop.<br><br>8. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br>
terminate|sentence cnt : 2 <br> <br>1. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>2. And then when you get to anexternal node you just look for and so that's a, that's the all searchesterminated in external node, in other words that's just a generalization of whatwe just did.<br>
opening|sentence cnt : 1 <br> <br>1. So how do we model opening a new site? Well to open asite we just connect it to all it's adjacent open sites.<br>
examined|sentence cnt : 5 <br> <br>1. The [cough] number of nodes examined when wedo a search is the length of the search path to low plus the length of the searchpath to high to [cough] find their ranks and that's going to be time proportionalto log N.<br><br>2. So we exchange itwill lt and increment both i and lt and now where the point, where the pointershave crossed i and gt across there's nothing that we haven't examined yet.<br><br>3. In this diagram, the entries in black, are theones that are examined in order to find the minimum each time with the minimum inred.<br><br>4. And so on average, you examined Nover M squared points per square.<br><br>5. We haven't examined yet,it's children are heap ordered so it's a small heap of size three that may not beheap ordered.<br>
knowing|sentence cnt : 2 <br> <br>1. But fortunately, we can get through prettymuch everything that we're going to do in this course just knowing about this one oflay cast.<br><br>2. But it's just a little bit of arithmetic with thevelocities and positions to deal with what happens when, when how to predict when agiven particle is going to collide with another given particle knowing theirvelocity and position.<br>
decided|sentence cnt : 2 <br> <br>1. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>2. And so what they decided in the first implementationwas let's just look at every eighth or ninth character, and that way, we don'thave to spend a lot of time computing the hash function.<br>
falls|sentence cnt : 1 <br> <br>1. They donot intersect, so now, what are we gonna do next? Well we're gonna compare the leftsub-tree, and it's Not, 22 falls within our interval so it's not less than'r' sothere might be an intersection there so we better go to the left, so we do go to theleft.<br>
demo|sentence cnt : 35 <br> <br>1. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>2. So let's look ata demo of how it looks.<br><br>3. So, let's just take a look at what happens with a real heap with the demo when we do these things.<br><br>4. Let's look at, Well it's a demo.<br><br>5.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>6. So here's abinary search tree let's do a demo of what different searches will look like in thistree.<br><br>7. Let's look at a demo of insertion sort.<br><br>8. So that's a short demo of linear probing hashing.<br>
illustrated|sentence cnt : 1 <br> <br>1. So forexample in this example with our ten objects the idea array that describes thesituation after seven connections is illustrated in the middle of the slide.<br>
cutoff|sentence cnt : 1 <br> <br>1. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br>
roots|sentence cnt : 8 <br> <br>1. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>2. If K is lessthan the key, it roots i n the left subtree.<br><br>3. And then the union operation is simply find the two roots Iand then set the idea the first one could be the second one.<br><br>4. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br><br>5.Now, once we can calculate these roots, then we can implement the find operationjust by checking whether the two items that we're supposed to check with areconnective where they have the same root.<br><br>6.That's the only time the height of a 2-3 tree changes, when the roots splits theheight introduces increases by one.<br><br>7. That's equivalent to saying, are they inthe same connective component? So that's some work, going to find the roots of eachitem but the union operation is very easy.<br><br>8. Algorithms arealso interesting to study, because they, they have ancient roots.<br>
rough|sentence cnt : 111 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>3. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>4. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>5. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>6. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>7. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>8. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br>
splitting|sentence cnt : 13 <br> <br>1. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>2. because there could be nopoint on the right subtree, on the right of this splitting line,that's closer to the query point than 3.<br><br>3. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br><br>4. That does not contain point 3 butnow which sub-tree do we search? [COUGH]In this case, now the rectangle intersects our splitting line, so we have to searchboth sub-trees, both above and below.<br><br>5. So now we'll search the leftsubtree of 4 first because the query point is to the leftof that splitting line.<br><br>6.Now, you, you can see this next insertion is going to cause some splitting whereverit is.<br><br>7. So as I've mentioned and this diagramshows, the splitting of 4-node and a 2-3 tree is a local transformation.<br><br>8.Reading all the strings on an input stream, on standard input,and, splitting em by blank space and putting em into array, sonow all the words, are, in the an array.<br>
extremely|sentence cnt : 20 <br> <br>1. The average case, which is extremelylikely for any practical application, is going to be about 1.<br><br>2. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>3.39 log N and that's probabilistic ifthey are in random order, its extremely likely to be there.<br><br>4. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>5. And also in all different typesof scientific data processing, these things are extremely important.<br><br>6. This is historically, an extremely, important problem.<br><br>7. A fundamental andextremely important data type that have led to all kinds offascinating implementations and we're going to look at severalof them in this course.<br><br>8. It's extremely easy to codeup as you can see from this code.<br>
touched|sentence cnt : 3 <br> <br>1. Number of items that have to be touchedduring quick sort.<br><br>2. Entries in gray are not touched, they're in their final position.<br><br>3. This is just anothertrace without the data-structure shown, to just show in our standard way, theelements in black and red are the ones that are touched and the elements in greyare the ones that are not touched at all.<br>
roles|sentence cnt : 1 <br> <br>1. Now, the keys and the values caninterchange roles that's why we have the abstruction to separate them.<br>
limit|sentence cnt : 8 <br> <br>1. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>2.And then it calls the recursive method that takes as arguments the limits of thesubarray that's gonna be sorted.<br><br>3. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>4. And then we also look for a lower bound which is a limit on the costguarantee of all algorithms.<br><br>5. If there were no timelimit computation at all, then I'll just hash everything to the sameplace and then do sequential search.<br><br>6. If we had no limitation on space at all,then we can have a very huge array with space for every possible key andjust use the key itself as an index.<br><br>7. And they had a complex error recovery process that,that got triggered if the height limit got too big.<br><br>8. So what hashing is kind of inthe real word where we're trying to tradeoff this idea that wedon't have unlimited space and we also don't unlimited time sowe're trying to find something in-between.<br>
fine|sentence cnt : 59 <br> <br>1.And then we do the comparisons as, as before and that, and that's all fine.<br><br>2. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. Andthat's a very useful thing because otherwise, we might try to define such analgorithm.<br><br>5. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>6. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>7. And if you're familiar with it, fine.<br><br>8.And okay, that's fine and you're going to see that when you do compiles using codelike these.<br>
endpoint|sentence cnt : 16 <br> <br>1. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>2. So left subtreeis [inaudible] right, okay? Otherwise, we have to check whether the max endpoint inthe left subtree is less than, the low point in our interval.<br><br>3. In this case wehit the right endpoint of line segment two.<br><br>4. But we're gonna store the, largest endpoint inthe subtree rooted at that node.<br><br>5. So at the root, the maximum endpoint orthe rightmost point covered by an interval, is 24.<br><br>6. Well we're going to hit the leftendpoint first, and so what we'll do when we hit the left, endpoint is, insert, they coordinate of that line into a binary search tree.<br><br>7. So, the insertion time might belinear, but then you can use binary search, to look for the two endpoints,that's only going to take time proportional to log in.<br><br>8. But if the maxendpoint in the left sub-tree is less than low, that means every interval in the leftsub-tree has a max endpoint less than mah, low, and so therefore it can't intersect.<br>
circuits|sentence cnt : 1 <br> <br>1. So, we get to use the faster and bigger computer to build faster and biggercircuits but that doesn't help if you're using a quadratic algorithm.<br>
architect|sentence cnt : 2 <br> <br>1. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>2. That's going to be the overall architecture forstudying algorithms that we're going to use throughout the course.<br>
used|sentence cnt : 65 <br> <br>1. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>2. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>3. This paper was veryinfluential and, and that basic method is widely used.<br><br>4. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>5. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>6. So again this time, sort of timing is whyQuicksort is so widely used.<br><br>7. And the first rule of the game that we have to thinkabout is, how can we make it so that we can implement one sort program that can beused by these three different clients to implement three different types of data.<br><br>8. Quicksortactually, they're up until the 1990s the most widely used implementation tookquadratic time.<br>
assume|sentence cnt : 13 <br> <br>1. And again, to keep the code simplewe're going to assume that all the coordinates are distinct.<br><br>2. The problem, the real problem is that when youdo that you can't know much about the performance or you can't assume much aboutthe performance.<br><br>3. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>4. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>5. So we assume that is connectedto is an equivalence relation.<br><br>6. You might assume that once you have it sorted by name, then whenyou sorted by the second field then it should maintain the sort of by name forall that have equal keys in that second field.<br><br>7. We'll assume that is a starting point.<br><br>8. It, you don't have to assumeanything.<br>
tiny|sentence cnt : 5 <br> <br>1. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>2. So in this case,tinyTale.<br><br>3. Even Quicksort has more overhead than youwant for a tiny array, like one of size two or three or four.<br><br>4. First thing is that Mergesort is toocomplicated to use for tiny arrays.<br><br>5. So that's a fine implementation ifthe priority queue was going to be tiny all the time.<br>
logarithm|sentence cnt : 17 <br> <br>1. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>2. And so that's the st ory of red-black BST's guaranteedlogarithmic performance for all symbol table operations.<br><br>3.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>4. What we're going to look at next time called the Red-Black Binary Search Tree will guarantee logarithmic performance for all operations.<br><br>5. So in typical cases, the runningtime of nearest neighbor search in a 2D tree is going to beproportional to logarithmic.<br><br>6. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br><br>7. And as long as there aren't too many deletions, you can keep the search cost and deletion and insert cost to be logarithmic.<br><br>8. So, and we have to, bear inmind, as we're building our logarithms, that both the number of objects can behuge, but also, the number of operations.<br>
table|sentence cnt : 250 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. Quicksort not stable.<br><br>3. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>4. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>5.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>6.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>7. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>8. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br>
dimensions|sentence cnt : 10 <br> <br>1. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>2. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>3. Some of them very mathematical, that extend thehigher dimensions.<br><br>4. And cycle through the dimensionsof level i mod k.<br><br>5. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>6. And what's more,it expand to more dimensions.<br><br>7. And we use the same idea as for 2d trees,but instead of just cycling through horizontal vertical, we cycle throughhowever many dimensions there are.<br><br>8. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br>
pros|sentence cnt : 1 <br> <br>1. So, number of pros for search and insert's proportionalto N over M.<br>
universe|sentence cnt : 3 <br> <br>1. There's a lot of particlesout in the universe and you can't do a quadratic calculation forlarge N.<br><br>2. And people understand properties ofthe universe by doing these kinds of calculations and comparingagainst what's observed in space.<br><br>3. They might unlockthe secrets of life in the universe, and they're good for fun and profit.<br>
maintaining|sentence cnt : 3 <br> <br>1.In the, all during the partitioning process, the code is maintaining thisinvariant.<br><br>2. So, whether or not there was a new node added we don't haveto test for that this recursively takes care of the problem of maintaining thesize in every node when there's a new node inserted.<br><br>3. Our algorithms willgain efficiency by maintaining connected components and using that knowledge toefficiently answer the query that's, that they're presented with.<br>
heaps|sentence cnt : 23 <br> <br>1. And this is just adding the Heapsort line to the table.<br><br>2. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>3. And that's called Heapsort.<br><br>4. But still again, using theory as a guide maybe there's a way to decrease costs a little bit from binary heaps.<br><br>5.And that completes our treatment of sorting algorithms with the Heapsortalgorithm.<br><br>6. Let's take a demoof how Heapsort works in our example.<br><br>7.Now we're going to look at binary heaps, which is an ingenious and very simple data structure that's going to help us implement all the priority queue operations quickly.<br><br>8. [cough] Let's look at thebasic Binary Search Tree data structure with Heaps we talk about implicitrepresentation of trees with an array.<br>
sections|sentence cnt : 16 <br> <br>1. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>2. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br><br>3. Be, becausesince there's no intersections in the left sub tree high has gotta be less than C.<br><br>4. No intersection in the left means no intersections at all, sothose two cases is enough to show that this algebroid finds an intersection, ifthere is one.<br><br>5. So it's all finesorted by name and but then in order to distribute it out to the people leading itto the sections, what we want to do is sort by the second fields, sort bysection.<br><br>6. So, how are we going to be able to determinethese intersections efficiently? Now, the natural algorithm, or the naivebrute-force algorithm, is quadratic in time.<br><br>7.So now let's look at a basic geometricdata processing problem of determining intersections among a set of linesegments.<br><br>8. That's the basic idea behind the sweep linealgorithm, to find intersections in sets of horizontal and vertical lines.<br>
violates|sentence cnt : 2 <br> <br>1. Now the node at the root violates the heap orders, so we have to exchange it with the largest of its two children, in this case that's R.<br><br>2. So, that's adding it at the end, violates the heap order, exchange it with the parent through smaller and keep doing until we get to a place where it's larger than it's two children, in this case S goes all the way up to the root, and then the I is all heap ordered again.<br>
clockwise|sentence cnt : 12 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. Example at the right, a to b to c is not counterclockwise.<br><br>3. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>4.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>5. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>6. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>7. Now that's essentially the proof that you have to have acounterclockwise turn.<br><br>8. Sothe main part of computation that we haven't really talked about and we'llcover briefly is if we have three points, a, b and c, and you go from a to b to c,are you making a counterclockwise turn or not? So, in the example at the left, a tob to c is counterclockwise.<br>
reflect|sentence cnt : 2 <br> <br>1.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>2. And all that is, it's a mathematicalreflection of what's going on in the code.<br>
social|sentence cnt : 4 <br> <br>1.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br><br>2. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>3. Another example, Social Security numbers.<br><br>4. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
every|sentence cnt : 176 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. And the reason is that you only createa new array every time it doubles.<br><br>4. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>5. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>6. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>7. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>8. There's do this prediction for every one of the particles.<br>
organized|sentence cnt : 2 <br> <br>1. Maybe the way yourcomputer's memory is organized make a difference.<br><br>2. And that's just the way it organized.<br>
emerge|sentence cnt : 8 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>3. And then that sets up for this four loop that accomplishes themerge.<br><br>4. This kind of question plagued a lot ofpeople in this late 60's or early 70's as these types of problems emerge forcomputing applications.<br><br>5. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>6. And with just changing one value in the arraywe get the two large components emerged together.<br><br>7. So, we've got an array A and its firsthalf is sorted and its second half is sorted and the computation we need toperform is to replace that with the sorted array where those two sub-halves aremerged together.<br><br>8. And, and in our code, if the two keys areequal, it takes from the left subarray so that means that, it will always take the,if there's a two sets of equal keys, it will preserve the relative order andthat's enough to show that the merge operation is stable and then thereforeMergesort is stable.<br>
knocks|sentence cnt : 1 <br> <br>1. But it might be the case thatthere's a third particle that knocks one of those out before that thing happens andthat event would be invalidated.<br>
refer|sentence cnt : 48 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. It's always refers tosomething that's nearby something else that I just referred to.<br><br>3. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>4. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>5. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>6. You know, with reference to what weknow about 2-3 trees.<br><br>7. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>8. So, a binary search treein Java is just going to be referenced to a root node.<br>
declaration|sentence cnt : 3 <br> <br>1. So we say that we're dealing withkeys that are comparable by simply adding this extents comparable key to ourdeclaration.<br><br>2.And at the top, the class declaration we declared an angle brackets that item isthe generic type that we're going to use.<br><br>3. So, after the classdeclaration, we write implements Comparable and then we fill in the genericwith the same type because we're only going to compare dates to other dates.<br>
unsorted|sentence cnt : 4 <br> <br>1. The thing is totallyunsorted, then it gets sorted until subarrays to size four, then eight,sixteen, and 32.<br><br>2. The ideaof selection sort, is start out with a unsorted array and we'll use these playingcards as an example.<br><br>3. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br><br>4. For example, if you have a large arraywith just a few, that's sorted except for just a few unsorted elementsappended at the end, it's going to be partially sorted.<br>
intermixed|sentence cnt : 1 <br> <br>1. And since as with stack and queue operations, theseinsert and deletes might be intermixed in arbitrary ways and there might be hugenumbers of them either one of these is very attractive because they're going totake N times the number of operations.<br>
assumption|sentence cnt : 12 <br> <br>1. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>2. Somehow we're going to want the valuebe any generic type at all but the key type we have to make somenatural assumptions about them.<br><br>3. And this assumption, again, it would work.<br><br>4. This is different than for example for quicksort when we, our assumption was we're going to create randomness and we aregoing to depend on that randomness.<br><br>5. And again, if the uniform hashing assumption holds the probability that thenumber of keys within a list is within a constant factor of N over M is extremelyclose to one.<br><br>6. And actually there's differentassumptions that we'd make in our implementations dependingon the application.<br><br>7. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br><br>8. But the bottom line is that now we havetwo methods that under the uniform hashing assumption can give us constant time,search, search it insert and delete.<br>
modification|sentence cnt : 6 <br> <br>1. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>2. But otherwise, it's a simple modification ofrecursive tree search to find all the keys and it's easy to see the running time tothat is going to be proportional to the number of keys returned plus log N.<br><br>3. This is a straightforward modification to our sorts.<br><br>4. Really, it's a modification of the sweep line algorithmthat we looked at for intersecting lines.<br><br>5. Again, modification of binary searchtrees.<br><br>6. So implementing this is a simple example of linked list processing, a slightmodification of our stack and queue code.<br>
models|sentence cnt : 9 <br> <br>1. It soonbecame clear that those mathematical models were difficult to solve.<br><br>2.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>3. For algorithm design where we tryto develop mathematical models that help us understand the properties of thealgorithms that we're developing.<br><br>4. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br><br>5. Then that modelsthe hash function, then how far do they have to go to look for a place? That'scanoot's parking problem.<br><br>6. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br><br>7. So, more and more and more now a days people are developing computationalmodels, where they attempt to simulate what might be happening in nature in orderto try to better understand it.<br><br>8. In the twentieth century, math, scientistsdeveloped mathematical models to try to understand natural phenomenon.<br>
times|sentence cnt : 59 <br> <br>1. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>4. About half a million distinct ones andin that [COUGH] corpus, the word government appearsabout 25,000 times.<br><br>5. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>6. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>7. And it's a little different kind oftoo slow then for Quick Find, there's times when it could be fast, but there'salso times when it could be too slow.<br><br>8. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br>
forms|sentence cnt : 3 <br> <br>1. And itreally forms the basis for what we're going to do.<br><br>2. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>3. Infact, there's an argument for just using this implementation of Quicksort andforgetting about horse because it performs so well in so many practical situations.<br>
auditory|sentence cnt : 1 <br> <br>1. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br>
technique|sentence cnt : 8 <br> <br>1. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>2. Now we're going to look at a technique forresolving that problem.<br><br>3. Try some technique to discover one and try to saysomething about the average-case performance of Shellsort.<br><br>4.To finish up, we're going to look at therectangle intersection problem that's got important practical applications and, usesthe techniques that we've been studying so far.<br><br>5. Or using either one of those techniquesyou could just get the idea that D of N is close to Log N or you can write a programto expand the recurrence and find that.<br><br>6. Now there's a, a number of practicalimprovements that we can use to make Mergesort even more efficientthan the simple one that we've looked at and we'll take a lookof those because they're examples of techniquesthat we can use for other algorithms.<br><br>7. So the well-known technique fordoing that, called repeated doubling,is to, when the array fills up, create a new array of twice the size andcopy all the items over.<br><br>8. So these are mathematical formulas andthere's techniques for solving them and we won't go intothat.<br>
fragile|sentence cnt : 1 <br> <br>1.Now there are some things that you have to watch out for with Quicksort because theimplementation is a bit fragile and it's easy to make mistakes.<br>
interestingly|sentence cnt : 1 <br> <br>1.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br>
cache|sentence cnt : 1 <br> <br>1. And there's some better system support in Java for strings thatcache hash code means that you don't even have to compute the hash if your, yoursimple table for strings is in an inner loop.<br>
forwards|sentence cnt : 1 <br> <br>1. With the forwards tongues of the twobefore and that were blended in after.<br>
hashes|sentence cnt : 3 <br> <br>1. So X hashes to fifteen, that's empty so weput it there, M hashes to one, that's empty and we put it there.<br><br>2. P hashes tofourteen, 14's occupied, 15's also occupied, now we run off the end of thetable, and look at zero, and that's empty so we put it there.<br><br>3. L hashes to six.<br>
discrete|sentence cnt : 1 <br> <br>1. This is not a course on discretemathematics.<br>
paid|sentence cnt : 2 <br> <br>1. Every time you hit a power of 2, you takethat many array accesses, but in a sense, you've already paid forthem by putting those items on the stack.<br><br>2. And number two, that every time youresize, you've already paid for it in an amortized sense by inserting,pushing or popping.<br>
confidence|sentence cnt : 2 <br> <br>1.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>2. We can have more confidence that our priority queue operations are going to work correctly, if we know that the type of data that's on the property queue is immutable.<br>
excitement|sentence cnt : 1 <br> <br>1.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br>
tukey|sentence cnt : 3 <br> <br>1. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>2. They [cough] used what's called a method for choosingpartitioning element called Tukey's ninther.<br><br>3. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
string|sentence cnt : 79 <br> <br>1. And so, this client readsstrings from standard input.<br><br>2. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>3. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>4. This does not include the space for the strings themselves,which are owned by the client.<br><br>5. And now build asimple table that associates strings with strings.<br><br>6. As a warm up, let's suppose that wehave a string, a collection of stings.<br><br>7. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>8. String.<br>
composite|sentence cnt : 1 <br> <br>1. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
mentioned|sentence cnt : 16 <br> <br>1. And I mentioned that a lot of us would get uswrong.<br><br>2. Now,the height of the tree, as I just mentioned, is the worst case number ofcompares.<br><br>3. But we mentioned this example to illustrate how even asimple algorithmah, can have interesting and complex analysis.<br><br>4. As I mentionedthey're widely used.<br><br>5. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>6. So, as I've mentioned, redblack trees and B-trees are widely used as system symbol tables.<br><br>7. So, it's got position and velocityas I mentioned, and every ball has a, a radius.<br><br>8. So as I've mentioned and this diagramshows, the splitting of 4-node and a 2-3 tree is a local transformation.<br>
generalization|sentence cnt : 6 <br> <br>1. So the search is a natural generalizationof the search in, binary search trees.<br><br>2.And so bee trees are a generalization of.<br><br>3. And as you'll see, this is, a generalization of,two three trees.<br><br>4. And then when you get to anexternal node you just look for and so that's a, that's the all searchesterminated in external node, in other words that's just a generalization of whatwe just did.<br><br>5. And it's a simple generalization ofour line intersection problem.<br><br>6.So what we're going to talk about to do it, is an algorithm, that actually prettyold algorithm called 2-3 trees, and a particular implementation that requiresvery little code, called left leaning red black BSTs and then we'll talk about ageneralization called B-trees.<br>
mass|sentence cnt : 5 <br> <br>1. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>2. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>3. But use the center of mass andyou get a very accurate [COUGH] approximation tothe N-body doing that.<br><br>4. And each particle is a disc that's got known position, velocity, mass,and radius.<br><br>5. You have centering, where you try to point near the centerof mass of the k nearest boids.<br>
order|sentence cnt : 255 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. So the heap order condition is satisfied everywhere except at this node.<br><br>3. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>4. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>5. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>6. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>7.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>8. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br>
left|sentence cnt : 294 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>4.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>5. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>6. B and this b treewould go down the left link.<br><br>7. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>8. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br>
delay|sentence cnt : 1 <br> <br>1. Or sink and swim methods are good for making this happen, but we'll delay these implementations until we need them in a more complicated algorithm.<br>
stack|sentence cnt : 117 <br> <br>1. Stacks are familiar.<br><br>2. And plus it goes on the operator stack.<br><br>3. The client really can'tknow how big the stack is.<br><br>4. We have two different stacks.<br><br>5. Value, put in the value stack.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>8. So to begin, we will talk about stacks.<br>
application|sentence cnt : 111 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. There's lots of importantapplications for this.<br><br>3. These types of things ariseoften in practical applications.<br><br>4. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6.And in fact, in many real applications, they're not very random.<br><br>7. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>8. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br>
astounding|sentence cnt : 1 <br> <br>1. It's really an astounding example ofalgorithmic technology.<br>
invariances|sentence cnt : 1 <br> <br>1. The whole partitioning process forthree-way partitioning and the modern programming language like Java simplymaintains the invariances described in the demo.<br>
paths|sentence cnt : 3 <br> <br>1.How long can those paths be? Well, it's not hard to see that the, inthe worst case, if they're all 2-nodes, that's the longest they can be is log basetwo of N.<br><br>2.So, all the paths in a 2-3 tree with N nodes have to have length between thosetwo bounds and those are pretty small numbers.<br><br>3. It's just going to be able toanswer the question, is there a path? In part two of the course, we'll consideralgorithms that explicitly find paths.<br>
sitting|sentence cnt : 4 <br> <br>1. So, whenever we find a right link, we're sitting on aright red link we just rotate it left and return that.<br><br>2.Why is it redundant? Well, the partitioning element is sittingthere and it'll stop when it hits the partitioning element.<br><br>3. And the heap condition is only violated again where H is sitting.<br><br>4. So now, we are sitting at E.<br>
mediums|sentence cnt : 1 <br> <br>1. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
plug|sentence cnt : 3 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>3. Plugging in N log N we get the desiredresult.<br>
capitalized|sentence cnt : 1 <br> <br>1. So Integer with the capitalized rapid typefor int and so forth and many of you were probably familiar with that.<br>
display|sentence cnt : 3 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>3. So, this the is an easy programming exercise given the rightdisplay primitives.<br>
developing|sentence cnt : 9 <br> <br>1. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>2. This gets to the intellectual challenge of developingalgorithms.<br><br>3. And that's really important, because itmeans you can put them into your code to check whiledeveloping.<br><br>4. For algorithm design where we tryto develop mathematical models that help us understand the properties of thealgorithms that we're developing.<br><br>5. And the real practical challengewith hashing is that developing a hash function is that every typeof key needs a hash function and you need a different approach forevery key type.<br><br>6. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br><br>7. So, more and more and more now a days people are developing computationalmodels, where they attempt to simulate what might be happening in nature in orderto try to better understand it.<br><br>8. That's the kind of situation we're going to try to avoid bydeveloping more efficient algorithms for solving problems like this.<br>
floor|sentence cnt : 14 <br> <br>1. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>2. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>3. So now,how do we implement rank? Well, it's a little like floor.<br><br>4. So if wefind our key, that's the floor.<br><br>5. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>6. For that is C of N over 2, ceiling of Nover 2 for the left and ceiling of, floor of Nover 2 for the right.<br><br>7. So, what we want to find is so say, we're seeking the floorof G.<br><br>8. In order to get that done, we're sortingthe left half and the right half and this notation ceiling of N over 2 andfloor of N over 2 that's the N over 2 round up and N over 2 round down, that'sthe size of the two sub-arrays, and we're going to call the same routine forthat size, so the number of compares you needto.<br>
stuck|sentence cnt : 2 <br> <br>1. But we're kind of stuck.<br><br>2. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br>
summarize|sentence cnt : 5 <br> <br>1. So, let's summarize the properties ofQuicksort.<br><br>2. This, slide summarizes the code for, heap construction.<br><br>3. Sothat's the first piece of code for heap ordering an array with arbitrary valuesand then these diagrams summarize the sync calls that, that we just went through inthe demo starting at five, four, three, two, one.<br><br>4.And these diagrams summarize the sync operations that we showed in the demo.<br><br>5. So, and those are the a top is summarize the four type of thingsthat we could wind up with and what to do so the left parenthesis we've ignored, avalue we put on to the value stack.<br>
hoare|sentence cnt : 1 <br> <br>1. Well in his original paper in 1961 Hoare gave a solution to the selectionproblem based on partitioning.<br>
temporary|sentence cnt : 24 <br> <br>1. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>2. And then we did a right rotate on the top node, and that transformed to thecase where our temporary four node is balanced.<br><br>3. And the other thing that we could dois we can use null and some situations are temporary situations to implementa lazy version of the delete() operation.<br><br>4. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>5.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>6.Now, if that parent were a 3-node, it would become a temporary 4-node and wouldcontinue the process moving up the tree.<br><br>7. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>8. And specifically, the work we do is, weadd the key to a 3-node to create a temporary 4-node and then split up thatfour node and move it's middle key into the parent.<br>
plays|sentence cnt : 1 <br> <br>1. And, quicksort certainly plays a role in most systemsorts.<br>
should|sentence cnt : 40 <br> <br>1. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>2. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>3. How do we, we do not implementing the API? The API says we should justbe able to create a stack and it should be able to grow andshrink to any size.<br><br>4. And the other is that itshould be the case that every table index is equally likely foreach key.<br><br>5. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>6. And then, it's easy to seethat what you should choose is M to be about square root of N.<br><br>7. Probably should do that.<br><br>8. And so but, but they still thought that it should be balancedand it shouldn't matter much.<br>
multiple|sentence cnt : 13 <br> <br>1. But still, we're guaranteed thatthe amount of the memory that we are use is always only a constant multiple ofthe number of items actually on the stack.<br><br>2. It's possible to implement symboltables that allow multiple values with the same key and so forth.<br><br>3. The implementation could hardly be morestraightforward and it's an excellent way to solve the problem of handling multipletypes of data with one implementation.<br><br>4.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br><br>5.It's cumbersome to maintain multiple node types.<br><br>6. Which one is better? In many situations, we're going tohave multiple implementations of APIs, and depending on propertiesof the client program, we're going to have to choose whichone is the better one to use.<br><br>7. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br><br>8. And you can go ahead and extend thisalgorithm to add functions like logs and sines or other operators and haveprecedence among operators, have them associate and multiple operations, and soforth.<br>
implications|sentence cnt : 1 <br> <br>1. And you can think about the implications of that.<br>
costing|sentence cnt : 1 <br> <br>1. Costing involving in the ray axises justto do the find operation and that's going to be too slow if you have a lot ofoperations.<br>
describes|sentence cnt : 4 <br> <br>1. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>2. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>3. So forexample in this example with our ten objects the idea array that describes thesituation after seven connections is illustrated in the middle of the slide.<br><br>4.So this is a mathematical formula that we derive by examining the code but itcompletely describes mathematically what we an upper bound on the number ofcompares that are going to be needed.<br>
originally|sentence cnt : 1 <br> <br>1. It might moveitems past some equal item and leave a result where items that are equal or indifferent order than they were originally in the file.<br>
expresses|sentence cnt : 1 <br> <br>1. So this is a simpler, narrowerAPI but still it expresses an important little collection of operations and, andwe'll use this one and we've already seen the implementations.<br>
pollen|sentence cnt : 2 <br> <br>1. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>2. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br>
exchanges|sentence cnt : 21 <br> <br>1. So, with just two exchanges we insert that new element into the heap in this case.<br><br>2. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>3. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>4. And so we'll do a sync on the S and bring it into a heap ordering, sothat's with just a few exchanges we got that whole array heap order, and now whatwe want to do is take advantage of the heap ordering in the array to do a sort.<br><br>5. Sonow R exchanges with M.<br><br>6. And another property is that youcan't sort moving less data because selection sort does just a linear numberof exchanges.<br><br>7.Selections or uses about N^2 / 2 compares and exactly n exchanges.<br><br>8. In the second case,it's slower than selection sort, because it uses about the same number ofcompares, but it uses many more exchanges.<br>
extreme|sentence cnt : 21 <br> <br>1. The average case, which is extremelylikely for any practical application, is going to be about 1.<br><br>2. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>3.39 log N and that's probabilistic ifthey are in random order, its extremely likely to be there.<br><br>4. [cough]They're, they're going to be extreme points on the convex hull.<br><br>5. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>6. And also in all different typesof scientific data processing, these things are extremely important.<br><br>7. This is historically, an extremely, important problem.<br><br>8. A fundamental andextremely important data type that have led to all kinds offascinating implementations and we're going to look at severalof them in this course.<br>
image|sentence cnt : 1 <br> <br>1. Down atthe bottom is one of those important one is in image processing for understandinghow to label areas in images.<br>
biggest|sentence cnt : 4 <br> <br>1. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>2. And that's going to happen in the casewhere the biggest element in the first half is less or equal to thesmallest item in the second half.<br><br>3. But we're interested in the biggest ones andso maybe it's the biggest amount of dollars, or the biggest cost, or whateverit might happen to be.<br><br>4. I wouldlike to, to store the, the thousand biggest ones.<br>
environment|sentence cnt : 5 <br> <br>1.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>2. So, that's true in many programming environments.<br><br>3. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>4. And you can test this out for different types of environments easily andit's representative.<br><br>5. Well, firstthing that we might that we might consider and actually we're forced to consider thisone in lots of programming environment, is to implement a separate stack class foreach type of data that we're using.<br>
worth|sentence cnt : 25 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>3. But for many practical applications, they're easy to implement and worth using.<br><br>4. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>5. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>6. It's certainly worth adding them.<br><br>7. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>8. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br>
becoming|sentence cnt : 1 <br> <br>1. And as you watch it go for a while, you can see that this thing about going to the right and taking the successor all the time, the trees becoming much less balanced that it was.<br>
compiling|sentence cnt : 1 <br> <br>1. One, having to deal with compiling from aprogramming language or interpreting into an actual computation and then the otherone is the PostScript language which is widely used for, for printing andpublishing.<br>
ninth|sentence cnt : 3 <br> <br>1. They [cough] used what's called a method for choosingpartitioning element called Tukey's ninther.<br><br>2. And so what they decided in the first implementationwas let's just look at every eighth or ninth character, and that way, we don'thave to spend a lot of time computing the hash function.<br><br>3. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
switching|sentence cnt : 1 <br> <br>1. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br>
topic|sentence cnt : 5 <br> <br>1. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br><br>2. These are the basic topicsthat we'll cover in part one and part two of the course.<br><br>3. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br><br>4. And you better use a good shuffling code, that's our topic.<br><br>5. What if we want to havequeues and stacks of other types of data? And that brings us to the topic ofgenerics.<br>
redraw|sentence cnt : 3 <br> <br>1. And then,also we're going to put as the first thing that happened always a, an event that saysredraw everything.<br><br>2. It's either redraw, bounce, B of A or, or bounce off avertical wall or, or a horizontal wall.<br><br>3. And if both particles are null we're saying wejust want to redraw things.<br>
indexing|sentence cnt : 4 <br> <br>1. So this is a indexing clientwhere we associate each string with its most recentposition in the input.<br><br>2.Here's another simple client program forsymbol tables related to indexing.<br><br>3. This is a simple indexing clientthat we use for our traces.<br><br>4. So again, our symbol table API gives a very easy wayto implement this file indexing function,which is very widely useful.<br>
easier|sentence cnt : 8 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>2.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>3. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>4. So, you could do it but we're not going tobecause there's a much easier way.<br><br>5. You could implement this bybuilding explicit links but the an easier thing to do is to know that every node isreferenced by just one link in a tree the one from it's parent.<br><br>6. Itjust makes the implementation a little bit easier and that's the way it's usuallydone.<br><br>7. You could use an extra array and thepartitioning code would be a little bit easier.<br><br>8. This isreally one of the rules of the game but it's much easier to talk about in thecontext of the real algorithms that we've seen so far.<br>
sustain|sentence cnt : 1 <br> <br>1. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br>
larger|sentence cnt : 46 <br> <br>1. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>2. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>3. We figure out which of the children is larger.<br><br>4. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>5. And so, it's larger than, it's bothchildren, and the larger of the two children is T, so we promote the T.<br><br>6. So in this case, we have an example where T, the node T here its value changes and it becomes larger than its parent key, P.<br><br>7. To put it in sorted order, we have to movefrom right to left, exchanging it with every larger elements to its left, andthat's what the code at the bottom does.<br><br>8. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br>
running|sentence cnt : 27 <br> <br>1. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>2. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br><br>3. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br><br>4. So, the analysis now says thatthe average running time per operation forwhatever the sequence of operations is, the average running time is going tobe proportional to a constant.<br><br>5. So that's the running time Mergesort isfast other thing that we usually want to knowis memory.<br><br>6. So in typical cases, the runningtime of nearest neighbor search in a 2D tree is going to beproportional to logarithmic.<br><br>7. So, that's N^2 or quadraticrunning time.<br><br>8. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br>
trouble|sentence cnt : 4 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. Butinexperienced programmers often have trouble with it.<br><br>3. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br><br>4. Now, these are the things thathave to be proven and we're not going to get into the details of geometric proofbut they're intuitive and certainly have no trouble accepting that these things aretrue.<br>
shorthand|sentence cnt : 1 <br> <br>1. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br>
changes|sentence cnt : 28 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>2. So, with just two exchanges we insert that new element into the heap in this case.<br><br>3. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>4. So in this case, we have an example where T, the node T here its value changes and it becomes larger than its parent key, P.<br><br>5. And then the last one changesthe value at E, again, 12.<br><br>6. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>7. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>8. And so we'll do a sync on the S and bring it into a heap ordering, sothat's with just a few exchanges we got that whole array heap order, and now whatwe want to do is take advantage of the heap ordering in the array to do a sort.<br>
hundreds|sentence cnt : 4 <br> <br>1. We have hundreds of different implementations.<br><br>2. And what if we have hundreds of different types of data that we'reprocessing.<br><br>3. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>4. But you could see that even for this case which is hundreds of keys,the length of the path from top to bottom is not so much.<br>
optimized|sentence cnt : 1 <br> <br>1.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br>
violating|sentence cnt : 1 <br> <br>1. And we exchange that one with the one that's violating the condition.<br>
compiler|sentence cnt : 2 <br> <br>1. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>2. So, so the way the compilers implement functions is using stacks.<br>
height|sentence cnt : 24 <br> <br>1. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>2.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>3. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br><br>4. So, this three has to have at least N factorial leaves and ifthe three of height h, it has utmost two^h leaves.<br><br>5. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>6. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>7.And then the height of the tree grows by one.<br><br>8. Now,the height of the tree, as I just mentioned, is the worst case number ofcompares.<br>
subtext|sentence cnt : 1 <br> <br>1. The subtext of today's lecture really is to go through the stepsthat we'll follow over and over again to develop a useful algorithm.<br>
separate|sentence cnt : 18 <br> <br>1. And so the first way we'll look at is called Separate Chainingand it's a very diagonal idea back1953, and the idea is just build a link list foreach of the table positions.<br><br>2. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>3.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>4. That's our first collision resolution method, hashing with separatechaining.<br><br>5. The idea is to completely separatethe interface and the implementation.<br><br>6. And in general, a CSVfile might have many fields separated by comma, comma.<br><br>7. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>8. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br>
acids|sentence cnt : 2 <br> <br>1.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br><br>2. And certain codons have names, that's theamino acids.<br>
drawing|sentence cnt : 5 <br> <br>1. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>2. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>3. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>4. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>5. And, there werevarious rules about what you can do on these drawings.<br>
mathematicians|sentence cnt : 2 <br> <br>1. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>2. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br>
inserted|sentence cnt : 11 <br> <br>1. So, it goes down to the middle, and windsup needing to be inserted in the, 3-node in the middle.<br><br>2. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br><br>3. Now, if the, the keys are inserted inrandom order, we know that height by analysis, is going to be proportional tolog N.<br><br>4. Now, we have to look at the third case, which is, when it's, thenew node inserted this in between and comes out of this link here.<br><br>5. It also has been shown actuallynot that long ago, that the expected height of the tree if they're inserted inrandom order, the height that's the worst case length of a path in the tree.<br><br>6. Each point has to be inserted, deleted.<br><br>7. Now, K is inserted into the 2-3 tree andit satisfies all the rules.<br><br>8. So, whether or not there was a new node added we don't haveto test for that this recursively takes care of the problem of maintaining thesize in every node when there's a new node inserted.<br>
adds|sentence cnt : 4 <br> <br>1. Sothat, that means you'd have, if you did exactly and [inaudible] + n/2 + n/4 and soforth which adds up to about two N compare so linear cross.<br><br>2. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>3. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>4. And the move method again,most of the times, just takes the x and y coordinates and adds the current velocitytimes the speed constant.<br>
mechanically|sentence cnt : 1 <br> <br>1. Well, there'sactually a way to compute the convex hull just mechanically if you put the nailsaround the points and put a rubber band around it, that gives you the convex hull.<br>
absolutely|sentence cnt : 2 <br> <br>1. And this is absolutely a fine methodthat is not that difficult to implement, in the case that the pointsare evenly distributed.<br><br>2. We're having a efficient sortas absolutely crucial.<br>
flight|sentence cnt : 1 <br> <br>1. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
treatment|sentence cnt : 2 <br> <br>1.And that completes our treatment of sorting algorithms with the Heapsortalgorithm.<br><br>2. So that, that, that'sour full summary of sorting algorithms to and completes our treatment of sortingalgorithms with Heapsort.<br>
publishes|sentence cnt : 1 <br> <br>1. For example Java publishesits hash function.<br>
partially|sentence cnt : 12 <br> <br>1. Now, if the array is partiallysorted, it doesn't matter to selection sort.<br><br>2. And that has to do with whenthe array is partially sorted.<br><br>3. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>4. Here's a partially sorted array, and you can see that insertion sortquickly gets the job done.<br><br>5. And partially sorted arraysappear often in practice.<br><br>6. And what's interesting about insertionsort is that it runs in linear time for partially sorted arrays.<br><br>7.If it's partially sorted it doesn't make much difference - does the higher sorts alittle bit faster.<br><br>8. But the other thing is if the increments are small because we'vedone previous h-sorts for bigger values of h, the array is partially sortedand so Insertions Sort is going to be fast.<br>
hardly|sentence cnt : 3 <br> <br>1. Could, could hardly be simpler.<br><br>2. Could hardly besimpler.<br><br>3. The implementation could hardly be morestraightforward and it's an excellent way to solve the problem of handling multipletypes of data with one implementation.<br>
heapsort|sentence cnt : 15 <br> <br>1. And this is just adding the Heapsort line to the table.<br><br>2. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>3. And that's called Heapsort.<br><br>4.And that completes our treatment of sorting algorithms with the Heapsortalgorithm.<br><br>5. Let's take a demoof how Heapsort works in our example.<br><br>6. So that, that, that'sour full summary of sorting algorithms to and completes our treatment of sortingalgorithms with Heapsort.<br><br>7. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br><br>8. That's quicksort, mergesort, heapsort and radix sorts.<br>
guess|sentence cnt : 1 <br> <br>1. Duplicate keys, we may notneed N log N compares, we're going to look at the method that I guess that down inlinear time and a lot of situations.<br>
understanding|sentence cnt : 11 <br> <br>1. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>2. And why is it true that the depth ofany node x is, at most, log base two of N? Well, the key to understanding that is to,take a look at exactly when does the depth of any node increase? When does it go downfurther in the tree? Well.<br><br>3. There's algorithms in physics for understanding physical phenomenon thatwe'll look at an example and many others on this list.<br><br>4. Down atthe bottom is one of those important one is in image processing for understandinghow to label areas in images.<br><br>5. So there is going tobe situations that are going to require an understanding of what it takes to engineera, a sort method that's appropriate for your application.<br><br>6. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br><br>7. Another reason nowadays to studyalgorithms is that, they have become a common language for understanding, nature.<br><br>8. And the idea is we're going to use Insertion Sortbecause of two reasons based on our understanding of how Insertion Sort works.<br>
stop|sentence cnt : 21 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>3. When we get our second A, we stopthe sort as long as we're not less.<br><br>4.Stop here at t cuz that's bigger.<br><br>5. But this general purpose implementationstops the pointers on keys equal to the partitioning items key and we'll take alook at why that's important in a minute.<br><br>6.Stop her at I because that's less.<br><br>7.Okay? And that's the legal of 2-3 trees, So we stop inserting A into that.<br><br>8. We're equal, we're not less, we stop it so wenever move an equal item pass another one.<br>
poorly|sentence cnt : 1 <br> <br>1. And you'll sometimes see Mergesortperforming poorly because of that bug.<br>
principle|sentence cnt : 4 <br> <br>1. Any uses of the resizing array,so many of the principles that we consider does also a, a link list interface.<br><br>2. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br><br>3. That's an extremely importantprinciple in designing good algorithms.<br><br>4. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
depicted|sentence cnt : 1 <br> <br>1. We aregoing to think of that array as representing a set of trees that's calleda forest as depicted at right.<br>
inter|sentence cnt : 242 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So, one thing is we're usinga different key interface.<br><br>3. This is called intervalsearch.<br><br>4. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>5. And now 2123 does intersect 1622, so wereturn and intersection.<br><br>6. Any interval thatintersects this query interval 23 25.<br><br>7. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>8. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br>
quantitative|sentence cnt : 2 <br> <br>1. Let's look at the Java implementation and then we'll look in moredetail at, at that quantitative information.<br><br>2. To talk about this in a quantitative way,we define what's called an inversion.<br>
collecting|sentence cnt : 1 <br> <br>1. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br>
assertions|sentence cnt : 3 <br> <br>1. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>2.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>3. Now the thing about assertions in Java is that you can enable or disable them atruntime.<br>
with|sentence cnt : 561 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>3. So we're done with 4, and we come to 3.<br><br>4. And you're familiar with this.<br><br>5. And how close it could get to full withoutsacrificing performance.<br><br>6. And if it does, print the value associated with the key.<br><br>7. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>8. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br>
tradeoffs|sentence cnt : 2 <br> <br>1. So even with these simple data structures,we have really important tradeoffs that actually make a differencein lots of practical situations.<br><br>2. So, what are the tradeoffs between usinga resizing array versus a linked list? Those are two differentimplementations of the same API, and the client can usethem interchangeably.<br>
trick|sentence cnt : 9 <br> <br>1. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>2. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>3. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br><br>4. So, that's a, a implementation that, that code isdefinitely tricky and a similar code for ceiling.<br><br>5.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>6. Not difficult, but a definitely tricky programming exercisethat people are welcome to try.<br><br>7. And the trick is that onceyou get past the capacity, you have to reset back to zero.<br><br>8. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br>
stolen|sentence cnt : 2 <br> <br>1. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>2. Maybe, you runa credit card company and you want to check for stolen cards then your keyswould be numbers.<br>
independently|sentence cnt : 1 <br> <br>1. InQuicksort partitioning, after the random shuffling we have the partitioning elementand then we process everybody to the left independently of everybody to the right.<br>
callback|sentence cnt : 4 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>2. There's a lot of different ways toimplement callbacks and that's programming language specific.<br><br>3.In the way that, that happens is a mechanism known as a callback.<br><br>4. So, that'sour basic question, how can sort, now, how to compare data of all those differenttypes without being given any information about the type of an item's key? And theanswer is that what is we set up a mechanism known as a callback or referenceto executable code where the client, by passing an array of objects to the sortfunction.<br>
tall|sentence cnt : 15 <br> <br>1. And so all that says is thatall the objects are independent.<br><br>2. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>3. Still has to go through, even ifit's totally sorted, still has to go through to the side where that minimumelement is.<br><br>4. Now,that's not quite as good as totally flattening actually in practice that itactually is just about as good.<br><br>5. The thing is totallyunsorted, then it gets sorted until subarrays to size four, then eight,sixteen, and 32.<br><br>6. The idea is to when implementing the quick union algorithmtake steps to avoid having tall trees.<br><br>7. The only, the, the tree that hasthe most leaves of height h is totally complete and that one has two^h leaves.<br><br>8. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
nulling|sentence cnt : 1 <br> <br>1. Now, in this case, to implement delete max we save away that value at the root in max, and we eliminate loitering by nulling out that vacated position, then return the max value.<br>
alternates|sentence cnt : 1 <br> <br>1. The worse that can happen is that it alternates redand black.<br>
abstractions|sentence cnt : 1 <br> <br>1. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br>
clever|sentence cnt : 2 <br> <br>1.Next we're going to look at the use of thebinary heap data structure to implement a clever sorting algorithm known asHeapsort.<br><br>2. With the clever data structure and interesting implementationwe can actually achieve that goal.<br>
linked|sentence cnt : 33 <br> <br>1. And to implement a stack when we do a push operation, we insert a new node atthe beginning of the linked list.<br><br>2. If I want that guarantee, if I want to besure that every operation's going to be fast, I'll use a linked list.<br><br>3. And again, you could do this with a linked list or withthe resizing array but then, with array, you'd have to move all the larger ones overone position to fit the new item in.<br><br>4. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>5. So we don't need so much any more generalprograms for manipulating linked-lists.<br><br>6. We use to implementlinked list in all linked data structures throughout the course, weuse what's called an inner class in Java.<br><br>7. So for linked lists, every operationtakes constant time in the worst case, that's a guarantee.<br><br>8. So lets look at how we implement those,first using linked list and then arrays.<br>
quadratic|sentence cnt : 46 <br> <br>1.So complexity's going to tell us that it's a quadratic algorithm if that's what itsworst case is.<br><br>2. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>3. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>4.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>5.And how can we do it efficiently that is in, in log N time versus quadratic time.<br><br>6. And one of the themesthat we'll go through over and over in this course is that quadratic time is muchto slow.<br><br>7. They're either connectedor not then that will take quadratic time in squared time.<br><br>8. You wouldn't work to use Shellsortas the basis for h-sorting because that always takes quadratic time no matter whatorder there is in the array.<br>
premium|sentence cnt : 1 <br> <br>1. In ancient times, memory was, at quite apremium and so people were very concerned in m-m-making sure that the hash tablenever, got too empty.<br>
alternative|sentence cnt : 3 <br> <br>1. So, how are we going to do better? Our first attempt is analternative called, Quick-union.<br><br>2. If occupied you, youreinsert the displaced key into its alternative.<br><br>3. This alternative of choosingbetween linked structures and arrays is fundamental, andit's going to come up again and again when we consider more complicateddata structures and algorithms.<br>
halfway|sentence cnt : 3 <br> <br>1. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>2. And you can see that for a large arraythat's randomly ordered, the element that we put into place is going to goabout halfway back on the average.<br><br>3. But then the very next one,the 9 has to only go back one position, and the 6 has to go about halfway back.<br>
letters|sentence cnt : 3 <br> <br>1. So, in this case, the first field is three letters from theDNA sequence which, represents a codon.<br><br>2. We might convert the letters to numbers, or we might, keysmight be numbers.<br><br>3. And this first argument is just ignorewords fewer than this many letters.<br>
lazy|sentence cnt : 3 <br> <br>1. This is so called lazy approach to algorithmdesign where we try to avoid doing work until we have to.<br><br>2. And the other thing that we could dois we can use null and some situations are temporary situations to implementa lazy version of the delete() operation.<br><br>3. So we need to fill in this one table, what's the cost of deletion in a binary search tree? How we're going to really do that? Well, let's take a look at a very lazy approach which we setup for in our basic conventions for symbol tables.<br>
partly|sentence cnt : 1 <br> <br>1. The second improvement that we can makethat'll improve the performance for cases when the array is partly sorted,is to just stop if it's already sorted.<br>
prime|sentence cnt : 5 <br> <br>1. And if M is prime,it gives us some comfort that we have some possibility of each table positionappearing with equal likelihood.<br><br>2. So we pick some othersmall prime number and for each field we multiply by 31.<br><br>3. So one thing to do is start outwith some small prime number and this kind of mimics Horner's method tojust add in more data as we get it.<br><br>4. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>5. This is just do mod M andif M is a prime then from that modular arithmetic we know that we're using allthe bits in the number in that point to.<br>
peels|sentence cnt : 1 <br> <br>1. You just peels off one key to do file size n then you get a sub file size n- one and then n - two and so forth and the result is a quadratic tim e algorithm.<br>
subarrays|sentence cnt : 11 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>3. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>4. And we have four subarrays ofsize four.<br><br>5. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>6. The thing is totallyunsorted, then it gets sorted until subarrays to size four, then eight,sixteen, and 32.<br><br>7. So, as you can see in this examplewe start out by merging the first two sub arrays of size one to make a array of sizetwo - E, M - that's sorted, and then do the same thing for the next two elements and thenext two and so forth until eventually instead of sixteen individual elements wehave eight sorted subarrays of size two.<br><br>8. One more pass makes two subarrays of size eight, and the last passis just a sorted array.<br>
ensure|sentence cnt : 1 <br> <br>1. So the challenge is to do the resizing,but somehow ensure that ithappens infrequently.<br>
designed|sentence cnt : 1 <br> <br>1. So,why not just use those? Why use our own implementations? Well, the problem isoften in such library code is kind of designed by committee phenomenon that moreand more operations get added and the API becomes too broad or bloated.<br>
strategy|sentence cnt : 6 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>3. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>4. Now what about inserting?Well, it's a similar type of strategy as with regular binary search trees, exceptthat we manipulate the two and 3-node to keep perfect balance in the tree.<br><br>5. We're going to get the situation where twovalues hash to the same array index and we need a collision resolution strategy totry to figure out what to do in that case.<br><br>6. So, that's asummary of linear probing or second hash, collision avoidance strategy.<br>
perhaps|sentence cnt : 4 <br> <br>1. But, the bottom line is, you should be able t oprogram, and the quick exercise to get ready is, to write a java program on yourcomputer perhaps using a programming model, as described on the book site.<br><br>2. Perhaps you wouldn't want to usea resizing-array implementation at the moment that your plane's coming in fora landing.<br><br>3. In continuing on the right perhaps the nextcompare is a less than c and maybe if c is less than a, then another compare, b lessthan c.<br><br>4. But for our iteration,we just have to worry about implementing next() and hasNext() and perhaps using a localinstance variable to get it done.<br>
implimintation|sentence cnt : 2 <br> <br>1. Here's the implementation of file indexusing our symbol file implimintation.<br><br>2. So just given that high level descriptionthen the implimintation is pretty direct.<br>
invalidated|sentence cnt : 2 <br> <br>1. But it might be the case thatthere's a third particle that knocks one of those out before that thing happens andthat event would be invalidated.<br><br>2. Then, we test whether that event has been invalidated.<br>
sines|sentence cnt : 2 <br> <br>1. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>2. And you can go ahead and extend thisalgorithm to add functions like logs and sines or other operators and haveprecedence among operators, have them associate and multiple operations, and soforth.<br>
mismatches|sentence cnt : 1 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br>
enqueue|sentence cnt : 7 <br> <br>1. To add a note, or enqueue,add a new note to a linked-list.<br><br>2. Traverse the left subtree enqueue the key, traverse theright subtree.<br><br>3. Instead of push we have enqueueinstead of pop we have dequeue.<br><br>4. So for enqueue, you add a new item a tail.<br><br>5. And the semantics is different, forenqueue we add an item say at the end of the queue, and for dequeue weremove an item from the beginning.<br><br>6. When you're enqueue you go at the end, and when the one that's been in therethe longest is the one that comes off.<br><br>7. Then, an insert() that putssomething in like push in a stack or enqueue in a queue.<br>
queries|sentence cnt : 6 <br> <br>1. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>2. And then processing queries is the same asbefore, as long as standard in is not empty we take aquery.<br><br>3. And this is going to be very efficientbecause as we get closer and closer to the query point, we're cuttingout all the sub queries that are away.<br><br>4. Or more generally, people want to oftenprocess, preprocess text to, maybe a huge amount oftext, to support, so called, concordancequeries.<br><br>5. And then that allows us to processqueries, where we take a query, and then get the set of indicesassociated with that query.<br><br>6. Then from standard input we take queries, just reada string, check if the symbol table contains the string.<br>
implicit|sentence cnt : 4 <br> <br>1. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>2. And then, this is just for simplicity to get this done andjust part of a lecture.<br><br>3. [cough] Let's look at thebasic Binary Search Tree data structure with Heaps we talk about implicitrepresentation of trees with an array.<br><br>4. For simplicity, we'll show the code where the client gives the capacity of the heap.<br>
oldest|sentence cnt : 1 <br> <br>1. This is one of the oldest sortingmethods invented by Shell in 1959.<br>
arrive|sentence cnt : 1 <br> <br>1. And so you can kind of immediately arrive at that performanceeven for simple clients.<br>
overwrote|sentence cnt : 1 <br> <br>1. If you have a sort method that can store anyvalues in an array, it could, for example, store zeros in every array entry thatmethod would pass this test, but it didn't really correctly sort the array becauseoverwrote all the values.<br>
bares|sentence cnt : 1 <br> <br>1. And the math bares that out.<br>
size|sentence cnt : 87 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>4. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br><br>5. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>6. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>7. For the union implementation, we're going tomodify the code to check the sizes.<br><br>8. Whatever the size,bottom of Mergesort gets the job done in log N passes.<br>
timing|sentence cnt : 1 <br> <br>1. So again this time, sort of timing is whyQuicksort is so widely used.<br>
auxiliary|sentence cnt : 15 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>3. That is, we need that extra auxiliaryarray for the last merge.<br><br>4. Now, it's important to not create theauxiliary array in the re in the recursive routine because that couldlead to extensive cost of extra array creation.<br><br>5. And then the actual sort is takes just theone argument of the array creates the auxiliary arrayand then uses that.<br><br>6. You can kind of switch the role of theinput and the auxiliary array every time youmake a recursive call.<br><br>7. [COUGH] The method that we're going to use isbased on taking an auxiliary array to hold thedata.<br><br>8.Is to save a little bit of time you don't really haveto copy over into the auxiliary array.<br>
between|sentence cnt : 88 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>3. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br><br>4. The partitioning elements in between themand they're in the wrong order.<br><br>5. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>6. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>7. But then, you might say,well, how many keys are there that are between g and k? In this case, there'sjust two.<br><br>8. So the invariant of that is thatthe array is always between 25% and 100% full, number one.<br>
others|sentence cnt : 6 <br> <br>1. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>2. There's algorithms in physics for understanding physical phenomenon thatwe'll look at an example and many others on this list.<br><br>3. So we pick some othersmall prime number and for each field we multiply by 31.<br><br>4. And there's anothersurprising situation that happens in today's world.<br><br>5. Sql or Oracles database and others,are based on, some variant of B-trees because they're so, so effective.<br><br>6. Last lecture, we looked at Mergesort,another classic sorting algorithm, that's used in many systems, and today we arelooking at Quicksort which is used in many others.<br>
comparison|sentence cnt : 28 <br> <br>1.And then we do the comparisons as, as before and that, and that's all fine.<br><br>2. So you have to use hashing if you don't havethe comparison.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>5. For example we can say that the number of comparison and theworst case is O(N3/2) for the 3x + 1 increments.<br><br>6. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>7. And that approximation gives us, it'sabout two M+1 natural log N comparisons for Quicksort.<br><br>8. We just use that dimension ofthe point to do the comparison.<br>
move|sentence cnt : 116 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>4. So we move that one up and increment j andk.<br><br>5. And then, here's the move method.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>8. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br>
simultaneously|sentence cnt : 1 <br> <br>1. The client might have a lot of stacks thatneed to be maintained simultaneously and maybe they reached their maximumcapacities at different times and various other things.<br>
cycle|sentence cnt : 3 <br> <br>1. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>2. And cycle through the dimensionsof level i mod k.<br><br>3. And we use the same idea as for 2d trees,but instead of just cycling through horizontal vertical, we cycle throughhowever many dimensions there are.<br>
interesection|sentence cnt : 1 <br> <br>1. And then that means that C-s got tobe less than A if it is in the right, so therefore there can't be any interesectionin the right either.<br>
progress|sentence cnt : 6 <br> <br>1. And actually, you can make some progress with this kind of method, leaving tombstones through out the tree.<br><br>2. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>3. So the progress of a scientificinvestigation is going to be affected by how quickly you can do this calculationfor a large number of particles.<br><br>4. But we did decrement gt so we made progress.<br><br>5.And that definitely enabled new progress in technology and it's a fine example ofthe importance of algorithmic technology.<br><br>6. And so this, this traceillustrates how we always make some progress and eventually we get the filesorted.<br>
audio|sentence cnt : 1 <br> <br>1. [BLANK AUDIO].<br>
systems|sentence cnt : 17 <br> <br>1. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>2. Littlebit scary for some systems designers.<br><br>3. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>4. So, that's a model for many systems.<br><br>5. And it's also, used in the, Linux kernel,and in many other systems.<br><br>6. It's often used in embedded systems or in hardware sort type systems becausethere's so little code involved to implement it.<br><br>7. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br><br>8. And, quicksort certainly plays a role in most systemsorts.<br>
proof|sentence cnt : 18 <br> <br>1. So, let's look at the proof of that.<br><br>2. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>3. We do some mathematical proofs in, in thiscourse when they're critical such as this one.<br><br>4. So, that's a sketch of a proof that the depthof any node x is at most log base two of N.<br><br>5. That's another proof by expansion.<br><br>6. So, That's a, quick sketch of the proof of this proposition.<br><br>7.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br><br>8. Now that's essentially the proof that you have to have acounterclockwise turn.<br>
treat|sentence cnt : 9 <br> <br>1. Ourproblem we were treating partitioning, equal of partitioning element as one valueless than as another and greater than as another.<br><br>2.And that completes our treatment of sorting algorithms with the Heapsortalgorithm.<br><br>3. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>4. And his idea was that if some particle isway away from some cluster of particles, we can treat that cluster asa single aggregate particle.<br><br>5. So it treats it as a base 31 number.<br><br>6. So that, that, that'sour full summary of sorting algorithms to and completes our treatment of sortingalgorithms with Heapsort.<br><br>7. Now, on the other hand, we could, fromthis same file, we could build a symbol table where we treat the IP address asthe, as the key and the URL as the value.<br><br>8. The first will be a file name, a so-called common separated value fileand the next two arguments are integers which will tell us what to treat as keysand values in the file.<br>
define|sentence cnt : 17 <br> <br>1. Andthat's a very useful thing because otherwise, we might try to define such analgorithm.<br><br>2. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br><br>3. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>4. How to sort the points by polar angle?Well again we need to define what we mean when we're comparing points.<br><br>5. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>6. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>7. And this is simple and completely well defined partitioning of the plane corresponding to a binary tree.<br><br>8. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br>
provided|sentence cnt : 1 <br> <br>1. One is an, what'scalled an upper bound which is a cost guarantee that's provided by somealgorithm for solving the problem.<br>
attribute|sentence cnt : 7 <br> <br>1. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>2. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>3. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>4. It doesn't have this highly desirableattribute but everything would compile.<br><br>5.Then, we've talked about a bunch of attributes.<br><br>6. There's alot of attributes, the different applications have.<br><br>7. But the thing is, there is way morepossible combinations of attributes than there are algorithms.<br>
approach|sentence cnt : 9 <br> <br>1. This is so called lazy approach to algorithmdesign where we try to avoid doing work until we have to.<br><br>2. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br><br>3. Which is another approach toimplementing symbol tables that can also be very effectivein a practical applications.<br><br>4. So we need to fill in this one table, what's the cost of deletion in a binary search tree? How we're going to really do that? Well, let's take a look at a very lazy approach which we setup for in our basic conventions for symbol tables.<br><br>5. And the real practical challengewith hashing is that developing a hash function is that every typeof key needs a hash function and you need a different approach forevery key type.<br><br>6." another, A complementary approachis to think of these words as words that we don't want to ever see.<br><br>7. And for overflow, what happenswhen the client does too much? We're going to talk aboutan approach called resizing that will allow us to avoid overflow forclients.<br><br>8. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br>
cumbersome|sentence cnt : 1 <br> <br>1.It's cumbersome to maintain multiple node types.<br>
characteristics|sentence cnt : 8 <br> <br>1. At leastthat some indication that you understand the performance characteristics.<br><br>2. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>3.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br><br>4. So that seems as if it should work but that doesn't have all the characteristicswe need in the Java implementation.<br><br>5. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>6. So again,typical characteristics we have a huge file but small number of different keyvalues.<br><br>7. And one of Mergesort's characteristics isthat in practical applications, it uses extraspace proportional to N.<br><br>8. B-trees, there's many different variants that, givedifferent characteristics of, space usage and other characteristics.<br>
everywhere|sentence cnt : 4 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>3. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>4. So, first thing it goes up the exchange with the S, it's still bigger than P so we exchange it with the P and now we're done because S is not bigger than T and the heap order condition is now satisfied everywhere in the heap.<br>
estimate|sentence cnt : 4 <br> <br>1. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>2. So now let's look at the running timeestimates about why we care about Quicksort vs Mergesort.<br><br>3. A second improvement is to, try toestimate the partitioning element to be near the middle.<br><br>4. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br>
finish|sentence cnt : 7 <br> <br>1. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>2. So, here's what our table, will look like,when we finish the implementation of 2-3 trees.<br><br>3.And so, for example, what this table shows, if you were to tryto use a insertion sort for a huge file, say a file with a billion elements,on your PC it'd take a few centuries tofinish.<br><br>4. The right goes to the value stack and nowwe got a lot of stuff on the stacks and we got through right parenthesis and that'sgoing to finish up the computation, take the top two items off the stack and thetop operator off the operator stack, perform the operation, put the resultback on the value stack.<br><br>5.To finish up, we're going to look at therectangle intersection problem that's got important practical applications and, usesthe techniques that we've been studying so far.<br><br>6. We're going to finish up by talkingabout some, practical applications of red black trees.<br><br>7. And now H has no right child, just a left child and it's larger than that one so now we're finished with that operation.<br>
places|sentence cnt : 12 <br> <br>1. And so,suppose we have a large number of such line segments and what we want to be ableto do is to find all places where they intersect.<br><br>2. Maintain a dynamic search symbol tablewith trillions of keys, so that you can get to any key just by looking five or sixplaces but that's what B-trees provide for us.<br><br>3. And again the string is the key and thesets of integers are going to be the places in the arraywhere the given work appears.<br><br>4. The word majesty appears in three places,and there's, there's the context.<br><br>5. Again, t and I are in the wrong places.<br><br>6. So, in this case there's fourplaces where these lines intersect.<br><br>7. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>8. And a programmer might use the same program, to find places where certain,Programming terms are used in a bunch of programs.<br>
ultimately|sentence cnt : 2 <br> <br>1. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>2. So, the system designer, Jon Bentley was one of the designers totake a look at these problems and that lead ultimately to the development of the3-way quick sort that were used today.<br>
cases|sentence cnt : 35 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. But also taking care of specialcases when the queue is empty.<br><br>3. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>4. So, just following those threecases, I see t hat this correspondence is going to work.<br><br>5. And in all of these cases where we're on a node that alreadyexisted, we just want to return the link to that node.<br><br>6. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br><br>7. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>8. But actually, in most cases, you want tofind the way to use all the data.<br>
mathematician|sentence cnt : 3 <br> <br>1. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>2. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br><br>3. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br>
loops|sentence cnt : 6 <br> <br>1. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>2. Actually less code thanfor Quick Find, no fore loops.<br><br>3. There's no loops.<br><br>4. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>5. And the key thing about this standard implementation thatit's two nested four loops that each run up to N.<br><br>6. It's got two nested for loops,selection sort had two nested for loops, a test, a comparison, andan exchange inside the for loop.<br>
probing|sentence cnt : 15 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>3. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>4. But, in linear probing, to insert what we do is when we put it inposition I if that's free, if not we just look at I plus one, and I plus two, andwrap around to the beginning if we reach the end.<br><br>5. So that's a short demo of linear probing hashing.<br><br>6. And, sothere was quite a bit of effort, devoted to figuring it out, how full we could getthe hash table, in linear probing.<br><br>7. So, what happens is that you are on a one waystreet and you are looking for a parking place and, it's, the idea's you startlooking for a parking place at particular times and say "Okay, now I need a parkingplace", and what you're doing is linear probing hashing.<br><br>8. With linear probing is called open addressing and isalso around the same time in the 50's the idea is just use an array.<br>
approximation|sentence cnt : 4 <br> <br>1. And that approximation gives us, it'sabout two M+1 natural log N comparisons for Quicksort.<br><br>2. And by Stirling'sapproximation, we know that log base two(N) factorial is proportional to N logbased 2N.<br><br>3. But use the center of mass andyou get a very accurate [COUGH] approximation tothe N-body doing that.<br><br>4. And that's a pretty close approximation,in this case.<br>
five|sentence cnt : 53 <br> <br>1. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>2. So what power do you have toraise 500 to get bigger than N? In practice that's going to be like four orfive.<br><br>3. 5's root isfive.<br><br>4. You can get to any one with onlyfive or six probes.<br><br>5. And fiveand zero have different entries.<br><br>6. So if we're going to union six and one,then we have to change entries zero, five, and six.<br><br>7. And then, if we want to connect five and zero.<br><br>8. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br>
briefly|sentence cnt : 5 <br> <br>1. If we're going to implement our own typesand then use those types as keys and symbol tables you have toexercise a little bit of care and we'll talk about that briefly.<br><br>2.Okay, next we'll briefly considerqueue implementations using the same basic underlying data structures.<br><br>3. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>4. Sothe main part of computation that we haven't really talked about and we'llcover briefly is if we have three points, a, b and c, and you go from a to b to c,are you making a counterclockwise turn or not? So, in the example at the left, a tob to c is counterclockwise.<br><br>5. That's a model for many physical systemsI'll give an abstract model and then just talk briefly about how it applies tophysical systems.<br>
testimony|sentence cnt : 1 <br> <br>1. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br>
scientific|sentence cnt : 15 <br> <br>1. And also in all different typesof scientific data processing, these things are extremely important.<br><br>2. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br><br>3. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>4. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br><br>5. With this fast algorithm we can get an accurate answer to the scientificquestion.<br><br>6.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>7. So the scientific question, or the, mathematical questionfrom this model is, how do we know, whether it's going to percolate or not? Inthis problem and in many similar problems, there's what's called a phase transition.<br><br>8. So we use a simple scientific model calledthe hard disc model.<br>
induction|sentence cnt : 6 <br> <br>1.If the parent was a 2-node then the transformation is a local transformationand if you look at where the links are, then it's easy to see by induction that ifthere was perfect balance before there's perfect balance afterward,Because we didn't change anything about the perfect balance in any of thosesubtrees.<br><br>2. And then that key is going to have all those keys in order by induction.<br><br>3. And then if the ones on the right goin their natural order, and then, by induction, they're all in their naturalorder.<br><br>4. So we have to again prove that property by induction.<br><br>5. And to believe this method, you just have to think recursivelyand prove by induction that this in order method puts all the keys in the datastructure on the queue in their natural order.<br><br>6. And then it turns out that it holds forall N, which we can prove by induction fromthe recurrence.<br>
acceptable|sentence cnt : 5 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>2. If Ngrows from a million to a billion, that cost goes from twenty to 30, which isquite not acceptable.<br><br>3. If the keys happened to have some order in them, our trees are not going to be balanced at all, and that's going to make the difference between acceptable and not acceptable performance.<br><br>4. Quadratic time to insertN items into a stack, that kind of performanceis unacceptable for large problems, as we've seen,as we will see many times.<br><br>5. So, thoseelementary implementations are no acceptable for a large numbers of keys cuzthey have the linear time operation.<br>
thrown|sentence cnt : 2 <br> <br>1. And when we've done that, we've thrown outlg N 1s.<br><br>2. In particular,it's known that after you've thrown M balls into the M bins then the most loadedbin has about log M over log M balls.<br>
identify|sentence cnt : 3 <br> <br>1. For example, you might have a spellchecker where you want to identifymisspelled words.<br><br>2. So, what we have to do isidentify the index or that minimum entry and exchange it.<br><br>3. We identify the, the length of the array that's n.<br>
proportional|sentence cnt : 56 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. Now instead of the initialization always takes timeproportional to N.<br><br>3. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br><br>4. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>5. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>6. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>7. Wehave constant time access to every element, but the space is proportional toN.<br><br>8. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br>
item|sentence cnt : 157 <br> <br>1. Order doesn'tmatter so all we want to do is add an item maybe you want to know the size and wewant to iterate through all the items in the bag.<br><br>2. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>3. That's the most recently added item.<br><br>4. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>5. So to insert N items,it's about three array accesses.<br><br>6. And then the last thing we need to do isjust return the item that we saved away.<br><br>7. So this is when the itemscome in in reverse order.<br><br>8. So now we have a second item b.<br>
matrix|sentence cnt : 12 <br> <br>1. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>2. And that's fine in typical applications when the matrix is small, orwhen there's lots of entries in the matrix.<br><br>3.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>4. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>5. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>6. But theyallow us to have a much more efficient matrix multiplication method.<br><br>7. So instead of using the standardmatrix representation, where every row of a matrix is an array, that's what a twodimensional array is and the space is proportional to N^2.<br><br>8. So now if wehave a sparse matrix times a vector our running time is going to be constant foreach row or proportional to the number of non-zero entries for each row which meansthat the running time is going to be linear for a sparse matrix just by the useof a symbol table.<br>
swiss|sentence cnt : 1 <br> <br>1. And with the Swiss knife implementation with so many operationsit's hard to know whether or not the particular set of operations that yourclient needs is efficiently implemented.<br>
guarantees|sentence cnt : 3 <br> <br>1. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>2. And again, that's a little harder to do withsomething like a red black tree where we have performance guarantees.<br><br>3.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br>
extents|sentence cnt : 1 <br> <br>1. So we say that we're dealing withkeys that are comparable by simply adding this extents comparable key to ourdeclaration.<br>
sides|sentence cnt : 5 <br> <br>1. If the probability is high and there is a lot of open sides, itdefinitely is going to percolate.<br><br>2. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>3. But we have to look on both sides tolook for more, but if the rectangle lies to the left of the root node, then we onlyhave to look on the left and so forth.<br><br>4. To get started we map a key to a integerbetween zero and m-1 where m is the sides of our array where we are storing thekeys.<br><br>5. Here's a little bit more mathematical one:we write the recurrence down, and then we divide both sides by N.<br>
myse|sentence cnt : 2 <br> <br>1. One myse alpha is forthe hit, one myse alpha for the squared for the insert.<br><br>2. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br>
moves|sentence cnt : 6 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>2. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>3. And then we're going to maintain an Ipointer that moves from left to right, and a J pointer that moves from right to left.<br><br>4. It moves keys pastother keys that could be equal and so its easy to construct examples showing thatSelection Sort is not stable.<br><br>5. Actually since we copied, we couldoptimize by avoiding these moves.<br><br>6. So, what we'll do is use a recursiveimplementation that as it moves down the tree it'll return a link up higher in thetree.<br>
experiment|sentence cnt : 8 <br> <br>1. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>2. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br><br>3. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br><br>4.And also, it allows us to develop a math model that we can go ahead and validatewith experimentation.<br><br>5. And then this isanother famous physics experiment showing diffusion.<br><br>6. So what we want to do is run this experiment millions of times,which we can do in a computer, as long as we can, efficiently do the calculation ofdoes it percolate or not.<br><br>7. This is a little bit about Einstein's experiment.<br><br>8. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
abstract|sentence cnt : 18 <br> <br>1. And also the associative arrayabstraction is the put() method will overwrite an oldvalue with a new value.<br><br>2. So those are the basic operationsthat we're going to want to implement to get the associative arrayabstraction and then there's many, many possibilities for clients andwe'll look at some later on.<br><br>3. So, with the priority queue abstraction that'snot too difficult to do.<br><br>4. So the way that it's convenient to set up a symbol table is to implement theso-called Associative array abstraction.<br><br>5. Soit's a little exercise in abstraction.<br><br>6. That's the associative array abstraction.<br><br>7. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>8. We took two sorted subarrays and we talkedabout an abstract in place merge but we didn't have anactual in place merge.<br>
ninther|sentence cnt : 2 <br> <br>1. They [cough] used what's called a method for choosingpartitioning element called Tukey's ninther.<br><br>2. And Tukey's ninther is justpick nine items out of the array and take the median of the mediums and that's theninther.<br>
definitions|sentence cnt : 2 <br> <br>1. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>2. [cough] There's a lot ofequivalent definitions of this.<br>
doom|sentence cnt : 1 <br> <br>1. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
true|sentence cnt : 24 <br> <br>1. And what assert will do is it will throwan exception unless that condition is true.<br><br>2. If we're not done we're supposed to return true and the next() is supposed togive the next item in the iteration.<br><br>3. If they're equal, it returnstrue.<br><br>4. So this isa static method that is supposed to return true if the array is sorted and false if it'snot.<br><br>5. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br><br>6. And why is it true that the depth ofany node x is, at most, log base two of N? Well, the key to understanding that is to,take a look at exactly when does the depth of any node increase? When does it go downfurther in the tree? Well.<br><br>7. First one says that if v is less than or equal to w and w is less thanor equal to v then the only way for that to be true is if they're equal and thenthere's transitivity.<br><br>8. And so and that's true as long as N isbigger than 1.<br>
embedded|sentence cnt : 1 <br> <br>1. It's often used in embedded systems or in hardware sort type systems becausethere's so little code involved to implement it.<br>
logarithmic|sentence cnt : 13 <br> <br>1. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>2. And so that's the st ory of red-black BST's guaranteedlogarithmic performance for all symbol table operations.<br><br>3.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>4. What we're going to look at next time called the Red-Black Binary Search Tree will guarantee logarithmic performance for all operations.<br><br>5. So in typical cases, the runningtime of nearest neighbor search in a 2D tree is going to beproportional to logarithmic.<br><br>6. And as long as there aren't too many deletions, you can keep the search cost and deletion and insert cost to be logarithmic.<br><br>7. Again, dependent on the random shuffling,is going to be logarithmic.<br><br>8. In color flip, wecould guarantee logarithmic performance not just research, insert, in delete code.<br>
below|sentence cnt : 25 <br> <br>1. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>2. So, the weighted algorithm always makes sure that the smaller tree goesbelow.<br><br>3. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>4. And the full pageabout to split then right below there's two pages.<br><br>5. So first we search the leftsub-tree that's the one below.<br><br>6. So in the example down below here, if we have this file called tobe.<br><br>7. Down below.<br><br>8. There's N squared over2 below the diagonal, half of that is N squared over 4.<br>
lean|sentence cnt : 48 <br> <br>1.It takes it, boolean condition.<br><br>2. In fact, that's what lead to [unknown] analyze the situation then comeup with a left-leaning variant.<br><br>3. So, what we are going to do is use internalleft-leaning links to glue the three nodes together.<br><br>4. That's a legal left-leaning red-blacktree.<br><br>5. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br><br>6. So this is, and actually the versionthat we're going to, looking at is called left-leaning red-black BSTs.<br><br>7. Now, we have athree node, but the red link is leaning right so we have to rotate.<br><br>8. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br>
comparable|sentence cnt : 39 <br> <br>1. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>2. And this one just uses equals, so the keysdon't have to be comparable for this.<br><br>3. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>4. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>5. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>6. Now if we're going to implement our owntype then we have to go ahead and implement the Comparable interfaceaccording to these rules.<br><br>7. So, if they're going to be comparable,we might as well take advantage of it, both to get more efficient algorithms and to be able to take advantage ofa broader set of operations.<br><br>8. First thing we do is the public sortmethod that takes the array of comparable items as its argument.<br>
networks|sentence cnt : 3 <br> <br>1. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>2. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br><br>3. We talked about dynamic connectivity innetworks there's many other examples in our computational infrastructure.<br>
exercises|sentence cnt : 2 <br> <br>1. But more important, there's code, there's exercises, tere's agreat deal of information there.<br><br>2. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br>
wider|sentence cnt : 1 <br> <br>1. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br>
dynamic|sentence cnt : 24 <br> <br>1. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>2. So this is a dynamic data structure that kind offollows the same rule as binary search.<br><br>3. To maintain the sorted array in dynamic fashion is going to takelinear time you have to go through the whole thing.<br><br>4. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>5.Now we'll look at our first implementationof an algorithm for solving the dynamic connectivity problem, called Quick-find.<br><br>6. But simply can'tsupport a huge dynamic connectivity problems.<br><br>7. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>8. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br>
describing|sentence cnt : 1 <br> <br>1. The problem is nobody knows an accurate model for describingthe number of compares taken by Shellsort for any interesting increment sequence.<br>
substitute|sentence cnt : 1 <br> <br>1.Substitute the previous equation telescope.<br>
internal|sentence cnt : 8 <br> <br>1. But we don't have the client to know whetherwe're using an array or link list or whatever internal representation we mighthave in mind.<br><br>2. So, what we are going to do is use internalleft-leaning links to glue the three nodes together.<br><br>3. We can associate the keywith null internally then apply or know the differencewhether that's in there or not.<br><br>4. And that causes us to add a newentry into this internal, node.<br><br>5. And then we'll pass the s plit up causing asplit up higher so the red keys in the internal nodes are copies of keys downbelow that direct the search.<br><br>6.There's a list of keys at every internal node and that key, tells you that, thenlinks for every key that give you, a place where your key would have to be.<br><br>7. First of all no node has two red links connected to it cuz theonly red links are internal to three nodes.<br><br>8. And you could havesome hybrid struc ture where you use something different for the internalmodel.<br>
again|sentence cnt : 184 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>5. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>6. Then once we've exchangedit, again, we preserved our invariant.<br><br>7. Again, exactly as what would happen in a2-3 tree.<br><br>8. And you put at the end of the code whatyou think it's going to do, again in the formof an assertion.<br>
simp|sentence cnt : 152 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>3.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>4. So this is a simple test client thatwe can use to test our implementations.<br><br>5. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>6. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>7. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>8. And now build asimple table that associates strings with strings.<br>
latest|sentence cnt : 1 <br> <br>1. Like, forexample, what's the earliest time? That's the min or what's the latest time? That'sthe max.<br>
geometry|sentence cnt : 6 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>2.So [cough] this is if we implement a point data type for computational geometry, youcan have a method ccw() that just with this little math calculation (b.<br><br>3. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br><br>4. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>5.>> Now we'll look at an application ofsorting from the field of computational geometry for an interesting computation.<br><br>6. This points out examples of howdifficult computational geometry can sometimes be because degenerate caseslike these are difficult to deal with in code.<br>
polar|sentence cnt : 8 <br> <br>1. How to sort the points by polar angle?Well again we need to define what we mean when we're comparing points.<br><br>2. We needed tohave a comparison for points that orders them by the polar angle they make, makewith the given point p.<br><br>3. Sort the points by polar angle with p wherethat is we're just going to consider in that order.<br><br>4. And then if you look at thepolar angle with respect for every other point with the respect to that one, so theangle you get from of the x-axis through p up to the point, then the vertices appear inincreasing order of that angle.<br><br>5. And that uses apush down stack for the hull, it puts the points on the hull in it goes ahead andfor every point considering I'm in the order of the polar sort it'll comparewhether the top two points on the hull and the new point implement a CCW turn or not.<br><br>6. Sort the points by polarangle with p so that is if we take a, a vertical line and sweep it in acounterclockwise direction, what order that we hit the points? The first thing wehit is 0, 1, and then we sweep counterclockwise, we get the 2 and then3 and 4 and so forth.<br><br>7. So, the point with thelowest y coordinates on the convex hull and shows the one that is the smallestpolar angle that creates with the x-axis.<br><br>8. Points are defined data type for geometric objects and so what weneed is code that will compute the polar angle and use that as the basis forcomparison.<br>
played|sentence cnt : 2 <br> <br>1. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>2. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
problem|sentence cnt : 178 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>3. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>4.We think that one is bad news, we don't use it can lead to insidious debug, bugdebugging problems.<br><br>5. That's the sort problem.<br><br>6. So now what about solving a problem likethis, range search problem for a 2d tree.<br><br>7. When does all the bins fill up? That's called the couponcollector problem.<br><br>8. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br>
declaring|sentence cnt : 1 <br> <br>1. So, we want to avoid cast as much as possible because it,it, it really is declaring some kind of weakness in what we're doing.<br>
find|sentence cnt : 192 <br> <br>1. This is the Quick-findalgorithm.<br><br>2. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>3. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>4. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>5. We're not gonna try to find them all we'llget back to that in a minute.<br><br>6. Because it would have N^2,calls to find, to check whether they're connected.<br><br>7. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>8. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br>
mimics|sentence cnt : 1 <br> <br>1. So one thing to do is start outwith some small prime number and this kind of mimics Horner's method tojust add in more data as we get it.<br>
supporting|sentence cnt : 1 <br> <br>1. And then supporting that textbook, is free onlinematerial that we call the book site.<br>
referenced|sentence cnt : 2 <br> <br>1. So, a binary search treein Java is just going to be referenced to a root node.<br><br>2. You could implement this bybuilding explicit links but the an easier thing to do is to know that every node isreferenced by just one link in a tree the one from it's parent.<br>
flattening|sentence cnt : 1 <br> <br>1. Now,that's not quite as good as totally flattening actually in practice that itactually is just about as good.<br>
bigger|sentence cnt : 54 <br> <br>1. There is that compareare the two children bigger, then compare.<br><br>2. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>3. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>4. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>5. So what power do you have toraise 500 to get bigger than N? In practice that's going to be like four orfive.<br><br>6. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>7. The first thing to check is find out which one is bigger, it's either 2k or 2k plus one and so set J accordingly.<br><br>8. And that will reset our instance variable, which is our stack,to this new, bigger array.<br>
suffer|sentence cnt : 1 <br> <br>1.Actually, some implementations of Quick Sort out in the wild don't have thisproperty, and they suffer a little bit in performance.<br>
telling|sentence cnt : 1 <br> <br>1. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br>
concert|sentence cnt : 1 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br>
bugs|sentence cnt : 4 <br> <br>1. Not only does it help detect bugs, but it also documents what the code is supposedto do.<br><br>2.You didn't want to have any bugs when you're making a chip.<br><br>3. There is this test fornull that has to be there and if it's not there it can lead tonefarious bugs and unusual problems.<br><br>4. Here's the code that you can find on the web for how to shuffle a deck of cards, that's pretty similar to our code but it's actually got more than a few bugs.<br>
cuckoo|sentence cnt : 1 <br> <br>1. In a new method called, relativelynew method called Cuckoo Hashing.<br>
weakness|sentence cnt : 1 <br> <br>1. So, we want to avoid cast as much as possible because it,it, it really is declaring some kind of weakness in what we're doing.<br>
requiring|sentence cnt : 2 <br> <br>1. Now, we're cheating in thisimplementation to keep it simple, and we'll take care of thischeat in a little while, by requiring the client to providethe capacity of the stack.<br><br>2. That's array implementations of stack, but it breaks the API by requiringthe client to provide the capacity.<br>
private|sentence cnt : 5 <br> <br>1.So let's start with the constructor, well we have a, a private integer array.<br><br>2. All of which are private as usual.<br><br>3. So starting at any node, you justfollow ID equals ID of I until they're equal and then you're at a root and that'sa private method that we can use to implement the find operation or theconnected operation.<br><br>4. So we put the word final to means that instance methods can't be overridden, and not only that, instance variables are private, they can't be seen from the outside and they don't change.<br><br>5. Now we have a private method that implements thisprocess of finding the root by chasing parent pointers until we get to the pointwhere I is equal to ID of I, and if it's not equal, we just move I up one level inthe tree, set I equals ID of I and return it.<br>
owned|sentence cnt : 1 <br> <br>1. This does not include the space for the strings themselves,which are owned by the client.<br>
duplicate|sentence cnt : 13 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>2. Duplicate keys, we may notneed N log N compares, we're going to look at the method that I guess that down inlinear time and a lot of situations.<br><br>3. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>4. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>5.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br><br>6. On the other hand,if the array is in descending order and has no duplicates,then every element goes all the way back.<br><br>7.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>8. And now, the statistical problems are like that or findingduplicates.<br>
expert|sentence cnt : 8 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br><br>3. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>4. And experts debate about that and people who are interested can lookon the web for that kind of date.<br><br>5. Where some expert has doneimplementation of the hash code and also your applicationdoes not need ordering.<br><br>6. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>7. The other thing that's possible to do andit's a little mind bending so recommended only for experts.<br><br>8. And so it's a simple idea butexpert scientists were struggling with dealing with hugeamounts of geometric data.<br>
science|sentence cnt : 9 <br> <br>1. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>2. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>3. But now, let's look at the computerscience code.<br><br>4.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br><br>5. I'm Bob Sedgewick, professor ofcomputer science at Princeton.<br><br>6. In fact Quicksort, which we'll consider next time, was honored as one of the top 10 algorithms of the 20th century inscience and engineering.<br><br>7. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>8. And if, in theclassic algorithm or computer science problems for people to think about is whatdo we do to delete in these two situations and exactly how do we resize.<br>
essential|sentence cnt : 16 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>3. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>4. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>5. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>6. Essentially if you have M entries in the hash table and Mkeys the link of list you're going to look at is about N over M cuz they're evenlydistributed.<br><br>7. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>8. Now that's essentially the proof that you have to have acounterclockwise turn.<br>
farthest|sentence cnt : 1 <br> <br>1. If you want to find the pairof points that are the farthest apart in the set of points in the plane, this issometimes important in statistical calculation or other applications.<br>
counter|sentence cnt : 22 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. And, for everynode that we encounter, it could be that, our right endpoint of our interval, isbigger than what was there.<br><br>3. Example at the right, a to b to c is not counterclockwise.<br><br>4. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>5.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>6. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>7. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>8. And so the average list length is short, this islike what we encountered with hashing.<br>
vacancy|sentence cnt : 1 <br> <br>1. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br>
alphabetic|sentence cnt : 4 <br> <br>1. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>2.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br><br>3. Like theintegers or natural numbers or real numbers or alphabetical order for strings,chronological order for dates or times and so forth.<br><br>4. So[cough] here is just an example of what happens if would those implementedcomparators for that class student using the Java system sort, if you call arraythat sort with your a rray of students and you give it this by name comparator, itwill put them in order alphabetical order by the name field.<br>
equals|sentence cnt : 32 <br> <br>1. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>2. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>3. And this one just uses equals, so the keysdon't have to be comparable for this.<br><br>4. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>5. If D of N is 2D of N over 2 plus N with D of1 equals 0, then D of N equals N log N.<br><br>6. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br><br>7. It just uses equals.<br><br>8. And if it's array of objects,you can see that testing for equals can actually involvea lot of code and a lot of cost.<br>
complexiting|sentence cnt : 1 <br> <br>1.with mergesort is a good opportunity totake a look at the intrinsic difficulty in the sorting problem, now that is calledcomplexiting and we'll look at that next.<br>
computes|sentence cnt : 3 <br> <br>1. Then it computes the value of the midpointsame way as we did for a binary search.<br><br>2. Once it computes the hash code,it stores it as an instance variable.<br><br>3. And for strings, it kind of createsthe string as a huge number and then,really computes the value of that number.<br>
seven|sentence cnt : 28 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>3. So that's the cut off point for, selling,seven tickets that's the cut off point.<br><br>4. Thegive me the seventh key we just go and look there, they are in order.<br><br>5. Seventeen, nineteen is at the root, so everybody with a le ft end pointless than seventeen is to the left, the left end point greater than seventeen isto the right and so forth.<br><br>6. 21 thru 23 to seventeen, nineteen.<br><br>7. Seven and two seven goes to be a child of 2's root which is one.<br><br>8. And now, if we ask is zeroconnected to seven we're going to answer yes.<br>
reducing|sentence cnt : 1 <br> <br>1. And the way that it works is we are always reducingone case to another.<br>
reynolds|sentence cnt : 1 <br> <br>1. How good is that? [MUSIC] >> So, this is a simple model developedby Craig Reynolds a while ago for simulating the situation called the boid.<br>
whatever|sentence cnt : 22 <br> <br>1. Whatever the size,bottom of Mergesort gets the job done in log N passes.<br><br>2. For whatever reason a parent becomes the key and decreases, it might become smaller than one or both of its children's.<br><br>3. But we don't have the client to know whetherwe're using an array or link list or whatever internal representation we mighthave in mind.<br><br>4. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br><br>5. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br><br>6. So, the analysis now says thatthe average running time per operation forwhatever the sequence of operations is, the average running time is going tobe proportional to a constant.<br><br>7. So, what we do is try to figure out why, find a way to addresswhatever's causing that problem, find a new algorithm and iterate until we'resatisfied.<br><br>8. We'll just goahead and compute the increments that are less than n, n / 3 and then startingat that increment whatever it is and say, we started 364 then next time we need anincrement, we'll just divide it by 3, 364 integer divide by 3, 364 integer /3 it gets 121, 40 and so forth.<br>
detailed|sentence cnt : 5 <br> <br>1. For detailed information ona performance, eval grievance.<br><br>2. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>3. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>4. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br><br>5. The exact analysis is notmuch more detailed than that.<br>
processing|sentence cnt : 26 <br> <br>1. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>2. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>3. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br><br>4. And also in all different typesof scientific data processing, these things are extremely important.<br><br>5. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br><br>6. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>7. We'll see later Kruskal's minimum spanning treealgorithm, which is a graph processing algorithm which uses Union-find as asubroutine.<br><br>8. Down atthe bottom is one of those important one is in image processing for understandinghow to label areas in images.<br>
coomplete|sentence cnt : 1 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br>
randomness|sentence cnt : 7 <br> <br>1. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>2. [cough] And actually, in typical applications with any kind ofrandomness or even if there is a lot of order its difficult to find situationsorders of keys that build the trace of height is bigger than actually one log Nin, in a real application, its very close to fully balanced all the time.<br><br>3. This is different than for example for quicksort when we, our assumption was we're going to create randomness and we aregoing to depend on that randomness.<br><br>4. In this care we're kind of hoping forrandomness and maybe that doesn't really always hold.<br><br>5. There's another family of methodswhere there's no ordering, and there's a special methodcalled hashCode that helps us inject randomness into the process.<br><br>6. And so, you can just run that program and if thesort doesn't use randomness then it's vulnerable to this attack.<br><br>7. That's a linear time shuffling algorithm making use of randomness.<br>
debugging|sentence cnt : 3 <br> <br>1.We think that one is bad news, we don't use it can lead to insidious debug, bugdebugging problems.<br><br>2. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br><br>3. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
programs|sentence cnt : 13 <br> <br>1. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>2. So we don't need so much any more generalprograms for manipulating linked-lists.<br><br>3. And that's why so manysystem programs refuse that.<br><br>4. And so client programs andsystem programs on the Java system were having terrible performance on theirsymbol table because of the shortcut in hashing.<br><br>5. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>6. And again the default implementation is tocheck whether we refer to the same object and that's rarely what we want,Java system's programs may be want that.<br><br>7. And you've, you've used programs like this on, on your computer many instances, mostlikely.<br><br>8. And a programmer might use the same program, to find places where certain,Programming terms are used in a bunch of programs.<br>
sort|sentence cnt : 492 <br> <br>1.That's a complete implementation of Quicksort.<br><br>2. You can see it's got the first half sorted, now it's working on the secondhalf.<br><br>3. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>4. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>5. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>6. Quicksort not stable.<br><br>7. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>8. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br>
recipe|sentence cnt : 3 <br> <br>1. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>2. So that's the standard recipe.<br><br>3. Okay, so that's a standard, this isjust in words the standard recipe for user type optimize forreference equality check against null.<br>
function|sentence cnt : 68 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. For example Java publishesits hash function.<br><br>5. So the hash function willmap any key.<br><br>6. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>7.And now, lg N is kind of a funny function.<br><br>8. It's going to be less than lg N and compares and it's got support for allthose ordered ST operations, and compared to and is pretty easy and natural functionto implement.<br>
parenthesis|sentence cnt : 15 <br> <br>1. Another right parenthesis, take the top two values off.<br><br>2. If we havea left parenthesis, do nothing.<br><br>3. It seems strange to be ignoring parenthesis and we'll getback to that in a second.<br><br>4. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>5. The right goes to the value stack and nowwe got a lot of stuff on the stacks and we got through right parenthesis and that'sgoing to finish up the computation, take the top two items off the stack and thetop operator off the operator stack, perform the operation, put the resultback on the value stack.<br><br>6. If we have a left parenthesis.<br><br>7.Left parenthesis, we ignore.<br><br>8. If we have a rightparenthesis, then go ahead and pop the operator.<br>
church|sentence cnt : 2 <br> <br>1. Theconcept of an algorithm was formalized actually here at Princeton, by Church andTuring, in the 1930s.<br><br>2. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br>
instructive|sentence cnt : 4 <br> <br>1. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>2. And it's definitelyan instructive exercise to check that you believe that, that method works.<br><br>3. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>4.Again, as with Mergesort, studying a recursive trace is instructive.<br>
easily|sentence cnt : 7 <br> <br>1. So, that's definitely a way to get a deck shuffled quite easily, easy to implement.<br><br>2. Doing something that, you wouldn't really, necessarilythink that you could do so easily.<br><br>3. And you can test this out for different types of environments easily andit's representative.<br><br>4. You can [cough] convinceyourself with that quite easily.<br><br>5. We didn't put in the this is thecheat version where we require the client to provide a capacity but we could easilychange this to a resizing array.<br><br>6. Again, another common function that'seasily handled by symbol tables.<br><br>7.That's a kind of a magic step, but we will see that it makes possible to solve theequation easily.<br>
split|sentence cnt : 50 <br> <br>1. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>2. So, let's look at a double split likethat.<br><br>3. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>4. And the full pageabout to split then right below there's two pages.<br><br>5. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>6.Now, L is the middle key of that one, So we're going to split that 4-node into,two 2-nodes and move L to the parent.<br><br>7. because there could be nopoint on the right subtree, on the right of this splitting line,that's closer to the query point than 3.<br><br>8.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br>
asked|sentence cnt : 1 <br> <br>1. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br>
because|sentence cnt : 160 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>3. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>4. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>5. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>6. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>7. Andthat's a very useful thing because otherwise, we might try to define such analgorithm.<br><br>8. Because it would have N^2,calls to find, to check whether they're connected.<br>
triangle|sentence cnt : 1 <br> <br>1. So now what about this one - 2? Is that onthe convex hull? Well, as far as we know at this point, it could be, it could bethat the thing is a triangle and 0 is the last point in which case it would be.<br>
mutually|sentence cnt : 2 <br> <br>1.A connected component is a maximal set of objects that's mutually connected.<br><br>2. In particular, just as another example,consider the idea of N-body simulation, which isa classic problem in physics where you've got N particlesmutually affected by gravity.<br>
partitionings|sentence cnt : 1 <br> <br>1. But intuitively, we can see kind of whathappens each partitionings that maybe splits the array approximately in half.<br>
racks|sentence cnt : 3 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. Andalso nobody racks up a, a set of billiard balls such that all fifteen are touchingin all places.<br><br>3. A red black tree tracks everysimple path from a node to a descendant leaf with the same number of black nodesthey got that rig ht.<br>
comparing|sentence cnt : 7 <br> <br>1. How to sort the points by polar angle?Well again we need to define what we mean when we're comparing points.<br><br>2. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>3. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br><br>4. And people understand properties ofthe universe by doing these kinds of calculations and comparingagainst what's observed in space.<br><br>5. The client programs usually havecustomized implementations that are based on comparing some sort of value.<br><br>6. Actually that one doesn'twork at all, very well at all because it winds up not comparing elements in evenpositions with elements in the odd positions until the 1-sort which meansperformance can be bad.<br><br>7. And for every value of k what we're most often doing is comparing whether aux of jis less than aux of i.<br>
safe|sentence cnt : 2 <br> <br>1. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>2. It says that we're using unchecked or unsafe operations and we shouldrecompile with a minus -Xlint equals unchecked for details.<br>
algorithmic|sentence cnt : 6 <br> <br>1. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>2.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>3. There's other things that we can doalgorithmically to bring down the search time a little bit.<br><br>4. And really, the key idea is reallyimportant to think about cuz it applies to all sorts of algorithmic problems.<br><br>5.And that definitely enabled new progress in technology and it's a fine example ofthe importance of algorithmic technology.<br><br>6. It's really an astounding example ofalgorithmic technology.<br>
struggling|sentence cnt : 1 <br> <br>1. And so it's a simple idea butexpert scientists were struggling with dealing with hugeamounts of geometric data.<br>
ogrammer|sentence cnt : 17 <br> <br>1." And many programmers live by that kind of preset.<br><br>2. Butinexperienced programmers often have trouble with it.<br><br>3. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>4. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br><br>5. And an experienced programmers know thisand it's not difficult to arrange for the natural types of data that peopleare going to use for symbol table keys.<br><br>6.sort and it's intended to be ageneral purpose sorting method for use by Java programmers.<br><br>7. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br><br>8. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br>
also|sentence cnt : 108 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. But also taking care of specialcases when the queue is empty.<br><br>3.Mergesort is not only efficient, it's also.<br><br>4.Also staying in bounds.<br><br>5. And also the associative arrayabstraction is the put() method will overwrite an oldvalue with a new value.<br><br>6. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>7. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>8.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br>
dynamics|sentence cnt : 1 <br> <br>1. It's got a little extra [COUGH] dynamics in the animation because of the auxiliaryarray.<br>
interleave|sentence cnt : 1 <br> <br>1. So this is 4 interleave sequences, that'sa 4-sorted array.<br>
sample|sentence cnt : 3 <br> <br>1. So one thing that we can do is sample theitems, and then take a median of the sample.<br><br>2.And that's actually not worth the cost for enlarged samples, not usually.<br><br>3. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br>
doubles|sentence cnt : 7 <br> <br>1. And the reason is that you only createa new array every time it doubles.<br><br>2. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>3. Now, there is a worst case, that is,at the point when the stack doubles, it takes time proportional to N.<br><br>4. And that array, it's got value stored in it, say it doubles and those can change but what immutable implementation would do would be to copy those values into the local data array instance variable and then those values are not going to change.<br><br>5. Now for standard keys like integers andstrings and doubles and so forth,we can count on the designers and implementors at Java toimplement good hash functions.<br><br>6. So, when the depth of x increases, the size of its tree at least doubles.<br><br>7. But by the time that it doubles, you'veinserted that many items into the stack.<br>
multiplied|sentence cnt : 1 <br> <br>1. And dates, when is a date so we addthat hash code, multiplied by 31 and add that hash code in.<br>
critically|sentence cnt : 2 <br> <br>1. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br><br>2.Now, look at an interesting application ofpriority queues that is actually representative of whole family of acritically important applications in applications of computing.<br>
printing|sentence cnt : 2 <br> <br>1. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br><br>2. One, having to deal with compiling from aprogramming language or interpreting into an actual computation and then the otherone is the PostScript language which is widely used for, for printing andpublishing.<br>
intervals|sentence cnt : 11 <br> <br>1. This is called intervalsearch.<br><br>2. So that's a binary search tree built, from thoseintervals.<br><br>3. And if we wanna find all intervals we just have to run thealgorithm fur Each interval that's, until we come up against no intersection, soit'll take time proportional to R log N if there's R intervals that intersect.<br><br>4. So this isthe binary search tree that's built from those five intervals, six intervals in ourexample.<br><br>5. So given a queryinterval, we want to find all intervals in the data structure that overlap thatinterval or find any interval we'll start with that simpler problem.<br><br>6. So now instead of points, our data is intervals.<br><br>7. So our, eh,our node stored intervals, but we only use our left end point as the key.<br><br>8. And because the interval search trees take logN for every operation, the insert and delete intervals is N log N totaled andthe searches is N log N + R log N.<br>
ruled|sentence cnt : 1 <br> <br>1. And then just look at the M atthe end but by sending up the problem, I already kind of ruled that one out becausewe don't have the space to sort them all, to store them all.<br>
found|sentence cnt : 28 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>3. So then we're done, andwe found that the nearest neighbor is 5.<br><br>4. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>5. And that has profound impact on theperformance of this algorithm.<br><br>6. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>7. So in order to look at every place in the table where L could be, we have tokeep looking til we found an empty table position, or we find L itself.<br><br>8. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br>
nice|sentence cnt : 6 <br> <br>1. But what's nice about data driven code is now that the code's workingand again we, we're not saying that this is a trivial code to write but it'sdefinitely manageable.<br><br>2. But Java does provide a nicea solution to this called iteration.<br><br>3. Another issue is, for many clients,if the keys are ordered, it's nice to be able to iteratethrough the symbol table and order.<br><br>4. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>5.So this aspect of red-black BSTs is an extremely nice one because of theoperations that we implemented for regular BSTs that involves some complicated codefor floor and ceiling and rank and so forth, and we don't have to change thatcode at all.<br><br>6. If it's 9/10's full one over one minus alphasquared is 100 one over 100, so it means it's going to be 50 p robes for a searchmiss if it's 9/10's full, and that's independent of N and M, whereas if it'shalf full then we get the nice.<br>
onnection|sentence cnt : 17 <br> <br>1. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br><br>2. There's not enough open site for there to be a connection from the topto the bottom.<br><br>3. And then, we have the idea of a connection between two objects.<br><br>4. So, that creates a connection between five andzero.<br><br>5.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br><br>6. Seven and two creates a connection between seven and two.<br><br>7. So shouldn't use it inconnection with inheritance.<br><br>8. And that's a redundant connection.<br>
plain|sentence cnt : 2 <br> <br>1. So here's just a particular client that will helpexplain the idea.<br><br>2. And what we're going to look atas one of the most widely used, which is basically to usea tree to represent a recursive subdivision of the plain,of two-dimensional space.<br>
potentail|sentence cnt : 1 <br> <br>1.1 what happened was that there wasa huge potentail for really bad collision patterns on typical data.<br>
nails|sentence cnt : 1 <br> <br>1. Well, there'sactually a way to compute the convex hull just mechanically if you put the nailsaround the points and put a rubber band around it, that gives you the convex hull.<br>
cities|sentence cnt : 16 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. So for example, here's somedata which is cities in the US.<br><br>3. So, in, in fact, often, the purpose of a sort isto bring items with equal keys together for like the example that I gave where wehad cities and time.<br><br>4. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>5. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>6.txt the first couple of words from "A Tale of Two Cities.<br><br>7. So, you have to take both velocities and divide theirdistance by those and, and so forth.<br><br>8. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br>
origin|sentence cnt : 9 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>3. Well in his original paper in 1961 Hoare gave a solution to the selectionproblem based on partitioning.<br><br>4. Shell's original idea is to try powers to two minus one andthat works okay.<br><br>5. Now, once that's done, what we'll want todo is copy back to the original array to get it insorted order.<br><br>6. Now this was studied in detail by Knauf, DonKnauf, in the 1960's and actually this problem, Knauf says, was the origin of theorigin of analysis of algorithms.<br><br>7. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>8. It might moveitems past some equal item and leave a result where items that are equal or indifferent order than they were originally in the file.<br>
queues|sentence cnt : 28 <br> <br>1. So howare we going to implement stacks and queues for that types of data.<br><br>2. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>3. All right, now the way we're going to use a complete binary trees to implement priority queues is to first of all associate information with each node.<br><br>4. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>5. Today we're going to talk aboutalgorithms and data structures for implementing some fundamental datatypes called bags, queues, and stacks.<br><br>6. This is just first indication of that of why ifyou want to do this simulation, you better know about some data structure likepriority queues.<br><br>7. This, this kind of stimulation is enabledby priority queues.<br><br>8. Again simulation of the naturalworld is an increasingly important application of computing and needefficient data structures like priority queues to get it done.<br>
identical|sentence cnt : 4 <br> <br>1. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>2. It's identical to the code forpop for a stack.<br><br>3. And in fact, most of the other operationsthat we implemented on BSTs are also identical.<br><br>4. We save away the item, we delete the firstnode by advancing the reference and then we return the item, so identical.<br>
variants|sentence cnt : 8 <br> <br>1. So let's, one way to understand the way that an algorithm works is tothink about invariants .<br><br>2. So the codeimplements the invariants.<br><br>3. Again, we can look at insertionsort in terms of invariants.<br><br>4. And, andpeople have variants of these algorithms that keep it more, much more than halfempty if that kind of space is a, is a consideration.<br><br>5. The invariants are that the entries on ontothe left of the arrow are never changed and they're in ascending order.<br><br>6. Andall the method does is maintain this in variants so let's do an example or two andsee how that works.<br><br>7. And the algorithm maintains those invariants by finding thesmallest entry to the right and exchange it with the next one.<br><br>8. B-trees, there's many different variants that, givedifferent characteristics of, space usage and other characteristics.<br>
generate|sentence cnt : 10 <br> <br>1. If we allow delete, in fact everything degenerates to square root of n.<br><br>2. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>3. So, we have an assignment whereyou need to generate a random open sites in a percolation system.<br><br>4. Now with i equals two, i pointing to the second card, we generate a random integer between zero and i.<br><br>5. Increment i, generate a random integer, this time it's going to be the first one again, swap them.<br><br>6. So, that's a, asimple simulation to just generate random positions.<br><br>7. The idea is just generate a random real number for every array entry, and then sort using those random numbers as the keys.<br><br>8. Increment i, generate a random integer, swap them.<br>
descendant|sentence cnt : 2 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. A red black tree tracks everysimple path from a node to a descendant leaf with the same number of black nodesthey got that rig ht.<br>
sketch|sentence cnt : 2 <br> <br>1. So, that's a sketch of a proof that the depthof any node x is at most log base two of N.<br><br>2. So, That's a, quick sketch of the proof of this proposition.<br>
sorry|sentence cnt : 4 <br> <br>1. Sorry a, a red black.<br><br>2. Could there be a node that's closer to our query point than 5 inthe right subtree of 4? We have to go above, sorry, to look atthe top subtree associated with 5 and we find that it's empty.<br><br>3. I'm sorry, v is less than w, w less than equalto x that you don't necessarily know that v is less than or equal to x.<br><br>4. Well, sorry, you have to take the absolutevalue because otherwise it'd be negative and you can't have it negative.<br>
populate|sentence cnt : 1 <br> <br>1. We'll populate its fields andthen that old link will change that from null toa pointer to the new node.<br>
fixed|sentence cnt : 1 <br> <br>1. And that's may not get fixed so that sort is not stable.<br>
builds|sentence cnt : 2 <br> <br>1. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>2. So, this value loop just builds thesymbol table from the file.<br>
rules|sentence cnt : 17 <br> <br>1. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>2. As far as the algorithms go, as far asthe rules go, you can always return 17.<br><br>3. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>4. Now if we're going to implement our owntype then we have to go ahead and implement the Comparable interfaceaccording to these rules.<br><br>5. And the idea is to use three simple rules, you get something very close tothis complex flocking behavior.<br><br>6. We need those procedures that implement those Physics rules for everyparticle.<br><br>7. And, there werevarious rules about what you can do on these drawings.<br><br>8. So from these rules you can see that the man of code required toimplement this intersecting inter role is extremely low.<br>
intersecting|sentence cnt : 5 <br> <br>1. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>2. So from these rules you can see that the man of code required toimplement this intersecting inter role is extremely low.<br><br>3. We don't haveany, any equal lines that we have to worry about whether we consider rectangles thattouch to be intersecting, and so forth.<br><br>4. Really, it's a modification of the sweep line algorithmthat we looked at for intersecting lines.<br><br>5. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
instant|sentence cnt : 3 <br> <br>1. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>2. And a supercomputer can do it in aninstant.<br><br>3. And smaller problems only take an instanteven on your PC.<br>
intrinsic|sentence cnt : 1 <br> <br>1.with mergesort is a good opportunity totake a look at the intrinsic difficulty in the sorting problem, now that is calledcomplexiting and we'll look at that next.<br>
mutual|sentence cnt : 3 <br> <br>1. And so, then there'll bemutual gravitational pull and this is what happens with a large numberof particles in a certain simulation.<br><br>2.A connected component is a maximal set of objects that's mutually connected.<br><br>3. In particular, just as another example,consider the idea of N-body simulation, which isa classic problem in physics where you've got N particlesmutually affected by gravity.<br>
metallic|sentence cnt : 1 <br> <br>1. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
craig|sentence cnt : 1 <br> <br>1. How good is that? [MUSIC] >> So, this is a simple model developedby Craig Reynolds a while ago for simulating the situation called the boid.<br>
parents|sentence cnt : 5 <br> <br>1. So, it will get added to, as the right link of A and every time weadd a node we just create a red link to its parents and so, that's changing thetwo node into a three node.<br><br>2. Now that parents of 4-node and that has tobe split, And we create a new root node.<br><br>3. But now we have to bring the heap order back into condition and so now that key is larger than its parents.<br><br>4. So the parents of say H and G are both N, H is at 10 G is at 11, N is at 5.<br><br>5. So one scenario shown here is, if for whatever reason a child's key becomes larger than its parents key.<br>
velocity|sentence cnt : 16 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>3. When it hits the wall is, is just going to change the velocity.<br><br>4. It's basically that distancedivided by the by the velocity.<br><br>5. So, we have to do collision prediction, which is givenposition, velocity, and radius when's it going to hit with another particle or, orthe wall.<br><br>6. So, we have a data type called ball that represents justone of the particles and has instance variables that has the position and thevelocity.<br><br>7. So, it's got position and velocityas I mentioned, and every ball has a, a radius.<br><br>8. And velocity matching, where you update your velocity tothe average of the k nearest boids.<br>
checks|sentence cnt : 3 <br> <br>1. It's recursive so, checks that we havesomething to do first.<br><br>2. So it simply takes its two arguments, P and Q, and checks whethertheir ID entries are equal, and returns that value.<br><br>3. That checks if those arrays are the sameobjects, and that's not what you want, you want to check that allthe values are the same.<br>
universal|sentence cnt : 2 <br> <br>1. It's called universal hash functions.<br><br>2. And we'd throw them universallyat random into M bins.<br>
points|sentence cnt : 82 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>3. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>4. So if the points are randomly distributed,then this is ideal.<br><br>5.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>6. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>7. So again, the geometric interpretationis the keys are points in the plane.<br><br>8. [cough]They're, they're going to be extreme points on the convex hull.<br>
specified|sentence cnt : 4 <br> <br>1. And then, and maybe it's all files on the computer, or maybe it's specified in, insome other way.<br><br>2. So, we're going to list of files that arespecified.<br><br>3. And so, the key values well, are just specified aspoints on a line.<br><br>4. So the two operations that we'regoing to perform in symbol tables is the insert operationwhere we're really putting a value, a key value pair into the symbol table,a value with a specified key.<br>
quickly|sentence cnt : 11 <br> <br>1. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>2. And that's an association that'swell known to biologist and then you can use this lookup CSV client to quickly getthe name associated with any given codon.<br><br>3.Now we're going to look at binary heaps, which is an ingenious and very simple data structure that's going to help us implement all the priority queue operations quickly.<br><br>4. Here's a partially sorted array, and you can see that insertion sortquickly gets the job done.<br><br>5. You wouldn't want it to all of a suddennot implement some operation quickly.<br><br>6. And kind of an explanation for how it getsthe sort done so quickly.<br><br>7. And now to do the high ones pretty quicklyand now it's doing the 1-sort and again it steps through the array pretty quickly.<br><br>8. We saw a few easy algorithms for solving theproblem, and quickly saw that they were inadequate for addressing huge problems.<br>
push|sentence cnt : 26 <br> <br>1. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>2. And to implement a stack when we do a push operation, we insert a new node atthe beginning of the linked list.<br><br>3. To push an item,we use N to index into the array, put the item there and then increment N.<br><br>4. Otherwise, if it's a string that'snot equal to the hyphen character, it'll just push it onto the stack.<br><br>5. So that also is a foreliner toimplement the stack push operation.<br><br>6. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>7. And if it's plus, add the resultof the two values at the top of the value stack and if it's a star, multiply the twovalues on the top of the stack and, and then push the result.<br><br>8. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br>
directly|sentence cnt : 6 <br> <br>1. This implementation directly implements thelink list.<br><br>2. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br><br>3. We can use a two-dimensional arrayto directly index relevant squares.<br><br>4. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>5. We have this inner class that we use tobuild the items in the linked-list and we make it an inner class so we can directlyrefer to those instance variables.<br><br>6. And then we have helper functions less and exchange that access the array directly so that the code doesn't have to access it directly.<br>
reds|sentence cnt : 7 <br> <br>1. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>2. We have hundreds of different implementations.<br><br>3. And what if we have hundreds of different types of data that we'reprocessing.<br><br>4. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>5.Now, we're going to take a look at orderedsymbol table operations using the binary search tree data structure as theunderlying implementation.<br><br>6. But you could see that even for this case which is hundreds of keys,the length of the path from top to bottom is not so much.<br><br>7. And youwant to insert h that goes to the left of R, two reds in a row, rotate the top.<br>
associations|sentence cnt : 1 <br> <br>1. So the client will build a symbol table that makes us associations for everyline in the file and this could be huge file.<br>
thorough|sentence cnt : 1 <br> <br>1. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br>
analysis|sentence cnt : 33 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. And we point that outbecause that helps with the mathematical analysis.<br><br>3. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>4. And then we can use, that property of the trees, in theanalysis to, show that, it's not going to be very many probes to get to any key.<br><br>5. The amount used is between 8N and 32N, depending on how full the array is and just a quick analysis of the amountof space that arrays take in Java.<br><br>6. So, the analysis now says thatthe average running time per operation forwhatever the sequence of operations is, the average running time is going tobe proportional to a constant.<br><br>7. What about the analysis of insertion sort? It's more complicated.<br><br>8. Now, if the, the keys are inserted inrandom order, we know that height by analysis, is going to be proportional tolog N.<br>
declare|sentence cnt : 7 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>2. And then we just declare that that's part of a heap and that node, well if it's less than its parent, we're fine.<br><br>3. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>4. So, we're going to take T and we're going to exchange it with the last element, and then declare that to be no longer part of the heap.<br><br>5.And at the top, the class declaration we declared an angle brackets that item isthe generic type that we're going to use.<br><br>6. So, what we wouldlike to do is just declare a new array using our generic name Item as in thehighlighted line here.<br><br>7. Now there's a fundamentaldefect in using an array and that is that you have to declarethe size of the array ahead of time and then so the stack has a certain capacity.<br>
twentieth|sentence cnt : 2 <br> <br>1. It was named as one of the most importantalgorithms of the twentieth century and it's widely used for system sorts and manyother applications.<br><br>2. In the twentieth century, math, scientistsdeveloped mathematical models to try to understand natural phenomenon.<br>
tombstones|sentence cnt : 3 <br> <br>1. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br><br>2. And actually, you can make some progress with this kind of method, leaving tombstones through out the tree.<br><br>3. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br>
john|sentence cnt : 2 <br> <br>1. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br><br>2. So that's John Bentley who discoveredthis while an undergraduate at Stanford.<br>
natural|sentence cnt : 37 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. So the search is a natural generalizationof the search in, binary search trees.<br><br>3. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>4. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>5. Somehow we're going to want the valuebe any generic type at all but the key type we have to make somenatural assumptions about them.<br><br>6. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>7. Very little code toimplement the convex hull given that you have a sort and that's our main point forthis lecture - there is many natural applications of sorting but also will beable to develop new algorithms that use sort that gain efficiency because of theefficiency of sorting.<br><br>8. It's going to be less than lg N and compares and it's got support for allthose ordered ST operations, and compared to and is pretty easy and natural functionto implement.<br>
arrow|sentence cnt : 4 <br> <br>1. No entryto the right of the arrow is smaller than any entry to the left of it.<br><br>2. Now, it's indicated by a little redarrow in this representation.<br><br>3. The invariants are that the entries on ontothe left of the arrow are never changed and they're in ascending order.<br><br>4. So this is a simpler, narrowerAPI but still it expresses an important little collection of operations and, andwe'll use this one and we've already seen the implementations.<br>
search|sentence cnt : 273 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. Rankoperation, that is essentially what binary search provides.<br><br>3. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>4.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>5. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>6. The first part is data typesorting and searching.<br><br>7. This is called intervalsearch.<br><br>8. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br>
lying|sentence cnt : 6 <br> <br>1. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>2.Okay, next we'll briefly considerqueue implementations using the same basic underlying data structures.<br><br>3. So this code is thebasis for applying the sort, system sort method or any sort method for the Grahamscan for the convex hull that we did at the end of the last lecture.<br><br>4. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>5. Then if you have a field that'sit's an array you can go ahead and try applying it to each entry andthere's implementations in Java.<br><br>6.Now, we're going to take a look at orderedsymbol table operations using the binary search tree data structure as theunderlying implementation.<br>
subfiles|sentence cnt : 8 <br> <br>1. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>2. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>3.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br><br>4. J points to the, rightmost element in theleft subfiles, everything that's not greater than K.<br><br>5. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br><br>6. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br><br>7.So, for every value of k, if you add those up the probability that the partitioningelement is k, plus the cost for the two subfiles, we get this equation.<br><br>8. In this case, the 4 subfiles stretched out at seven each onlyhave two elements in them.<br>
unchecked|sentence cnt : 2 <br> <br>1. It says that we're using unchecked or unsafe operations and we shouldrecompile with a minus -Xlint equals unchecked for details.<br><br>2. So, we can go aheadand do that and it says that you have put in, in your code an unchecked cast andwe're warning you about that cuz you shouldn't be putting in unchecked cast.<br>
happens|sentence cnt : 44 <br> <br>1.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>2. This gives exactly what happens duringeach of the calls to merge.<br><br>3. Alright, so, let's take a look at what happens.<br><br>4.Plus what happens next depends on what the partitioning element was.<br><br>5. So, let's just take a look at what happens with a real heap with the demo when we do these things.<br><br>6. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br><br>7. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>8. So here's just whathappens to the array for our small client example.<br>
deploy|sentence cnt : 3 <br> <br>1. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>2. Now,years after, we have to deploy our software and be extremely difficult oneveryone.<br><br>3. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
entire|sentence cnt : 4 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>2. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>3. And so, afterthat process, then we know that the entire array is in its final order, all sorted.<br><br>4. And then we have the entire array sorted.<br>
copy|sentence cnt : 10 <br> <br>1. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>2. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>3. Now, once that's done, what we'll want todo is copy back to the original array to get it insorted order.<br><br>4. And that array, it's got value stored in it, say it doubles and those can change but what immutable implementation would do would be to copy those values into the local data array instance variable and then those values are not going to change.<br><br>5.Is to save a little bit of time you don't really haveto copy over into the auxiliary array.<br><br>6. So that's, in array accesses forthe copy, there's two array accesses.<br><br>7. So the first thing we do is copyeverything over to the auxiliary array.<br><br>8. The reason is that you have to createa new array, size one bigger, and copy all the items to that new array.<br>
mutable|sentence cnt : 15 <br> <br>1. There's many other reasons that people use immutable data types.<br><br>2. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>3. And again as with priority qs the bestpractice is to use immutable types.<br><br>4. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>5. So and actually, since strings are immutable,what Java does is keep the hash value in an instancevariable so it only gets computed once.<br><br>6. And that array, it's got value stored in it, say it doubles and those can change but what immutable implementation would do would be to copy those values into the local data array instance variable and then those values are not going to change.<br><br>7. And so a constructor for an immutable vector data type, it might take an array as its argument.<br><br>8. And the next time you ask forthe hash code of that string, it will just provide it andthat works because strings are immutable.<br>
button|sentence cnt : 1 <br> <br>1. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br>
birthday|sentence cnt : 2 <br> <br>1. For example, there's the birthday problem.<br><br>2. So, what arewe supposed to do when two different keys hash to the same index? The birthdayproblem tells us that we're going to have collisions.<br>
exposure|sentence cnt : 1 <br> <br>1. They have some exposure toobject oriented programming and recursion.<br>
plit|sentence cnt : 50 <br> <br>1. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>2. So, let's look at a double split likethat.<br><br>3. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>4. And the full pageabout to split then right below there's two pages.<br><br>5. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>6.Now, L is the middle key of that one, So we're going to split that 4-node into,two 2-nodes and move L to the parent.<br><br>7. because there could be nopoint on the right subtree, on the right of this splitting line,that's closer to the query point than 3.<br><br>8.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br>
tail|sentence cnt : 47 <br> <br>1. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>2. For detailed information ona performance, eval grievance.<br><br>3. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>4. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>5. Let's look at the Java implementation and then we'll look in moredetail at, at that quantitative information.<br><br>6.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>7. Wewill provide much more detail information on that as we get into the assignments.<br><br>8. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br>
connecting|sentence cnt : 6 <br> <br>1. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>2. So, in this case we have a redlink connecting E and C.<br><br>3. And then key partof the problem is find query or the connected query, which just asks, is therea path connecting the two objects.<br><br>4. And now, if we insert C into this one, it goesless than E, greater than A it's a red link connecting A and C but it's leaningthe wrong way.<br><br>5. And those have to have ex, externallinks or tree links connecting them to some other node.<br><br>6. So for example, in this set of ten objects, weperformed already, a bunch of union commands, connecting four and three, threeand eight, six and five, nine and four, two and one.<br>
represent|sentence cnt : 49 <br> <br>1. The thing is remember represented in array one two three and so forth.<br><br>2. The array representation, all we do is we put, we start with indices at 1.<br><br>3. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>4. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>5. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>6. So, from this datastructure we can associate with each item a root, which is representative, say, ofit's connected component.<br><br>7. But we don't have the client to know whetherwe're using an array or link list or whatever internal representation we mighthave in mind.<br><br>8. So first before we get to the code for insertion, we haveto look at the representation.<br>
accesses|sentence cnt : 7 <br> <br>1. So to insert N items,it's about three array accesses.<br><br>2. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br><br>3. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>4. Every time you hit a power of 2, you takethat many array accesses, but in a sense, you've already paid forthem by putting those items on the stack.<br><br>5. So that's, in array accesses forthe copy, there's two array accesses.<br><br>6. This plot is another way of looking at it, which is the number of array accessestaken as you implement push operations.<br><br>7. So that's the proposition Mergesort usesat most N lg N compares and 6 N lg N array accesses tosort any array of size N.<br>
happy|sentence cnt : 4 <br> <br>1. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>2. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>3. And then, it's up to the client when it pops something off theapple stacks to cast at the apple to keep the type checking system happy.<br><br>4. So that brings us to this summary where red-blacktrees, we were happy with a log based two of N for search and insert with separatechaining, you can really get it down to a constant number of operations for searchand insert.<br>
associated|sentence cnt : 39 <br> <br>1. And if it does, print the value associated with the key.<br><br>2. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>3. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>4. Give me the minimum key, give me the largest key, andthen I can get the value associated with that using that.<br><br>5. And then find the index associatedwith the key that we're searching for using binary search.<br><br>6. A search key and get all the associatedinformation.<br><br>7. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>8. And then, if we want to look up theIP address associated with a given URL we can just type in URLs and the client willreturn the IP address, it'll do the look up.<br>
claiming|sentence cnt : 1 <br> <br>1. Andagain nobody's claiming that this is easy but this is the Physics part and it'sworked out and it comes from Newton's Second Law.<br>
illustrates|sentence cnt : 4 <br> <br>1. The idea though is that this example illustrates that good sortingalgorithm gives us a good convex hull algorithm.<br><br>2. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>3. So this well illustrates that youneed to use all of the data in the hash function and sometime we do a closeranalysis.<br><br>4. And so this, this traceillustrates how we always make some progress and eventually we get the filesorted.<br>
accommodating|sentence cnt : 1 <br> <br>1. So the tree grows from the bottomin the little side to side motion it's just accommodating room for each new keyas it's added.<br>
midnight|sentence cnt : 1 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br>
figuring|sentence cnt : 6 <br> <br>1. So figuring outthe value of dt that would really work is a huge problem for the time drivensimulation.<br><br>2. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br><br>3. And, sothere was quite a bit of effort, devoted to figuring it out, how full we could getthe hash table, in linear probing.<br><br>4. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>5. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>6. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br>
concentrated|sentence cnt : 1 <br> <br>1. They the expected number of comparisons isconcentrated around this value.<br>
cycling|sentence cnt : 1 <br> <br>1. And we use the same idea as for 2d trees,but instead of just cycling through horizontal vertical, we cycle throughhowever many dimensions there are.<br>
paradoxically|sentence cnt : 2 <br> <br>1. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br><br>2.Increases the number of exchanges paradoxically, cuz more exchanges arerequired when the partition is right in the middle.<br>
blacklist|sentence cnt : 2 <br> <br>1. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>2. They'reblacklist, and we want to take them out of our source file.<br>
sending|sentence cnt : 1 <br> <br>1. And then just look at the M atthe end but by sending up the problem, I already kind of ruled that one out becausewe don't have the space to sort them all, to store them all.<br>
facts|sentence cnt : 2 <br> <br>1. And the algorithm that we're going to look at, called the Grahamscan is based on those two facts.<br><br>2. This is oneof those mathematical facts that seems obvious but then if you try to prove thatmaybe it's a little more subtle than you think.<br>
choosing|sentence cnt : 3 <br> <br>1. This alternative of choosingbetween linked structures and arrays is fundamental, andit's going to come up again and again when we consider more complicateddata structures and algorithms.<br><br>2. And what's worse, if you try to fix it by say, randomly choosing between the left and the right.<br><br>3. They [cough] used what's called a method for choosingpartitioning element called Tukey's ninther.<br>
merged|sentence cnt : 4 <br> <br>1. The x's depth will increase by one, when its tree, T1 inthis diagram, is merged into some other tree, T2 in this diagram.<br><br>2. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>3. And with just changing one value in the arraywe get the two large components emerged together.<br><br>4. So, we've got an array A and its firsthalf is sorted and its second half is sorted and the computation we need toperform is to replace that with the sorted array where those two sub-halves aremerged together.<br>
space|sentence cnt : 59 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>3. But we have to use a little extra time andspace to deal with the links.<br><br>4. This does not include the space for the strings themselves,which are owned by the client.<br><br>5. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>6.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>7. We have less wasted space and probablyfaster implementation of each operation.<br><br>8. It's optimal with respect to both space and time.<br>
parallel|sentence cnt : 7 <br> <br>1. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>2. Maybe the value in a parallel array.<br><br>3. Use parallel arrays [inaudible] and thevalue array with the same index.<br><br>4. Maybe your computer is parallel and the sort has to be paralleland we found that equal keys make a huge difference.<br><br>5. If it's there, then we return the valuewith the same index and parallel array.<br><br>6. And we use parallel arrays forthe value in the keys.<br><br>7. So, for binary search, [COUGH] what we're going to do is usean ordered array and actually use parallel arrays, one forthe keys and one for the values.<br>
fundamental|sentence cnt : 14 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2. A fundamental andextremely important data type that have led to all kinds offascinating implementations and we're going to look at severalof them in this course.<br><br>3. Today we're going to talk aboutalgorithms and data structures for implementing some fundamental datatypes called bags, queues, and stacks.<br><br>4.Next we're going to consider addressinganother fundamental defect in the implementations we've considered so farthat those implementations are only good for strings.<br><br>5. So, range searching is a veryimportant fundamental operation.<br><br>6. This alternative of choosingbetween linked structures and arrays is fundamental, andit's going to come up again and again when we consider more complicateddata structures and algorithms.<br><br>7. So those are just a couple of examples, this is a very fundamental andbasic abstraction.<br><br>8. And that's a fundamental problemthat we have to deal with in array implementations in all sortsof algorithms data structures.<br>
confident|sentence cnt : 1 <br> <br>1. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
obviously|sentence cnt : 3 <br> <br>1. So that's obviously a verydesirable characteristic.<br><br>2. Which isobviously much higher than we want.<br><br>3. Obviously, not practical toaddress such a problem on today's computer.<br>
principal|sentence cnt : 1 <br> <br>1. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
evenly|sentence cnt : 5 <br> <br>1. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>2. Essentially if you have M entries in the hash table and Mkeys the link of list you're going to look at is about N over M cuz they're evenlydistributed.<br><br>3. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br><br>4. And this is absolutely a fine methodthat is not that difficult to implement, in the case that the pointsare evenly distributed.<br><br>5. Unfortunately, it's usually the case in geometric data that the pointsare not evenly distributed.<br>
customized|sentence cnt : 3 <br> <br>1. In the standard built-in types ofthe Java language we're going to have those customized implementations andwe can rely on them doing what we expect.<br><br>2. So Java has a customized implementationsfor the standard data types that people would use for similar table keysand that's the sweet spot for hashing.<br><br>3. The client programs usually havecustomized implementations that are based on comparing some sort of value.<br>
desire|sentence cnt : 2 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>2. Plugging in N log N we get the desiredresult.<br>
select|sentence cnt : 52 <br> <br>1. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>2. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>3. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br><br>4. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>5. That's the a Quicksort like implementationsolving the selection problem.<br><br>6. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>7. Now, if the array is partiallysorted, it doesn't matter to selection sort.<br><br>8. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br>
reset|sentence cnt : 12 <br> <br>1." And many programmers live by that kind of preset.<br><br>2. And that will reset our instance variable, which is our stack,to this new, bigger array.<br><br>3.And by the way, if we find a key that's in the tree already, then we just want toreset the value.<br><br>4. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br><br>5. We have an inter-for loop that for j, if it finds asmaller one, resets min and then once we've looked at all the elements to theright of i we exchange the smallest one with i.<br><br>6. And insertionis not much more difficult if you do the same thing and if you find a node wherekey equal to key on the link list, reset the value and return.<br><br>7. If the key's there, it just resets the value.<br><br>8.If the key's already in the tree then we're just going to reset the value.<br>
niklaus|sentence cnt : 1 <br> <br>1. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br>
switchery|sentence cnt : 1 <br> <br>1. So it's recursive argument switchery toget the job done.<br>
partitioning|sentence cnt : 87 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So the goal is socalled three way partitioning.<br><br>3. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>4. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>7. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>8. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br>
swaps|sentence cnt : 1 <br> <br>1. And now, we know they're in orderbut the program doesn't so we have to look and decide that i and n are the same andthen it swaps it with itself and does the same thing for the last.<br>
manipulations|sentence cnt : 2 <br> <br>1.Now, the constant depends on the implementation, exactly what kind ofmanipulations we need to do to convert, 3-nodes to 4-nodes and so forth.<br><br>2. so let's look at the just the global properties that thesemanipulations preserve.<br>
talked|sentence cnt : 13 <br> <br>1. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>2. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br><br>3. We've talked about six different sorting algorithms.<br><br>4.Then, we've talked about a bunch of attributes.<br><br>5.Now, we'll take a look at how the sortingalgorithms that we talked about or expressed in the systems that we useeveryday.<br><br>6. We took two sorted subarrays and we talkedabout an abstract in place merge but we didn't have anactual in place merge.<br><br>7. And it's, quite straightforward, given the demo thatwe talked about.<br><br>8. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br>
containing|sentence cnt : 19 <br> <br>1. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>2. Nine and four, So now four is the root of the tree containing four is eight.<br><br>3. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>4. Union is more difficult in order to merge the components, containingtwo given objects.<br><br>5.And the root of tree containing nine is nine.<br><br>6. So again, we take thefirst item and make it a child of the root of the tree containing the second item.<br><br>7.The 2-node containing H, Right link is null,So we convert that 2-node into a 3-node and now we have a legal 2-3 tree.<br><br>8. And this idea is that, well, when we're tryingto find the root of the tree containing a, a given node.<br>
results|sentence cnt : 5 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. And those are just examples ofclassic results from combinatorial analysis that help us understandwhat happens when we do this, which is what we're doing with hashing.<br><br>3.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br><br>4. Now, you have to takethese results in context.<br><br>5. So , what we want to take from thesetheoretical results is, is a guide when we're looking at implementations andtrying to solve practical problems.<br>
wants|sentence cnt : 1 <br> <br>1. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br>
subordinates|sentence cnt : 1 <br> <br>1. And that's maybe a little bit what happens when a new boss is hired from the outside and then the two subordinates struggle to take over that position and then the boss would get demoted to it's level of competence.<br>
union|sentence cnt : 53 <br> <br>1. So, how are we going to do better? Our first attempt is analternative called, Quick-union.<br><br>2. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>3. So that's a few callsto Union but that's easy to implement.<br><br>4. For the union implementation, we're going tomodify the code to check the sizes.<br><br>5. Alright, so now let's look at the code for implementing Quick-union.<br><br>6. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>7. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>8. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br>
lectures|sentence cnt : 3 <br> <br>1. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>2. And then wow, what are we getting the sortefficient, done efficiently? Well, we could use Shellsort but actually in thenext couple of lectures and we'll look at classical sorts - Mergesort and Quicksort -that we could use.<br><br>3. In this and the next few lectures,we're going to look at symbol tables.<br>
another|sentence cnt : 94 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>3. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>4.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>5. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>6. And all it does is divides by 2 again andthen throws out another 1.<br><br>7. And then another thing that you mightwant to do is iterate through all the keys in the table.<br><br>8. Then on another pass through, we can takethe E, M and the G, R and merge them together to make EGMR, and the E, S and theO, R merge those together to make EORS, and so forth.<br>
production|sentence cnt : 2 <br> <br>1. But it doesn't incur any extra cost at allin production code.<br><br>2. So, the best practice is to use insertionsjust as we did in that example with merge and to assume that they're not going to be there inproduction codes.<br>
intermix|sentence cnt : 2 <br> <br>1. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>2. And since as with stack and queue operations, theseinsert and deletes might be intermixed in arbitrary ways and there might be hugenumbers of them either one of these is very attractive because they're going totake N times the number of operations.<br>
artificial|sentence cnt : 1 <br> <br>1.This seems like an artificial kind of input but actually we'll look at anapplication even in this lecture.<br>
movies|sentence cnt : 2 <br> <br>1. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br><br>2. They're used for movies andvideo games, for particle collision simulation, they're used to study thegenome, and all manner of other applications.<br>
touching|sentence cnt : 6 <br> <br>1. And,but the problem with that quick find algorithm is that, that would taketen^18th operations, or, say array axises or touching memory.<br><br>2. So they have to touch in a constantproportional to n times after touching array entry.<br><br>3. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br><br>4. We're touching all the nodeson the path from that node to the root.<br><br>5. Andalso nobody racks up a, a set of billiard balls such that all fifteen are touchingin all places.<br><br>6. And to just show that this thing gets thesort done with touching relatively few elements.<br>
invented|sentence cnt : 5 <br> <br>1. This method was invented in 1961 by TonyHore, who won the Turing Award in 1980 for this and other work.<br><br>2. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>3. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br><br>4. This is one of the oldest sortingmethods invented by Shell in 1959.<br><br>5. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br>
college|sentence cnt : 1 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br>
explicit|sentence cnt : 10 <br> <br>1. All right, so there is equalities, now equality again we're going toget a programming language issue but still was important to be explicitabout what's going on with equality.<br><br>2. But it's worthwhile to state them explicitly andmake sure that our algorithms maintain them.<br><br>3. So we don't need explicit links at all to represent these data structures, we can just use array indices.<br><br>4. We don't actually have explicit representation oflinks or links in trees or just references to nodes.<br><br>5. For Binary Search Trees we're going to talkabout actually explicit tree data structures.<br><br>6. You could implement this bybuilding explicit links but the an easier thing to do is to know that every node isreferenced by just one link in a tree the one from it's parent.<br><br>7. Butthis time, we h ave some guarantee that no item is too far from the root and we'lltalk about that explicitly in a second.<br><br>8. In fact, you can always use an explicit stack to make a recursiveprogram non-recursive.<br>
displaced|sentence cnt : 1 <br> <br>1. If occupied you, youreinsert the displaced key into its alternative.<br>
processed|sentence cnt : 3 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. First, an integer which is the number of objects that are going to beprocessed.<br><br>3. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
linux|sentence cnt : 2 <br> <br>1. And it's also, used in the, Linux kernel,and in many other systems.<br><br>2. Linus Torvalds, who created lin, Linux, saysthat the difference between a bad programmer and a good one is whether heconsiders his code or his data structures more important.<br>
kind|sentence cnt : 79 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>3." And many programmers live by that kind of preset.<br><br>4. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>5. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>6. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>7.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>8. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br>
today|sentence cnt : 22 <br> <br>1. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>2. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>3. And there's anothersurprising situation that happens in today's world.<br><br>4. Today we're going to talk aboutalgorithms and data structures for implementing some fundamental datatypes called bags, queues, and stacks.<br><br>5. Today, we're gonna take alook at a number of interesting applications of symbol tables and thebinary search tree data structure to address problems with processing geometricdata.<br><br>6. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>7. So, the system designer, Jon Bentley was one of the designers totake a look at these problems and that lead ultimately to the development of the3-way quick sort that were used today.<br><br>8. Today, we're going to lookat Priority Queues which is a variant of sorting that generalizes the idea toprovide more flexible data structure that we can use for all sorts of applications.<br>
algorithms|sentence cnt : 129 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. And, I might add, the algorithms that process them.<br><br>3. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>4. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>5. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>6. As far as the algorithms go, as far asthe rules go, you can always return 17.<br><br>7. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>8. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br>
lefts|sentence cnt : 6 <br> <br>1. So first we search the leftsub-tree that's the one below.<br><br>2. A would go to the left of E two lefts in a row so we have to rotate thatto right.<br><br>3. But if the maxendpoint in the left sub-tree is less than low, that means every interval in the leftsub-tree has a max endpoint less than mah, low, and so therefore it can't intersect.<br><br>4. But we don't to look at the leftsubtree of e because all of those are less than e and therefore are less than f.<br><br>5. So now we'll search the leftsubtree of 4 first because the query point is to the leftof that splitting line.<br><br>6. They donot intersect, so now, what are we gonna do next? Well we're gonna compare the leftsub-tree, and it's Not, 22 falls within our interval so it's not less than'r' sothere might be an intersection there so we better go to the left, so we do go to theleft.<br>
searches|sentence cnt : 9 <br> <br>1. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>2. So here's abinary search tree let's do a demo of what different searches will look like in thistree.<br><br>3. In web searches.<br><br>4. And then the,range search, in the binary tree, for each, each one of the range searches.<br><br>5. We don't want our searches to take that long.<br><br>6. Say well, we'll leave the key in the tree to guide searches, but we won't count it as being in the symbol table.<br><br>7. And because the interval search trees take logN for every operation, the insert and delete intervals is N log N totaled andthe searches is N log N + R log N.<br><br>8. And then when you get to anexternal node you just look for and so that's a, that's the all searchesterminated in external node, in other words that's just a generalization of whatwe just did.<br>
children|sentence cnt : 38 <br> <br>1. And now this one's not heap ordered, so we have toexchange over the largest of its two children.<br><br>2. We figure out which of the children is larger.<br><br>3. There is that compareare the two children bigger, then compare.<br><br>4. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>5. And so, it's larger than, it's bothchildren, and the larger of the two children is T, so we promote the T.<br><br>6.That is, we allow for the possibility of something called a 3-node that can holdtwo keys, But then it has to have three children.<br><br>7. For whatever reason a parent becomes the key and decreases, it might become smaller than one or both of its children's.<br><br>8. Now, that element which went from the bottom to the top is most likely going to violate the heap order, it's going to be smaller than one or its both of its children, so we do a sink.<br>
dealing|sentence cnt : 7 <br> <br>1. So we'll, we'll come back to dealing withthat worse case in the next lecture.<br><br>2. So this is, we'll start withone dimension as before and right away you can see that it's a more complicatedproblem than we've been dealing with.<br><br>3. One of the practices that will follow often inthis course is to check our API design before getting too far into dealing withthe problem, by building a client that is going to use the data type that wedevelop.<br><br>4. So we say that we're dealing withkeys that are comparable by simply adding this extents comparable key to ourdeclaration.<br><br>5. So without seeing all the details yo can understand that the same basic ideais going to work in this situation where we're dealing with much, much more memory.<br><br>6. And so it's a simple idea butexpert scientists were struggling with dealing with hugeamounts of geometric data.<br><br>7. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br>
connectivity|sentence cnt : 11 <br> <br>1.Now we'll look at our first implementationof an algorithm for solving the dynamic connectivity problem, called Quick-find.<br><br>2. But simply can'tsupport a huge dynamic connectivity problems.<br><br>3. But that's a quick and elegant implementation of code to solvethe dynamic connectivity problem called Quick-union.<br><br>4. And then with that, simple, relationship wecan use the exactly the code that we developed to go ahead and run a simulationfor this connectivity problem.<br><br>5. The, the dynamic connectivity problem.<br><br>6. So, firstwe'll talk about the dynamic connectivity problem, the model of the problem forunion find.<br><br>7. A set of algorithms for solvingthe so-called dynamic connectivity problem.<br><br>8. For example, in the firstlecture, we're going to talk about the network connectivity problem, where theproblem is, given a large set of items that are connected together pairwise isthere a way to get from one to another with a path through the connections.<br>
boolean|sentence cnt : 4 <br> <br>1.It takes it, boolean condition.<br><br>2. If it's a boolean, they pick out a coupleof particular values that they return, so hashing boolean type,there's only two different values, so it's hard to think about whatyou really might want there.<br><br>3. So you know,typical Java model, what we will do is create a class called UF that contains twomethods, one to implement union, the other one to implement connected, which returnsa boolean.<br><br>4. We have an is empty testwhich returns a boolean.<br>
controlling|sentence cnt : 1 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
cope|sentence cnt : 8 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. So now, this is a recurrence thattelescopes.<br><br>3.And to cope with that we need to do both.<br><br>4.Substitute the previous equation telescope.<br><br>5. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>6. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br><br>7. The proof for this fact is quite beyond thescope of this course but it's still an important fact.<br><br>8. So analysis of 2d trees isa bit beyond our scope.<br>
recurrences|sentence cnt : 1 <br> <br>1. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br>
proven|sentence cnt : 1 <br> <br>1. Now, these are the things thathave to be proven and we're not going to get into the details of geometric proofbut they're intuitive and certainly have no trouble accepting that these things aretrue.<br>
inventor|sentence cnt : 1 <br> <br>1. He's widely accredited as being theinventor of Mergesort.<br>
estimates|sentence cnt : 1 <br> <br>1. So now let's look at the running timeestimates about why we care about Quicksort vs Mergesort.<br>
smallest|sentence cnt : 34 <br> <br>1. Now the one pointed to my i, the G is smallest so move that and increment iand k.<br><br>2. Then wehave a for loop that goes through every element in the array, we keep a variablemin in that is the index of the going to be the index of the smallest element tothe right of pointer i.<br><br>3. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br><br>4. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>5. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br><br>6.Whenever we get a new one, then we throw away the smallest one that's there.<br><br>7. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br><br>8. Because if you're looking for thesmallest, you can just go through the array and find the small or the smallestin one pass through or if you're two, you'll find it and two passes through.<br>
convince|sentence cnt : 8 <br> <br>1. Andso, I think most students have had high school Physics and will be able to do, dothis Math or at least be convinced that the code that does this Math is correct.<br><br>2. And that's easyto convince ourselves of that just from, from what we did in the demo.<br><br>3. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br><br>4. And that's really easy to convince yourself that that's true because the height if we add nodes one at a time going from left to right on the bottom level say, the height only increases when N is the power of 2.<br><br>5. You can [cough] convinceyourself with that quite easily.<br><br>6. It's a little mind bending atfirst because of the recursive structure but it won't take you long to convinceyourself that this little bit of extra code completes the implementation ofleft-leaning red-black trees.<br><br>7. We should convinceourselves really that it always works and so we'll spend just a moment on a shortproof.<br><br>8. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br>
unlimited|sentence cnt : 1 <br> <br>1. So what hashing is kind of inthe real word where we're trying to tradeoff this idea that wedon't have unlimited space and we also don't unlimited time sowe're trying to find something in-between.<br>
considers|sentence cnt : 1 <br> <br>1. Linus Torvalds, who created lin, Linux, saysthat the difference between a bad programmer and a good one is whether heconsiders his code or his data structures more important.<br>
involves|sentence cnt : 16 <br> <br>1. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br><br>2.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>3. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>4. And again it involves allthe characters of the string in computing the hash function.<br><br>5. Do the sync operation on E which involves promoting the larger of its twochildren, until it gets to the bottom, or a place where it's larger than both itschildren.<br><br>6.All of this involves the scientific method.<br><br>7.Each one of these union operations just involves changing one entry in the array.<br><br>8. So, here's another one that involves, remember, wepassed that red link up.<br>
glue|sentence cnt : 1 <br> <br>1. So, what we are going to do is use internalleft-leaning links to glue the three nodes together.<br>
generically|sentence cnt : 1 <br> <br>1. Now this isn't legal in Javaif key is not an int and we're going to do this generically,it can be any type of data.<br>
discussed|sentence cnt : 1 <br> <br>1. So our best practice that we recommend is so few thatthese basic data structures that we use and there's so simple is to go ahead anduse the implementations that we've just discussed for these fundamental datastructures.<br>
dividing|sentence cnt : 4 <br> <br>1.And working from left to right, by dividing each sub-array in half as itgoes.<br><br>2. So it's dividing by N.<br><br>3. Solve a problem by dividing it into two halves, solvingthe two halves, and then putting the solutions together toget the appropriate answer.<br><br>4. Well one easy way to doit is to just think about dividing space into a grid of squares.<br>
effectively|sentence cnt : 3 <br> <br>1. It generalizes thestack and the queue and gives us a data structure that we can use to effectivelydesign algorithm of all sorts.<br><br>2. Another importantreason is that if you know effect, how to effectively use algorithms and datastructures you're going to have a much better chance at interviewing for a job inthe technology industry then if you don't.<br><br>3. Maybe later, later on, after an experienced programmer who knows whathe or she is doing could use some of these library collections effectively.<br>
amino|sentence cnt : 2 <br> <br>1.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br><br>2. And certain codons have names, that's theamino acids.<br>
blended|sentence cnt : 1 <br> <br>1. With the forwards tongues of the twobefore and that were blended in after.<br>
seconds|sentence cnt : 7 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>3. And we just say, we're going to update everything every dt seconds.<br><br>4. The computers get bigger but they get faster so to toucheverything in the memory is going to take a few seconds.<br><br>5. We can do it in six seconds.<br><br>6.So, if you know that you have a particle that's at a certain position or x or y andhas got a certain velocity, the x in the x-direction and y in the y-direction, thenyou can from the distance to the pro, vertical wall you can figure out how manyseconds this is going to take until it hits it.<br><br>7. You could spendmillions on a super computer, and maybe you could get it done in six years insteadof 30, or in two months but with a fast logarithm, you can do it in seconds, inseconds on your own PC.<br>
conventional|sentence cnt : 1 <br> <br>1. Nowuntil the 1990s, conventional wisdom among people implementing system was, wasn'tworth doing this.<br>
ready|sentence cnt : 30 <br> <br>1. And in all of these cases where we're on a node that alreadyexisted, we just want to return the link to that node.<br><br>2. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>3. Notice already that will meanwhen we get back to 0.<br><br>4.Eight and nine are already connected.<br><br>5.And by the way, if we find a key that's in the tree already, then we just want toreset the value.<br><br>6. Now, because it's 7-sortedand a 3-sort elements are either already in placed or on a go back a fewstrides.<br><br>7. Pull off the first E,it's already heap ordered.<br><br>8. And we've already looked atan algorithm that can do this, and that's binary search.<br>
encloses|sentence cnt : 2 <br> <br>1. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>2. There's a geometric object calledthe Convex Hull which is the smallest polygon that encloses all the points.<br>
procedure|sentence cnt : 6 <br> <br>1. Alright, so with that mergeimplementation, then the sort implementation is a quite simple,recursive procedure shown here.<br><br>2. We need those procedures that implement those Physics rules for everyparticle.<br><br>3. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>4. So [cough] thisis the get procedure.<br><br>5. So we use the merge procedure we justshowed, and then our sort procedure.<br><br>6. Okay, so that's the procedures that weneed and then they're similar ones for the horizontal and vertical walls.<br>
exception|sentence cnt : 17 <br> <br>1. So that now, we have our set ofexceptional words.<br><br>2. And what assert will do is it will throwan exception unless that condition is true.<br><br>3. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>4. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br><br>5. And in yourexceptional list would be words that are in the dictionary.<br><br>6. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>7. That's an example of a, anexception filter.<br><br>8. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br>
particles|sentence cnt : 36 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>4. There's do this prediction for every one of the particles.<br><br>5. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>6. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>7.Because if we have a computational process that takes quadratic time, then it's notgoing to scale, we're not going to be able to do large number of particles.<br><br>8. When you have two particles there's definitely moremath.<br>
comfortable|sentence cnt : 1 <br> <br>1.You can use your own programming environment if your comfortable with oneor you download ours.<br>
deleting|sentence cnt : 5 <br> <br>1. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>2. So like deleting R in this tree, it only has one child.<br><br>3. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>4. What about deleting the minimum? Well actually, that's maybe not too difficult.<br><br>5. And same for deleting.<br>
occupied|sentence cnt : 8 <br> <br>1. The white is the unoccupied part.<br><br>2. So the black is theoccupied part of the page.<br><br>3. Sixis occupied.<br><br>4. We look at seven, seven is occupied.<br><br>5. If occupied you, youreinsert the displaced key into its alternative.<br><br>6. And he was able to show, and we'll talk just a little bitabout this, that if, there's, only half of the parking spaces are occupied, then, onaverage, half the people find, find it after one place and the other half have tolook one extra.<br><br>7. P hashes tofourteen, 14's occupied, 15's also occupied, now we run off the end of thetable, and look at zero, and that's empty so we put it there.<br><br>8. So now we look at four, and that's occupied, so we can't put the Hthere.<br>
implementation|sentence cnt : 251 <br> <br>1.That's a complete implementation of Quicksort.<br><br>2.But the other test is not in our implementation.<br><br>3. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>4. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>5. So the clustering in the data is going tomake the implementation inefficient.<br><br>6. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>7. So this is a simple test client thatwe can use to test our implementations.<br><br>8. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br>
poin|sentence cnt : 277 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>4. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>5. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>6. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>7. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>8. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br>
randomly|sentence cnt : 16 <br> <br>1. So if the points are randomly distributed,then this is ideal.<br><br>2. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>3. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>4. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>5. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>6. And you can see that for a large arraythat's randomly ordered, the element that we put into place is going to goabout halfway back on the average.<br><br>7. So that's an animation forrandomly ordered items.<br><br>8. We start with therandomly ordered input and you can see that it gets more and more in order oneach time that we h-sort for the decreasing values of h.<br>
doubled|sentence cnt : 2 <br> <br>1. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>2. So, you might think, well,we doubled it when it was full, why don't we cut it in halfwhen it gets to be half full? We don't want the array to get too empty.<br>
bits|sentence cnt : 8 <br> <br>1. They convert to 64-bit, and x or the most significant 32-bits withthe least significant 32-bits.<br><br>2. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>3. Somethings are wires, and some things are switches that, are used to, implementmemory bits and computer logic.<br><br>4. It's possible soyou have to just take the 31-bits.<br><br>5. This is just do mod M andif M is a prime then from that modular arithmetic we know that we're using allthe bits in the number in that point to.<br><br>6. So if it's an integer the hashcodes suppose to be 32-bits, integer supposed to be 32-bits.<br><br>7. Trying to take all the bits andscramble all the bits and use them.<br><br>8. The bitswere really expensive, and people wanted to make sure, that they were making bestuse of the memory.<br>
promoted|sentence cnt : 1 <br> <br>1. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br>
narrower|sentence cnt : 1 <br> <br>1. So this is a simpler, narrowerAPI but still it expresses an important little collection of operations and, andwe'll use this one and we've already seen the implementations.<br>
eliminate|sentence cnt : 3 <br> <br>1. That's the swim operation to eliminate violation when a key value increases.<br><br>2. Now, in this case, to implement delete max we save away that value at the root in max, and we eliminate loitering by nulling out that vacated position, then return the max value.<br><br>3. Again just a few lines of code to eliminate the violation when a key value in a heap decreases.<br>
flexibility|sentence cnt : 3 <br> <br>1. So, the 2-3 tree is a way to generalizeBSTs to provide the flexibility that we need to guarantee fast performance.<br><br>2. And again, that level of flexibility, here's the implementation of it.<br><br>3. And that's going to give us the flexibility that we need to implement priority queue operations.<br>
spot|sentence cnt : 3 <br> <br>1. And in this case it's H, and we put that node in T spot and then delete the minimum.<br><br>2. so, with the, more [COUGH] complex userinterface, this is, very much what the spotlight or find functionon your computer is doing.<br><br>3. So Java has a customized implementationsfor the standard data types that people would use for similar table keysand that's the sweet spot for hashing.<br>
tables|sentence cnt : 40 <br> <br>1. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>2. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>3. So here's the review of where we were withsingle tables.<br><br>4. And so that's really are thekey to thinking about what are symbol table and symbol tables in general.<br><br>5. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>6. And so, symbol tables provide us with a way to provide a moreefficient implementation of, of this process when we have lots of zero entries.<br><br>7. And our data structure then will be a root thatpoints to a node in the tree and then that node will point to subtrees and that willbe the data structure that we use for symbol tables.<br><br>8. So symbol tables are ST is the type,symbol table, they're generic in key and value.<br>
still|sentence cnt : 41 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. So first we exchange it with the 10,it's still not in place, so we exchange it with the 7.<br><br>3. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>4. That's still a BST.<br><br>5. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>6. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>7. X's color is stillgoing to be h's color.<br><br>8. That doesn't work i, t still becomes square root of n.<br>
lifo|sentence cnt : 1 <br> <br>1. That's also called the LIFO discipline,last in, first out.<br>
beneath|sentence cnt : 1 <br> <br>1. When we continue toimplement sorting algorithms, we're actually even in a hide that beneath ourown implementations.<br>
switched|sentence cnt : 1 <br> <br>1. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br>
implementations|sentence cnt : 83 <br> <br>1. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. So this is a simple test client thatwe can use to test our implementations.<br><br>4. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>5. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>6. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>7. That's the a Quicksort like implementationsolving the selection problem.<br><br>8. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br>
wire|sentence cnt : 3 <br> <br>1. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>2. Somethings are wires, and some things are switches that, are used to, implementmemory bits and computer logic.<br><br>3. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br>
underlying|sentence cnt : 3 <br> <br>1.Okay, next we'll briefly considerqueue implementations using the same basic underlying data structures.<br><br>2. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>3.Now, we're going to take a look at orderedsymbol table operations using the binary search tree data structure as theunderlying implementation.<br>
pulling|sentence cnt : 2 <br> <br>1. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br><br>2. Pulling off the largest elementfrom the heap.<br>
telescopes|sentence cnt : 2 <br> <br>1. So now, this is a recurrence thattelescopes.<br><br>2. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br>
streaming|sentence cnt : 1 <br> <br>1. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br>
remove|sentence cnt : 42 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>3. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>4. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>5. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>6. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br><br>7. To remove a key, and maybereturn the number of keys in the set, and also have an iterator to iterate throughkeys in the set.<br><br>8. The Java also allows remove().<br>
depended|sentence cnt : 1 <br> <br>1. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br>
chasing|sentence cnt : 1 <br> <br>1. Now we have a private method that implements thisprocess of finding the root by chasing parent pointers until we get to the pointwhere I is equal to ID of I, and if it's not equal, we just move I up one level inthe tree, set I equals ID of I and return it.<br>
kept|sentence cnt : 2 <br> <br>1. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>2. And their in,kept in sorted order.<br>
elegant|sentence cnt : 4 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. So and then whenyou're done then simply print out the value on the stack and that's a fine andelegant implementation using stacks for any arithmetic expression.<br><br>3. But that's a quick and elegant implementation of code to solvethe dynamic connectivity problem called Quick-union.<br><br>4. There's another facility that Javaprovides that leads to very elegant compact client code that's definitelyworthwhile to add to our basic data types and that's iteration, that's what we'regoing to talk about now.<br>
strings|sentence cnt : 42 <br> <br>1. And so, this client readsstrings from standard input.<br><br>2. This does not include the space for the strings themselves,which are owned by the client.<br><br>3. And now build asimple table that associates strings with strings.<br><br>4. In all possible ways, andyou can get two to the N strings, for any N of length to N that all hash to the samevalue.<br><br>5. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br><br>6.sort is a method that takes anarray a as its parameter and it, it's the first argument and it rearranges thestrings in that array to be in sorted order.<br><br>7. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>8. Here's maybe a more familiar sort client that sort strings.<br>
geographic|sentence cnt : 1 <br> <br>1. Again, it's not too good to use the firstthree digits because they're associated with some geographic region andit's better to use the last three digits.<br>
style|sentence cnt : 3 <br> <br>1. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br><br>2. Even if you are familiar with linkedlists, it's worth taking a look at this code because it's the style of codingthat we'll use throughout the course for much more complicated data structures.<br><br>3. And we'll be very disciplinedin our use of this style.<br>
intervening|sentence cnt : 1 <br> <br>1. And then again, we need an, is valid to check aboutintervening collision.<br>
intuitively|sentence cnt : 2 <br> <br>1. You can think of it intuitivelyas like a dictionary.<br><br>2. But intuitively, we can see kind of whathappens each partitionings that maybe splits the array approximately in half.<br>
mcilroy|sentence cnt : 2 <br> <br>1. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>2. Mcilroy, himself,actually found this problem that you could while the sort is running figuring out aninp ut that would make it crash.<br>
nearly|sentence cnt : 3 <br> <br>1. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>2. So we need to remove this cheat andwe will, but the code is nearly trivialif we have the capacity.<br><br>3. And all of these things allow us to makebetter use of memory, allows the table to become nearly full.<br>
adopted|sentence cnt : 1 <br> <br>1. There's versions ofmerge sort that come close but they are too complex for practitioners to haveadopted them.<br>
ends|sentence cnt : 15 <br> <br>1.Plus what happens next depends on what the partitioning element was.<br><br>2. Notice again that it depends on the randomshuffle at the beginning that's going to be important for performance.<br><br>3. We say that our generic type Key extendsComparable of Key.<br><br>4.Now, the constant depends on the implementation, exactly what kind ofmanipulations we need to do to convert, 3-nodes to 4-nodes and so forth.<br><br>5. It depends on the arraybeing randomly ordered.<br><br>6. And as we'll see this extendsto a practical problem in a number of situations.<br><br>7.K is less than L, so the search ends at the left link of L.<br><br>8. Then, how about space usage? That depends very much onthe implementation and the machine so this is a typical Java implementationthat we do the analysis for.<br>
compares|sentence cnt : 54 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>2. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>3. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>4. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>5. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>6. In thiscase, if c is less than b and a is less than c then those three compares show thatthe order has to be a, c, b and if c is less than a, then it's going to be c, a,b, those three compares that c is less than a, c less than b and a is less thanb.<br><br>7. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br><br>8. On the other hand, maybe there is an algorithm that uses N log N comparesand also uses optimal space.<br>
priority|sentence cnt : 61 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>3. And then that's a time in the futureand we'll put that event on the priority queue with that time as the key.<br><br>4. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>5. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>6. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>7. All right, now the way we're going to use a complete binary trees to implement priority queues is to first of all associate information with each node.<br><br>8. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br>
proved|sentence cnt : 8 <br> <br>1. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>2. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>3. It was proved actually a long time ago even before computer implementations that if you do that, you get a uniformly random permutation and it only takes linear time.<br><br>4. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>5. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>6. And what was provedby Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of Munion and find operations will touch the array at most a c (N + M lg star N) times.<br><br>7. Really what we proved is that mergesort is optimal withrespect to number of compares but we already know that it's not optimal withrespect to space usage.<br><br>8. And as I mentioned, there's been many, many improved versions ofhashing that have been studied.<br>
summary|sentence cnt : 18 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. In fact, maybe ten times what's in the book,including a summary of the content.<br><br>3. And the quicksummary is that every one of those operations, while ordered iteration isoptimal, it just gets them in linear time.<br><br>4. That's the summary for hash functions.<br><br>5.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br><br>6. So, in, in summary.<br><br>7. Here's our summary of where weleft off with red black BSTs.<br><br>8. So that, that, that'sour full summary of sorting algorithms to and completes our treatment of sortingalgorithms with Heapsort.<br>
calculation|sentence cnt : 13 <br> <br>1.So [cough] this is if we implement a point data type for computational geometry, youcan have a method ccw() that just with this little math calculation (b.<br><br>2. It implements the compare method that takes two points as argument and withjust a little bit of calculation is able to do the compare.<br><br>3.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>4. That's the nextcollision that's going to happen from all our calculations.<br><br>5. There's a lot of particlesout in the universe and you can't do a quadratic calculation forlarge N.<br><br>6. It's a little less calculation.<br><br>7. But the other thing is even ifN is small if you do a very small dt, then you're just doing this calculation overand over again and there's just too much computation moving the balls little bit ata time.<br><br>8. So the progress of a scientificinvestigation is going to be affected by how quickly you can do this calculationfor a large number of particles.<br>
compact|sentence cnt : 3 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>3. There's another facility that Javaprovides that leads to very elegant compact client code that's definitelyworthwhile to add to our basic data types and that's iteration, that's what we'regoing to talk about now.<br>
online|sentence cnt : 6 <br> <br>1. And then supporting that textbook, is free onlinematerial that we call the book site.<br><br>2. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br><br>3. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br><br>4. So, during this course you'll be referring tothe book site frequently while working online.<br><br>5. Nowadays you more likelyto do that online or when you're trying to find the song todownload, you provide the name of the song and then the value will tell youwhat computer got her to get that.<br><br>6. So, here's an example of an implementation for online poker.<br>
approximately|sentence cnt : 1 <br> <br>1. But intuitively, we can see kind of whathappens each partitionings that maybe splits the array approximately in half.<br>
simulative|sentence cnt : 1 <br> <br>1.Welcome back, today we're going to talkabout balance search trees, Which will lead us to an ultimate symboltable implementation that can provide fast performance for all the simulative optionswe've looked at, guaranteed.<br>
rock|sentence cnt : 2 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. So, rock, paper, scissors is intransitive.<br>
segment|sentence cnt : 15 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>3. In this case wehit the right endpoint of line segment two.<br><br>4. Sofirst thing is if we hit a horizontal line segment.<br><br>5. And again, as we know,such an algorithm is not going to be practical, for huge numbers of linesegments.<br><br>6. Consider it as aevery time it hits some line segment as an event where we have to do something.<br><br>7. And so,suppose we have a large number of such line segments and what we want to be ableto do is to find all places where they intersect.<br><br>8. So that is, for every line segment,you check whether it intersects with every other line segment.<br>
computing|sentence cnt : 17 <br> <br>1. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>2. So the basic rule is that if you'recomputing your own try to use the whole key but consult an expert if you'reseeing some performance problems.<br><br>3. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>4. The cost of computing the hash function can mean that something like redblack trees will even outperform hashing even for just searching and insert.<br><br>5. So, this is so when we have the GCD function, computing thegreatest common denominator, greatest common denominator p and q is greatestcommon denominator of q and p mod q and it just calls itself until q gets to be zero.<br><br>6. This kind of question plagued a lot ofpeople in this late 60's or early 70's as these types of problems emerge forcomputing applications.<br><br>7. And again it involves allthe characters of the string in computing the hash function.<br><br>8. And that's diffidently one thingto consider when using hashing is that the cost of computing the hash function for acomplicated key might exceed the cost of searching and using a simpler structurelike a binary search tree.<br>
flatten|sentence cnt : 3 <br> <br>1.Now, we'll go up again to just flatten the tree out.<br><br>2. We had one line of code to flatten the tree, amazingly.<br><br>3. Now,that's not quite as good as totally flattening actually in practice that itactually is just about as good.<br>
collector|sentence cnt : 4 <br> <br>1. When does all the bins fill up? That's called the couponcollector problem.<br><br>2. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>3. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br><br>4. And then that first node is ready tobe reclaimed by the garbage collector.<br>
pointed|sentence cnt : 4 <br> <br>1. Now the one pointed to my i, the G is smallest so move that and increment iand k.<br><br>2. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br><br>3.[COUGH] so the first thing we do is, take the smaller of the two entriespointed to by i and j, and compare those, and take the smallest one, and movethat one to be the next item output.<br><br>4. Now we compare the minimum again, again,the one pointed group by j is smaller, so we move that one to k.<br>
accepting|sentence cnt : 1 <br> <br>1. Now, these are the things thathave to be proven and we're not going to get into the details of geometric proofbut they're intuitive and certainly have no trouble accepting that these things aretrue.<br>
randomize|sentence cnt : 5 <br> <br>1. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>2. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br><br>3.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br><br>4. But the problem bycomparison with sorting is, we don't get to randomize the order the client isproviding the keys.<br><br>5. So if we, we aretalking abouta randomized model where the sites are vacant with the givenprobability.<br>
bentley|sentence cnt : 3 <br> <br>1. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>2. So, the system designer, Jon Bentley was one of the designers totake a look at these problems and that lead ultimately to the development of the3-way quick sort that were used today.<br><br>3. So that's John Bentley who discoveredthis while an undergraduate at Stanford.<br>
demoed|sentence cnt : 1 <br> <br>1. So it's worthwhile youknow, checking that you believe that this code implements the simple binary searchtree algorithm that we demoed where when we fall off a null link we created a newnode and replaced that null link with the new node .<br>
compare|sentence cnt : 123 <br> <br>1.compareTo(w) less than zero.<br><br>2.So we move to the left and compare H against the root of the left subtree.<br><br>3. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>4. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>5. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>6. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>7. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>8. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br>
simpler|sentence cnt : 17 <br> <br>1. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>2. Well, let's look at a simpler problem.<br><br>3. Could, could hardly be simpler.<br><br>4. For, and for array,it's even simpler.<br><br>5. First when we look at, seemseven simpler than the regular symbol tables, and that's about sets.<br><br>6. Could hardly besimpler.<br><br>7. And that's diffidently one thingto consider when using hashing is that the cost of computing the hash function for acomplicated key might exceed the cost of searching and using a simpler structurelike a binary search tree.<br><br>8. So given a queryinterval, we want to find all intervals in the data structure that overlap thatinterval or find any interval we'll start with that simpler problem.<br>
framework|sentence cnt : 2 <br> <br>1. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>2. The idea of complexity is it's a framework for studying the efficiency of all the algorithms for solving a particularproblem.<br>
architecture|sentence cnt : 1 <br> <br>1. That's going to be the overall architecture forstudying algorithms that we're going to use throughout the course.<br>
whale|sentence cnt : 1 <br> <br>1. The word whale is only in, Moby Dick.<br>
equal|sentence cnt : 136 <br> <br>1. So we have to be sure we've gotthe method that we want for checking whether two keys are equal.<br><br>2. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>3. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>4. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>7. And this one just uses equals, so the keysdon't have to be comparable for this.<br><br>8. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br>
diagonal|sentence cnt : 4 <br> <br>1. And so the first way we'll look at is called Separate Chainingand it's a very diagonal idea back1953, and the idea is just build a link list foreach of the table positions.<br><br>2. There's N squared over2 below the diagonal, half of that is N squared over 4.<br><br>3. This is a bigger trace that shows, again, about half the elements belowthe diagonal are involved in the sort.<br><br>4. So that means about half the elementsbelow the diagonal are going to be black on the average.<br>
motion|sentence cnt : 3 <br> <br>1. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>2. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br><br>3. So the tree grows from the bottomin the little side to side motion it's just accommodating room for each new keyas it's added.<br>
showed|sentence cnt : 8 <br> <br>1. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>2. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>3. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>4. We have the swim and sink functions that we showed earlier.<br><br>5. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>6. The client is always going to betesting hasNext() as I showed as I showed and that stub code before and so when itgets to null it will return false in the iterational stop.<br><br>7.And these diagrams summarize the sync operations that we showed in the demo.<br><br>8. So we use the merge procedure we justshowed, and then our sort procedure.<br>
ultimate|sentence cnt : 3 <br> <br>1. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>2. So, the system designer, Jon Bentley was one of the designers totake a look at these problems and that lead ultimately to the development of the3-way quick sort that were used today.<br><br>3.Welcome back, today we're going to talkabout balance search trees, Which will lead us to an ultimate symboltable implementation that can provide fast performance for all the simulative optionswe've looked at, guaranteed.<br>
materials|sentence cnt : 2 <br> <br>1. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>2. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br>
interested|sentence cnt : 6 <br> <br>1.If you're interested in implementing this, you can come back to the slide.<br><br>2. And experts debate about that and people who are interested can lookon the web for that kind of date.<br><br>3. People might be interested inthis one.<br><br>4. So, why we are interested in this algorithm? Well, it's a simple ideathat leads to substantial performance gains.<br><br>5. But we're interested in the biggest ones andso maybe it's the biggest amount of dollars, or the biggest cost, or whateverit might happen to be.<br><br>6. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br>
internet|sentence cnt : 4 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>2. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>3.Now, hashing also has a extremely important application in today's Internetcommerce.<br><br>4. From the internet to biology to,commercial computing, computer graphics, security, multimedia, social networks, andscientific applications, algorithms are all around us.<br>
things|sentence cnt : 94 <br> <br>1. These types of things ariseoften in practical applications.<br><br>2. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>3. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>4. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>5. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>6. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>7. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>8. So, let's just take a look at what happens with a real heap with the demo when we do these things.<br>
piece|sentence cnt : 9 <br> <br>1.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>2. But in particular, there's a piece of a recordcalled a key and what we want to do is put the records into order according to thekey.<br><br>3. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>4. And again, we want to try to make useof all the pieces of data that we have.<br><br>5. So we're looking for a piece ofinformation somewhere in a computer, and it'll give us the names of the filesthat contain that information.<br><br>6. Sothat's the first piece of code for heap ordering an array with arbitrary valuesand then these diagrams summarize the sync calls that, that we just went through inthe demo starting at five, four, three, two, one.<br><br>7. And we can keep the root page in memory so that it means, for anyconceivable application, you can get to any piece of data.<br><br>8. Even if it's trillionsof, of pieces of data in this huge, huge file.<br>
joined|sentence cnt : 1 <br> <br>1. it goes to theleft of E, has to be joined with A into a new 3-node.<br>
flipping|sentence cnt : 2 <br> <br>1. And again, that's just flipping colors.<br><br>2. So, that'sflipping the colors.<br>
heard|sentence cnt : 1 <br> <br>1. But in thiscase we have to put in this one cast and so what we've heard about that is the uglycast it doesn't, it doesn't make you feel good about the code.<br>
angle|sentence cnt : 49 <br> <br>1. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>2. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>3. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>4. And, and that willgive us now three rectangles on our sweep line.<br><br>5. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>6. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>7. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>8. How to sort the points by polar angle?Well again we need to define what we mean when we're comparing points.<br>
digits|sentence cnt : 4 <br> <br>1. And it's not equally likely that each phone number has the samefirst three digits.<br><br>2. Again, it's not too good to use the firstthree digits because they're associated with some geographic region andit's better to use the last three digits.<br><br>3. Probably a bad idea to use the first threedigits of the phone number as a hash function because so many phonenumbers will have the same area code.<br><br>4. You have a better chanceusing the last three digits.<br>
collides|sentence cnt : 1 <br> <br>1. In such a waythat, it's hard for someone else to find another key that collides with that.<br>
challenges|sentence cnt : 1 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br>
listed|sentence cnt : 1 <br> <br>1. So that's theexception filter, and that's useful in lots of applications such as the oneslisted here.<br>
expensive|sentence cnt : 8 <br> <br>1. Now, it was very expensive.<br><br>2. And this is problematicbecause the union operation is too expensive.<br><br>3. Which would mean that the find operation would be tooexpensive.<br><br>4. That's easy to code up, but not worth it, because it'smuch too expensive to do that.<br><br>5. Whereas, Mergesort has to move the itemsinto and out of the auxiliary array, which is more expensive.<br><br>6. The bitswere really expensive, and people wanted to make sure, that they were making bestuse of the memory.<br><br>7. So very inexpensive and they had macros to do this so and use not too muchcost to find a partitioning element that's much closer to the middle than, and if youuse a, a random one.<br><br>8. But it's too expensive for use, in a symbol table.<br>
unnecessary|sentence cnt : 1 <br> <br>1. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br>
insertions|sentence cnt : 10 <br> <br>1. So by default, insertions are disabled.<br><br>2. And what's interesting about insertionsort is that it runs in linear time for partially sorted arrays.<br><br>3. Again, we can look at insertionsort in terms of invariants.<br><br>4. So, the basic s trategy is, with thoseoperations, maintain one-to-one correspondence with 2-3 trees when we doinsertions.<br><br>5. And simple algorithms like insertions or dump,they've they don't use any extra space at all.<br><br>6. But the other thing is if the increments are small because we'vedone previous h-sorts for bigger values of h, the array is partially sortedand so Insertions Sort is going to be fast.<br><br>7. And this is just for random insertions.<br><br>8. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br>
command|sentence cnt : 15 <br> <br>1. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>2. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>3. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>4. So we could have,billions of objects, and hope to do billions of union commands on them.<br><br>5. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>6. And our simple client is totake some strings on standard input and some pop commands whichare indicated with hyphens.<br><br>7. Okay, so toimplement the operations, we have to find query and the union command.<br><br>8. So, that's our problem, to be ableto officially support these two commands for given set of objects.<br>
violated|sentence cnt : 9 <br> <br>1. That's restoring the heap border along a path from the place where it's violated to the root.<br><br>2. But in general, we have to check whether the heap condition is violated and exchange it with its parent as long as it's smaller.<br><br>3. So,now the invariant might be violated so we have to fix it.<br><br>4. It might be violatedbecause you might have an element to the right of the pointer that is smaller than some, the element on the pointer.<br><br>5. So now, we have to bring the heap order back because it might be violated at the root.<br><br>6. But the heap conditional will be violated because T is still smaller than S.<br><br>7. Swims up to the top, and if we have a node at index k and we know the heap condition is violated there.<br><br>8. And the heap condition is only violated again where H is sitting.<br>
robes|sentence cnt : 7 <br> <br>1. And then we can use, that property of the trees, in theanalysis to, show that, it's not going to be very many probes to get to any key.<br><br>2. You can get to any one with onlyfive or six probes.<br><br>3. So what we want to do is try to access data that's out, externally, usinga minimum number of probes.<br><br>4. Base M over two M probes and that's going to be a really small number, so sayM is a 1000, log base M over two is, is log base 500.<br><br>5. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br><br>6. If it's 9/10's full one over one minus alphasquared is 100 one over 100, so it means it's going to be 50 p robes for a searchmiss if it's 9/10's full, and that's independent of N and M, whereas if it'shalf full then we get the nice.<br><br>7. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
pieces|sentence cnt : 4 <br> <br>1.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>2. And again, we want to try to make useof all the pieces of data that we have.<br><br>3. Even if it's trillionsof, of pieces of data in this huge, huge file.<br><br>4. And these are just pieces of literature.<br>
roughly|sentence cnt : 1 <br> <br>1. Now, let's just talk roughly about what I mean bythat.<br>
pratical|sentence cnt : 1 <br> <br>1. It could be that there aresome increment sequence out there that make Shellsort more efficient than anyother method, any of the sorting method that we know for pratical file size, noone can deny that.<br>
global|sentence cnt : 1 <br> <br>1. so let's look at the just the global properties that thesemanipulations preserve.<br>
treated|sentence cnt : 1 <br> <br>1. There might, if that gets passed up to a three node, thenwe have to continue moving up the tree and just treat it in the same way as we justtreated inserting at the bottom.<br>
surprise|sentence cnt : 2 <br> <br>1. And so, it'san annoying surprise for many people and many applications.<br><br>2. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br>
scary|sentence cnt : 1 <br> <br>1. Littlebit scary for some systems designers.<br>
affected|sentence cnt : 2 <br> <br>1. So the progress of a scientificinvestigation is going to be affected by how quickly you can do this calculationfor a large number of particles.<br><br>2. In particular, just as another example,consider the idea of N-body simulation, which isa classic problem in physics where you've got N particlesmutually affected by gravity.<br>
structur|sentence cnt : 116 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>3. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>4. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>5. You just take stackand remove the pop, or queue and remove the dequeue [cough] and you have fineimplementation of a useful data structure.<br><br>6. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br><br>7. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>8. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br>
implication|sentence cnt : 2 <br> <br>1. And you can think about the implications of that.<br><br>2. So, a sort, it'sworthwhile to take a careful look at what the implication of that is.<br>
scientists|sentence cnt : 5 <br> <br>1. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>2. Now there's four volumes out and moreplanned, and this is where, all computer scientists go.<br><br>3. And so it's a simple idea butexpert scientists were struggling with dealing with hugeamounts of geometric data.<br><br>4. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br><br>5. In the twentieth century, math, scientistsdeveloped mathematical models to try to understand natural phenomenon.<br>
solved|sentence cnt : 5 <br> <br>1. And the other thing we can do with this is just use a red-black BSTto guarantee that we solved this in time proportional to log in.<br><br>2. Try to understand, basically, what are the mainelements of the problem that need to be solved.<br><br>3.Now we'll look at the problem that'srelated to sorting called selection that's also well solved by Quicksortpartitioning.<br><br>4. And then left uswith, applications that, could not be solved without these efficient algorithms.<br><br>5. But with the basic interval search tree algorithmand the sweep line process that we've talked about, you can get the orthogonal,orthogonal rectangle intersection search problem solved in time proportional toanalog N log N + R log N, where R is the number of intersections.<br>
picked|sentence cnt : 3 <br> <br>1. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br><br>2. So,that's why we picked the color red to distinguish red links the types of linksin three nodes.<br><br>3. Now, for a practical situation we picked some kind of, some value of M.<br>
enabled|sentence cnt : 7 <br> <br>1. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br><br>2. This, this kind of stimulation is enabledby priority queues.<br><br>3. So this is a useful and non trivialclient that's enabled by symbol table.<br><br>4. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br><br>5. And really have enabled a new developmentsand new technology in all of these kinds of applications.<br><br>6. And it's enabled by priority queues.<br><br>7.And that definitely enabled new progress in technology and it's a fine example ofthe importance of algorithmic technology.<br>
executable|sentence cnt : 1 <br> <br>1. So, that'sour basic question, how can sort, now, how to compare data of all those differenttypes without being given any information about the type of an item's key? And theanswer is that what is we set up a mechanism known as a callback or referenceto executable code where the client, by passing an array of objects to the sortfunction.<br>
container|sentence cnt : 1 <br> <br>1.>> I thought the red door was the storage container.<br>
significantly|sentence cnt : 1 <br> <br>1. Now that's also simple toimplement and it works well as long the size of the array is, significantly biggerthan the number of keys.<br>
inexperienced|sentence cnt : 1 <br> <br>1. Butinexperienced programmers often have trouble with it.<br>
changed|sentence cnt : 10 <br> <br>1. Then once we've exchangedit, again, we preserved our invariant.<br><br>2. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>3. All those zeros have to getchanged to ones.<br><br>4. We justchanged the way we get to them.<br><br>5. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>6. The 4-node had four links, and the two2-nodes have four lengths, so nothing has to be changed below.<br><br>7. In this case, the value apposition two has changed to H for whatever reason, in that smaller, in this case then both its children.<br><br>8. The invariants are that the entries on ontothe left of the arrow are never changed and they're in ascending order.<br>
polygon|sentence cnt : 5 <br> <br>1. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>2. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br><br>3. It's the smallest convex set that contain all the points,the smallest area of convex polygon enclosing the points.<br><br>4. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>5. There's a geometric object calledthe Convex Hull which is the smallest polygon that encloses all the points.<br>
shrinkage|sentence cnt : 1 <br> <br>1. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br>
forgetting|sentence cnt : 2 <br> <br>1. People have come up with methods forgetting this done.<br><br>2. Infact, there's an argument for just using this implementation of Quicksort andforgetting about horse because it performs so well in so many practical situations.<br>
everybody|sentence cnt : 14 <br> <br>1. In the binary search tree, we have a node at the root and we haveeverybody smaller to the left, and everybody larger to the right.<br><br>2. Seventeen, nineteen is at the root, so everybody with a le ft end pointless than seventeen is to the left, the left end point greater than seventeen isto the right and so forth.<br><br>3. Now we canpair H against the root of the right subtree of E, and that's R and it's lessso we have to go left cuz everybody to the right of R is bigger and H is smaller.<br><br>4.And we have everybody to the left.<br><br>5.And everybody to the right, there's nobody less.<br><br>6. InQuicksort partitioning, after the random shuffling we have the partitioning elementand then we process everybody to the left independently of everybody to the right.<br><br>7. Everybody in the same connectedcomponent as six.<br><br>8. Okay, so again start out in our normal starting position, whereeverybody's in their own tree.<br>
multiplication|sentence cnt : 2 <br> <br>1. But theyallow us to have a much more efficient matrix multiplication method.<br><br>2. So, this is a standard matrix vectormultiplication that you learn in Math where we have a square matrix and a columnvector and we want to do a dot product of, of first row with the column vector to getthe first entry in the result.<br>
defect|sentence cnt : 4 <br> <br>1.Next we're going to consider addressinganother fundamental defect in the implementations we've considered so farthat those implementations are only good for strings.<br><br>2.Okay, our basic array implementationof stacks had the defect where we required clients to provide the maximumcapacity of the stack ahead of time.<br><br>3. Now there's a fundamentaldefect in using an array and that is that you have to declarethe size of the array ahead of time and then so the stack has a certain capacity.<br><br>4. And the defect for Quick-union is that thetrees can get too tall.<br>
applications|sentence cnt : 82 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. There's lots of importantapplications for this.<br><br>3. These types of things ariseoften in practical applications.<br><br>4. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6.And in fact, in many real applications, they're not very random.<br><br>7. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>8. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br>
border|sentence cnt : 1 <br> <br>1. That's restoring the heap border along a path from the place where it's violated to the root.<br>
saving|sentence cnt : 2 <br> <br>1.And as this graphic integrates, it just does it by saving the information on astack.<br><br>2. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br>
remains|sentence cnt : 1 <br> <br>1. So, if you think of all this is,is, is trivial and easy, go ahead and try to write down a proof that a g-sortedarray remains g-sorted even after it's h-sorted.<br>
uses|sentence cnt : 41 <br> <br>1. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>2. And this one just uses equals, so the keysdon't have to be comparable for this.<br><br>3. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>4. It uses actually both quicksort and mergesort.<br><br>5. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>6. On the other hand, maybe there is an algorithm that uses N log N comparesand also uses optimal space.<br><br>7. It just uses equals.<br><br>8. It uses an arithmetic.<br>
closest|sentence cnt : 6 <br> <br>1. So that's the closestpoint that we know about.<br><br>2. So the first point that's the closestwe found so far to the query point, so we'll save our number 1 as the distance.<br><br>3. So in this case our query point isover here in green and our algorithm's going to want to return point 5,that's the closest one to the query point.<br><br>4. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>5. Where's the closest thing? How am I going to findthe closest thing efficiently? What things are nearby and so forth.<br><br>6. So now instead of a rectanglewe have a query point and our goal is to find the closestpoint to that point.<br>
squared|sentence cnt : 17 <br> <br>1. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>2. They're either connectedor not then that will take quadratic time in squared time.<br><br>3. One myse alpha is forthe hit, one myse alpha for the squared for the insert.<br><br>4. There's N squared over2 below the diagonal, half of that is N squared over 4.<br><br>5. Now, but the thing is, foreach pair of particles, so if you have N particles and you have todo it for each pair, that's N squared.<br><br>6. If you take all the points in one square, in 0 and all the rest of them,your average is still N over M squared.<br><br>7. [COUGH] So, the idea andthe consequence of this is, if you insert N items into an array, intoa stack with this array representation, the time will be proportional to N,not N squared.<br><br>8. But in time,much closer to N log N than to N squared.<br>
node|sentence cnt : 297 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. So the heap order condition is satisfied everywhere except at this node.<br><br>3. That's first = new Node.<br><br>4. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>5. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>6. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>7. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>8. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br>
seventh|sentence cnt : 3 <br> <br>1. Thegive me the seventh key we just go and look there, they are in order.<br><br>2. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>3. So now, what about operationslike rank and select? How many keys are there less than a given key? And, give usthe seventh largest key to facilitate implementing those operations and alsosize all we do is keep an extra field in each node, which is the number of thenodes in the subtree rooted at that node.<br>
onerous|sentence cnt : 1 <br> <br>1. In a few applications, this might be fine, but in many many applications,that's too onerous of requirement.<br>
cards|sentence cnt : 11 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>3. Let's look at how that workson our example with cards.<br><br>4. Or like the one at the bottom credit cards.<br><br>5. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br><br>6. But the bottom line is, don't think that it's easy to shuffle a deck of cards.<br><br>7. The ideaof selection sort, is start out with a unsorted array and we'll use these playingcards as an example.<br><br>8. Here's the code that you can find on the web for how to shuffle a deck of cards, that's pretty similar to our code but it's actually got more than a few bugs.<br>
each|sentence cnt : 129 <br> <br>1. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>4. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>5. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>6. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>7. There's only a few instructions foreach one of the operations.<br><br>8. We create the array and then set eachelement to be it's own root.<br>
magnetic|sentence cnt : 1 <br> <br>1. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br>
kernel|sentence cnt : 1 <br> <br>1. And it's also, used in the, Linux kernel,and in many other systems.<br>
canonical|sentence cnt : 2 <br> <br>1. So, that's a canonical example of a, a priority queue client that we need todesign a program that can do that.<br><br>2.So, even with this huge stream of items coming through, we're only keeping trackof the M largest items and that's a fine canonical client for priority queue.<br>
tried|sentence cnt : 2 <br> <br>1. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>2. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br>
strange|sentence cnt : 1 <br> <br>1. It seems strange to be ignoring parenthesis and we'll getback to that in a second.<br>
biologist|sentence cnt : 1 <br> <br>1. And that's an association that'swell known to biologist and then you can use this lookup CSV client to quickly getthe name associated with any given codon.<br>
pointer|sentence cnt : 43 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>3. We'll populate its fields andthen that old link will change that from null toa pointer to the new node.<br><br>4. Then wehave a for loop that goes through every element in the array, we keep a variablemin in that is the index of the going to be the index of the smallest element tothe right of pointer i.<br><br>5. And we start the k Pointer at thebeginning lo.<br><br>6. So we have to look at the code that'sgoing to maintain that invariant as the pointer increments.<br><br>7. And then we're going to maintain an Ipointer that moves from left to right, and a J pointer that moves from right to left.<br><br>8. So we'll maintain two pointers,the first item in the queue and the tail, which is the position forthe next item to appear.<br>
promoting|sentence cnt : 1 <br> <br>1. Do the sync operation on E which involves promoting the larger of its twochildren, until it gets to the bottom, or a place where it's larger than both itschildren.<br>
concordance|sentence cnt : 2 <br> <br>1. Or more generally, people want to oftenprocess, preprocess text to, maybe a huge amount oftext, to support, so called, concordancequeries.<br><br>2. [COUGH] concordance client that that doesthe job.<br>
implements|sentence cnt : 19 <br> <br>1. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>2. Or actually Java implementsthat in its arrays library.<br><br>3. This implementation directly implements thelink list.<br><br>4. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>5. It implements the compare method that takes two points as argument and withjust a little bit of calculation is able to do the compare.<br><br>6. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>7. So it has the infrastructure that allows us tobe used for all types of data types and all types of ordering so it's got a methodthat implements comparable then its got methods easy compare order.<br><br>8. So the codeimplements the invariants.<br>
decrement|sentence cnt : 19 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>3. And to pop, we decrement the index and then use it to returnthe item in the array.<br><br>4. Now, what about when we get one that's greaterthan the partitioning elements? So, in that case, we exchange greater the oneover at the right with i and decrement gt.<br><br>5. So nowwhat happens here, now i is pointing to a bigger one so we're going to exchange itwith the one at gt and decrement gt again.<br><br>6. Then thesecond pass again that's only a two liner, we exchange the first element with the oneat the end and then decrement the size of the heap and then do a sync operations.<br><br>7. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br><br>8. We just go throughstarting at h for i and when we do the insertion, the j loop, we decrement j by heach time, otherwise the code is exactly like Insertion Sort.<br>
scans|sentence cnt : 3 <br> <br>1. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>2. So, for the selection sort, we have a pointer that wasour variable i, that scans from left to right.<br><br>3.Our implementation, we stopped the partitioning scans on items equal to thepartitioning item and then in that case, when all the keys are equal, it's going todivide it exactly in the middle.<br>
relatively|sentence cnt : 5 <br> <br>1. And there's a relatively easy wayto do that.<br><br>2. Even though it emerged asa data structure relatively late in the game now that we see that there are manyalgorithms that are much easier to implement when we think about the prioritykey abstraction.<br><br>3. And this is a fine data structure forsymbol tables where there is, [COUGH] that are relatively static, where the values don't change much,and most of the operations are search.<br><br>4. In a new method called, relativelynew method called Cuckoo Hashing.<br><br>5. And to just show that this thing gets thesort done with touching relatively few elements.<br>
disc|sentence cnt : 29 <br> <br>1. This is not a course on discretemathematics.<br><br>2. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>3. In fact, some were discovered by undergraduates in a course,course like this.<br><br>4. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>5. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>6. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>7. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>8. And that's also call the FIFO discipline,first in, first out.<br>
java|sentence cnt : 106 <br> <br>1. Even though we know we're not using it,the Java system doesn't know that.<br><br>2. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>3. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>4.3 of the book, or in our introduction to programming andJava book.<br><br>5. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>6. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>7. For example Java publishesits hash function.<br><br>8. Or actually Java implementsthat in its arrays library.<br>
precision|sentence cnt : 1 <br> <br>1. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br>
amazing|sentence cnt : 7 <br> <br>1. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>2. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>3. We had one line of code to flatten the tree, amazingly.<br><br>4. That's quite amazing.<br><br>5. Really amazingly simple and efficient algorithm.<br><br>6.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br><br>7. The implementation is amazingly simple.<br>
mailing|sentence cnt : 1 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br>
block|sentence cnt : 9 <br> <br>1.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>2. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>3. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>4. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>5. Where, we work with continuous blocks of data that are big.<br><br>6. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br><br>7. Where a vacant side is just empty and a block side hasgot some material, and either the water flows through from top to bottom, or not.<br><br>8. That's white in the diagram with probablyP or blocked, that's black of the diagram with probability one - P and we define asystem to, we say that a system is percolated if the top and the bottom areconnected by open sites.<br>
error|sentence cnt : 3 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br><br>3. And they had a complex error recovery process that,that got triggered if the height limit got too big.<br>
callbacks|sentence cnt : 2 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>2. There's a lot of different ways toimplement callbacks and that's programming language specific.<br>
entry|sentence cnt : 44 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>3. And three, four, eight, and nine all have entry eight.<br><br>4. If they key's not there,it puts a new entry in.<br><br>5. What about nine and four? So, now we have to change the, to connect nine andfour, we have to change, 9's entry to be the same as 4's.<br><br>6. We're going to do our partitioning so that we get entry a(j) in place of thearray.<br><br>7. In the third case now,when i is at the third entry in the array, now we start a index j, andwe move that starting at i to the left.<br><br>8. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br>
rotation|sentence cnt : 14 <br> <br>1. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>2. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>3. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>4. We flipped the colorsand now our temporary 4-node is up higher in the tree but it's not balanced so weare going to have to do two rotations to make that balanced.<br><br>5. All those subtrees, those three subtrees areexactly the same relative to the top and bottom of the tree, as they were beforethe rotation.<br><br>6. Okay, that's a right rotation.<br><br>7.left after the rotation is going to beh.<br><br>8.It's a bunch of transformations but they're all simple using our flip colorsor left or right rotation.<br>
realize|sentence cnt : 6 <br> <br>1. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br><br>2. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br><br>3. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br><br>4. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br><br>5. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br><br>6. And the key to understanding this code is to realize that the same code,code handles all of the cases.<br>
taught|sentence cnt : 1 <br> <br>1. Actually years ago when we taught coursesin algorithms and data structures, much of the course would be aboutthis kind of pointer manipulation.<br>
constrained|sentence cnt : 1 <br> <br>1. So, it's called the orthogonal line segment, segment intersection searchwhere the lines segments or constrained to be either horizontal or vertical.<br>
formula|sentence cnt : 13 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>3. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>4. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>5. So there's simple formulas to tell us what todo and we can also figure out the formulas for what we do o nce they do collide.<br><br>6. Well, youcan see that this isn't going to be in general an N by N square and about half of theelements in the square are black or about N^2 / 2 and you can see also the exactformula (N - 1) + (N - 2) and so forth is the total number of compares used.<br><br>7. No way can you formulate theproblem as so called parking problem.<br><br>8. So,for example this is a rather complicated formula but not too bad but in a sensethat if you know that the i-th key, it occurs xi times you can write down a lowerbound for the number of comparisons that are going to be required in the worstcase.<br>
degeneracies|sentence cnt : 4 <br> <br>1. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>2. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br><br>3. Now, this computation will be pretty easy except for thedegeneracies.<br><br>4. We don't have to worry about degeneracieswhere lots of things have the same x or y coordinate.<br>
browser|sentence cnt : 3 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br><br>3. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br>
begining|sentence cnt : 1 <br> <br>1. The basic idea is to think of the array as being a littleat the begining a set of little sorted sub arrays of size one.<br>
modern|sentence cnt : 5 <br> <br>1. The whole partitioning process forthree-way partitioning and the modern programming language like Java simplymaintains the invariances described in the demo.<br><br>2. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br><br>3. The other thingthat is probably more significant on modern machines is.<br><br>4. Now, we could use a interval bag or some data structure likethat and hide the link list structure underneath and that's a perfectly fine wayto proceed in modern programming.<br><br>5. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br>
copies|sentence cnt : 1 <br> <br>1. And then we'll pass the s plit up causing asplit up higher so the red keys in the internal nodes are copies of keys downbelow that direct the search.<br>
disciplined|sentence cnt : 1 <br> <br>1. And we'll be very disciplinedin our use of this style.<br>
looking|sentence cnt : 45 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>3. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>4. Well so, we arelooking for the largest key that's less than G.<br><br>5. All we're going to do islook in the table and try to see if the key that's there isequal to the key we're looking for.<br><br>6. The maximum end-point in the left is 22, and we're looking for 23, andwe're not gonna find anything there, so we just wanna go right.<br><br>7. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br><br>8. And then, what we're looking for is to find or count the pointsin a given interval in one dimension.<br>
papers|sentence cnt : 1 <br> <br>1. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br>
slow|sentence cnt : 24 <br> <br>1. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>2. And that's difficult for Kenny to think about and difficult todrive that information from the implementation so program is just tooslow.<br><br>3. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>4. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>5. And one of the themesthat we'll go through over and over in this course is that quadratic time is muchto slow.<br><br>6. And it's a little different kind oftoo slow then for Quick Find, there's times when it could be fast, but there'salso times when it could be too slow.<br><br>7.All right so QuickFind is too slow forhuge problems.<br><br>8. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br>
combine|sentence cnt : 3 <br> <br>1. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>2. Here's the 31x plus y ruleto combine all the fields.<br><br>3. Well what that means is that actually, just likeworking in binary you got, you can combine those things.<br>
everyone|sentence cnt : 2 <br> <br>1. Now,years after, we have to deploy our software and be extremely difficult oneveryone.<br><br>2. So again we, we start out the same way butnow the idea array entry really means that every one of these things is a little treewhere the one node each everyone pointing to itself.<br>
decrementing|sentence cnt : 2 <br> <br>1. And decrementing J.<br><br>2. So,but we can take care of that in the less and exchange methods by just decrementingthe indices in those methods to have it work as if the array were zero through n.<br>
displayed|sentence cnt : 1 <br> <br>1. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br>
distributed|sentence cnt : 7 <br> <br>1. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>2. So if the points are randomly distributed,then this is ideal.<br><br>3. Essentially if you have M entries in the hash table and Mkeys the link of list you're going to look at is about N over M cuz they're evenlydistributed.<br><br>4. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br><br>5. And this is absolutely a fine methodthat is not that difficult to implement, in the case that the pointsare evenly distributed.<br><br>6. Unfortunately, it's usually the case in geometric data that the pointsare not evenly distributed.<br><br>7. And they're pretty uniformly distributed.<br>
depth|sentence cnt : 10 <br> <br>1. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>2. So, that's a sketch of a proof that the depthof any node x is at most log base two of N.<br><br>3. And why is it true that the depth ofany node x is, at most, log base two of N? Well, the key to understanding that is to,take a look at exactly when does the depth of any node increase? When does it go downfurther in the tree? Well.<br><br>4. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br><br>5. The x's depth will increase by one, when its tree, T1 inthis diagram, is merged into some other tree, T2 in this diagram.<br><br>6. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br><br>7. So, when the depth of x increases, the size of its tree at least doubles.<br><br>8. The depth of recursion.<br>
nuygen|sentence cnt : 1 <br> <br>1.And that actually, the analysis, is amazing function that goes back to famousRoman Nuygen and other classical results from our commentorial analysis.<br>
probes|sentence cnt : 6 <br> <br>1. And then we can use, that property of the trees, in theanalysis to, show that, it's not going to be very many probes to get to any key.<br><br>2. You can get to any one with onlyfive or six probes.<br><br>3. So what we want to do is try to access data that's out, externally, usinga minimum number of probes.<br><br>4. Base M over two M probes and that's going to be a really small number, so sayM is a 1000, log base M over two is, is log base 500.<br><br>5. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br><br>6. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
modular|sentence cnt : 6 <br> <br>1. Our sub text today is allabout modular programming.<br><br>2. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br><br>3. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br><br>4. This is just do mod M andif M is a prime then from that modular arithmetic we know that we're using allthe bits in the number in that point to.<br><br>5. So this is just an example showingall the words in a Tale of Two Cities using the modular hashing function forstrings like the one that Java uses.<br><br>6. So this allows us to create modular, reusable libraries of algorithms anddata structures that we can use to build more complicated algorithms anddata structures.<br>
upper|sentence cnt : 7 <br> <br>1. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>2. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>3. One is an, what'scalled an upper bound which is a cost guarantee that's provided by somealgorithm for solving the problem.<br><br>4. So if we go left and then left, thatmeans all the points to the left of 1 and above 3, so the square in the upper leftis represented by that node in the tree.<br><br>5. That's an upper bound and how difficult it is tosolve the problem.<br><br>6. Now, what we seek ideallyis what's called an optimal algorithm where we prove that the upper bound andthe lower bound are the same.<br><br>7.So this is a mathematical formula that we derive by examining the code but itcompletely describes mathematically what we an upper bound on the number ofcompares that are going to be needed.<br>
articulate|sentence cnt : 4 <br> <br>1. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>2. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>3. And the bottom line is that we can articulate anAPI for generic stacks that works for any type of data and we've got twoimplementations, link list and arrays that, that performed very well for [cough]any type of data using the, the resizing or link list as we've described.<br><br>4. What's the implementation of an exception filters?Here's a simple one using the said API that we just articulated.<br>
necessarily|sentence cnt : 4 <br> <br>1. Now, the problem with binary search is,well, not necessarily the problem, but the situation is that whenit's time to insert a new element, we have to move everything larger over oneposition, just like an insertion sort.<br><br>2. The cartoon on the right showsthat not all orders are necessarily total orders.<br><br>3. Doing something that, you wouldn't really, necessarilythink that you could do so easily.<br><br>4. I'm sorry, v is less than w, w less than equalto x that you don't necessarily know that v is less than or equal to x.<br>
lies|sentence cnt : 9 <br> <br>1. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>2. Like, forexample, what's the earliest time? That's the min or what's the latest time? That'sthe max.<br><br>3. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br><br>4. But we have to look on both sides tolook for more, but if the rectangle lies to the left of the root node, then we onlyhave to look on the left and so forth.<br><br>5. If the root node lies inthe rectangle then we're done, [COUGH]we can return that point.<br><br>6. And really, the key idea is reallyimportant to think about cuz it applies to all sorts of algorithmic problems.<br><br>7. And the number of leaves has to be greater orequal to N factorial so that implies the height of the tree has to be greater thanor equal to log base two(N) factorial which is proportional to N log N byStirling's formula.<br><br>8. That's a model for many physical systemsI'll give an abstract model and then just talk briefly about how it applies tophysical systems.<br>
conditions|sentence cnt : 3 <br> <br>1. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br><br>2. We can have a, a very large number, ofunion and connected, operations and our algorithms are going to have to beefficient, under those conditions.<br><br>3. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br>
including|sentence cnt : 11 <br> <br>1. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>2. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br><br>3. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>4. In fact, maybe ten times what's in the book,including a summary of the content.<br><br>5. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>6. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>7. On this lecture we're going to look inMergesort, which is the basic sort in plenty of differentprogramming systems including Java.<br><br>8. So we are going to use a min-oriented priority queue sothat's going to keep, it'll [cough] it'll be one where we can delete the minimumand, and it'll be generic so we'll have a transaction type that holds thisinformation including natural ordering where it's ordered by dollars that lastcolumn.<br>
normally|sentence cnt : 3 <br> <br>1. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>2. So, normally we have a bunch of dot java files when we're working on anapplication.<br><br>3. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br>
travel|sentence cnt : 2 <br> <br>1. And the otherthing is that, so if we travel from p to point 1 then we make a left turn to goto point 5 or counterclockwise turn and then from there, we go to point 9 and12 and then we eventually get back to the start point.<br><br>2. That following off that nulllink and again, we'll just, for G, travel down the tree until we come to the, nulllink.<br>
practice|sentence cnt : 28 <br> <br>1. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>2. So what power do you have toraise 500 to get bigger than N? In practice that's going to be like four orfive.<br><br>3. This things exist but they're not sowidely applied at in practice.<br><br>4. But actually in practice it'smuch less than that.<br><br>5. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>6. And again as with priority qs the bestpractice is to use immutable types.<br><br>7. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>8. One of the practices that will follow often inthis course is to check our API design before getting too far into dealing withthe problem, by building a client that is going to use the data type that wedevelop.<br>
meaning|sentence cnt : 3 <br> <br>1. Let's look at the meaning of those words.<br><br>2. So all that means is that ourimplementations can use compared to but for the client it means that all theseoperations have meaning.<br><br>3.It'll compare this object against the object given as argument and depending onsome complicated tests, it'll return -1, meaning less, +1, meaning greater or0, meaning equal.<br>
delmax|sentence cnt : 3 <br> <br>1. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>2. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>3. And depending on the frequency of execution of the uncertain delMax operations, that might work out better.<br>
right|sentence cnt : 295 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>3. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>4. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>5.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>6. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>7. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>8. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br>
investigation|sentence cnt : 2 <br> <br>1. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br><br>2. So the progress of a scientificinvestigation is going to be affected by how quickly you can do this calculationfor a large number of particles.<br>
proportion|sentence cnt : 58 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2. Now instead of the initialization always takes timeproportional to N.<br><br>3. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br><br>4. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>5. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>6. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>7. Whereas what we can hope for and what weactually will achieve is to get log N time for all operations, time proportion to log Nfor all operations.<br><br>8. Wehave constant time access to every element, but the space is proportional toN.<br>
considerations|sentence cnt : 1 <br> <br>1. Nowthere's a number of considerations to take into account.<br>
appearing|sentence cnt : 2 <br> <br>1. And if M is prime,it gives us some comfort that we have some possibility of each table positionappearing with equal likelihood.<br><br>2. We have a new red link appearing into some threenode.<br>
subfile|sentence cnt : 10 <br> <br>1. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br><br>2. So here's a visualization of what the practical Mergesort might looklike, and this is with big cutoff to small subfiles.<br><br>3. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>4.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br><br>5.Then the method calls the sort for the left subfile first, and then that's gonnabe partitioned on this e, and so forth.<br><br>6. J points to the, rightmost element in theleft subfiles, everything that's not greater than K.<br><br>7. So partition usually happens pretty closeto the middle when you do that sample median-of-three and then small subfilescan just be left unsorted to be picked up with insertion sort right at the end.<br><br>8. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br>
applies|sentence cnt : 3 <br> <br>1. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>2. And really, the key idea is reallyimportant to think about cuz it applies to all sorts of algorithmic problems.<br><br>3. That's a model for many physical systemsI'll give an abstract model and then just talk briefly about how it applies tophysical systems.<br>
answered|sentence cnt : 1 <br> <br>1. So I just answered this question, why do we usedifferent algorithms for the two types? And this is, is maybe arguable.<br>
solutions|sentence cnt : 4 <br> <br>1. Solve a problem by dividing it into two halves, solvingthe two halves, and then putting the solutions together toget the appropriate answer.<br><br>2. It wasdifficult to create solutions, to be able to test hypotheses against naturalphenomenon.<br><br>3. And our basic search tree mentality and APIs, and binary searchtree data structure give us efficient solutions to these important practicalproblems.<br><br>4. And, surprisingly binary search trees and these associatedalgorithms that we've looked at are going to provide very efficient solutions to anumber of important problems in this area.<br>
patterns|sentence cnt : 2 <br> <br>1. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br><br>2.1 what happened was that there wasa huge potentail for really bad collision patterns on typical data.<br>
incremented|sentence cnt : 1 <br> <br>1. Move the pointer to the right,it's incremented again.<br>
talking|sentence cnt : 9 <br> <br>1. So if you have this recurrence [COUGH]which is similar to the ones that we're talkingabout.<br><br>2. We're going to finish up by talkingabout some, practical applications of red black trees.<br><br>3. If one of the particles is null then we're talking abouta wall, a vertical or horizontal wall.<br><br>4. The idea is that we're gonna be talking aboutgeometric objects, not simple keys like strings and numbers.<br><br>5. And if we this the, the thing called event which involves it saysbetween two particles, something is going to happen at a certain time and we'regoing to adopt the conventions that, if, neither particle is null then we'retalking about two particles.<br><br>6. And we came up with thatbefore when we're talking about using a sort for the Graham scan.<br><br>7. So if we, we aretalking abouta randomized model where the sites are vacant with the givenprobability.<br><br>8. Now there's a few rules and there's naturalrules but they're worth talking about and paying attention to that the compareTo()method has to implement in the so called a total order.<br>
updates|sentence cnt : 1 <br> <br>1. Just go ahead and return the link to that child, and that updates the link and everything works fine.<br>
occupying|sentence cnt : 1 <br> <br>1.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br>
daunting|sentence cnt : 1 <br> <br>1.This looks like a fairly daunting equation, but actually it's not toodifficult to solve.<br>
postulate|sentence cnt : 1 <br> <br>1.And, we'll, postulate that there's going to be a command that says, connect twoobjects.<br>
pull|sentence cnt : 11 <br> <br>1. Pull it off the heap and then that's our example.<br><br>2. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>3. We pull out the current item and then advance the current reference andreturn item.<br><br>4. We're going to pull off the two particles and then we'regoing to all, we're going to move all particles by the amount of time that haselapsed since the last event.<br><br>5. Pull off the first E,it's already heap ordered.<br><br>6. Pull off that E.<br><br>7. And so, then there'll bemutual gravitational pull and this is what happens with a large numberof particles in a certain simulation.<br><br>8. Let's look at ananimation, an animation with Heapsort is interesting to watch so the constructionof the heap happens in a blink and now it's pulling off the largest elements,moving from right to left.<br>
terminated|sentence cnt : 1 <br> <br>1. And then when you get to anexternal node you just look for and so that's a, that's the all searchesterminated in external node, in other words that's just a generalization of whatwe just did.<br>
primitive|sentence cnt : 7 <br> <br>1. Ituses two quick sort for primitive types of data and a two mergesort for objects.<br><br>2. Okay then,it's one of the detail that Java takes care of and that's what about primitivetypes [cough] so the generic type that we're using is for objects and you know,we're casting down from array of objects.<br><br>3.And if the program is using primitive types, maybe performance is the mostimportant thing.<br><br>4. So, this the is an easy programming exercise given the rightdisplay primitives.<br><br>5. If it's a primitive type,use the wrapper hashCode.<br><br>6. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br><br>7. And for primitive types takethe wrapper type and use the hash code.<br>
confused|sentence cnt : 1 <br> <br>1. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br>
excellent|sentence cnt : 1 <br> <br>1. The implementation could hardly be morestraightforward and it's an excellent way to solve the problem of handling multipletypes of data with one implementation.<br>
broader|sentence cnt : 2 <br> <br>1. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>2. So, if they're going to be comparable,we might as well take advantage of it, both to get more efficient algorithms and to be able to take advantage ofa broader set of operations.<br>
experiments|sentence cnt : 2 <br> <br>1. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>2. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
computed|sentence cnt : 2 <br> <br>1. So and actually, since strings are immutable,what Java does is keep the hash value in an instancevariable so it only gets computed once.<br><br>2. So this is just a graphical representationif we want to compute D of N we want to computeD of N over 2 twice.<br>
boss|sentence cnt : 2 <br> <br>1. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br><br>2. And that's maybe a little bit what happens when a new boss is hired from the outside and then the two subordinates struggle to take over that position and then the boss would get demoted to it's level of competence.<br>
void|sentence cnt : 16 <br> <br>1. This is so called lazy approach to algorithmdesign where we try to avoid doing work until we have to.<br><br>2. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>3. So, we want to avoid cast as much as possible because it,it, it really is declaring some kind of weakness in what we're doing.<br><br>4. So, we, we avoid this firstsituation here where we put the larger tree lower.<br><br>5. The idea is to when implementing the quick union algorithmtake steps to avoid having tall trees.<br><br>6. Actually since we copied, we couldoptimize by avoiding these moves.<br><br>7. You need a quadratic amount ofmemory to avoid collisions.<br><br>8. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
shellsort|sentence cnt : 22 <br> <br>1. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>2. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>3. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>4. You wouldn't work to use Shellsortas the basis for h-sorting because that always takes quadratic time no matter whatorder there is in the array.<br><br>5.Now, we'll look at Shellsort which is abit elementary on the face of it but it's not at all elementary as you'll see.<br><br>6. It could be that there aresome increment sequence out there that make Shellsort more efficient than anyother method, any of the sorting method that we know for pratical file size, noone can deny that.<br><br>7. Try some technique to discover one and try to saysomething about the average-case performance of Shellsort.<br><br>8. But most people will accept thatand it's a fact and that's how Shellsort gains efficiency.<br>
slides|sentence cnt : 5 <br> <br>1. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>2. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br><br>3. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>4. You can go to books, the book site to see thelecture slides.<br><br>5. So, just, to simplify our code in the slides in it's off, off from thecase for geometric data processing.<br>
detect|sentence cnt : 2 <br> <br>1. Not only does it help detect bugs, but it also documents what the code is supposedto do.<br><br>2. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
different|sentence cnt : 101 <br> <br>1. We have two different stacks.<br><br>2. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>3. So, one thing is we're usinga different key interface.<br><br>4. So that's three different clients, three completelydifferent types of data.<br><br>5. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>6. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>7. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>8. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br>
convention|sentence cnt : 14 <br> <br>1. Now there's a couple ofconventions around null.<br><br>2. If we get to the bottom and our current nodeis null and that's falling off the bottom of the tree we return null and that'sequivalent to saying our buyer convention that, that key is not in our datastructure, or not in our symbol table.<br><br>3. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br><br>4. So that's something that isa convention that's built into Java and that enables the hash code to be used forhashing.<br><br>5. So hashing is widely used forsystems programming and applications, so some conventions forhashing are built into Java.<br><br>6. And then,we're going to adopt the convention that the get() method returns null ifthe key is not present in the table.<br><br>7. So we need to fill in this one table, what's the cost of deletion in a binary search tree? How we're going to really do that? Well, let's take a look at a very lazy approach which we setup for in our basic conventions for symbol tables.<br><br>8. So we have a, a, a bunch of conventions just toreduce the code.<br>
plane|sentence cnt : 16 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>3. So again, the geometric interpretationis the keys are points in the plane.<br><br>4. And this is simple and completely well defined partitioning of the plane corresponding to a binary tree.<br><br>5. And even if it's not points in the plane,just databases.<br><br>6.So say your geometric objects are points in the plane and you specify a rectanglethat's oriented with the horizontal/vertical axes.<br><br>7. So now in the tree on the right there, all the points that fall to the left of thefirst plane are going to be on the left.<br><br>8. Perhaps you wouldn't want to usea resizing-array implementation at the moment that your plane's coming in fora landing.<br>
compiles|sentence cnt : 1 <br> <br>1.And okay, that's fine and you're going to see that when you do compiles using codelike these.<br>
covers|sentence cnt : 2 <br> <br>1. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>2. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br>
downsize|sentence cnt : 1 <br> <br>1. The only downsize as wouldregular Mergesort is that it uses extra space proportional to the size of thearray.<br>
telephone|sentence cnt : 1 <br> <br>1. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br>
sophisticated|sentence cnt : 6 <br> <br>1. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>2. Those are some basic data structuresand implementations and it seem quite elementary and simple but actually rightaway we can get to some very sophisticated applications of these basic concepts andthat's what we're going to consider next.<br><br>3. Andthat's a key feature of binary search trees that we'll come back to again whenwe look at more sophisticated data structures.<br><br>4. It's going to beat even theclassical sophisticated methods for medium sized arrays.<br><br>5. But it's something always to be aware of whentrying to [cough] apply simple algorithms in situations like these that turn out tobe maybe more sophisticated than we might think.<br><br>6. Again, when we look at moresophisticated values we'll be returning something else.<br>
placed|sentence cnt : 5 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. Now, because it's 7-sortedand a 3-sort elements are either already in placed or on a go back a fewstrides.<br><br>3. If occupied you, youreinsert the displaced key into its alternative.<br><br>4. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>5. So it's worthwhile youknow, checking that you believe that this code implements the simple binary searchtree algorithm that we demoed where when we fall off a null link we created a newnode and replaced that null link with the new node .<br>
longstanding|sentence cnt : 1 <br> <br>1. And that's a very longstanding open problem to find a natural simple efficient delete for binary search trees.<br>
unordered|sentence cnt : 7 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>2. And we'll skip that code and just take a look at the comparison betweenthis elementary implementation for symbol tables with the sequentialsearch in an unordered list.<br><br>3. For search, we have to,since it's unordered, scan through the whole list tofind a match, a key that's there.<br><br>4. This version keeps it unordered.<br><br>5. Wemight consider keeping the things in an unordered array.<br><br>6. We could keep it in order orkeep it unordered.<br><br>7. So if you, without evenimplementing it, you can understand this table that if we use an unordered arrayimplementation we can get insertion done in constant time but we haveto look at everything to delete the maximum or even find the maximum.<br>
orderings|sentence cnt : 5 <br> <br>1. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>2. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br><br>3. We're sorting strings but we'reimplementing a different ordering, various different orderings on that same data.<br><br>4. If there's some ordering that is notappear in a tree corresponding the particular algorithm then that algorithmhasn't can't sort, can't, can't tell the difference between two differentorderings.<br><br>5. Out of all the orderings the one that's further stand in the tree that'sthe worst case and so the algorithm, no matter what the input is, the tree tellsus a bound, the number of compares taken by the algorithm.<br>
coupon|sentence cnt : 2 <br> <br>1. When does all the bins fill up? That's called the couponcollector problem.<br><br>2. In the lower balancing, a coupon collector analysistell us that the collisions are going to be evenly distribute, distributed amongthe table, around the table.<br>
impelements|sentence cnt : 1 <br> <br>1.So every time we're moving a new element into k and that's the codethat impelements the abstract in place merge.<br>
square|sentence cnt : 39 <br> <br>1. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>2. They're either connectedor not then that will take quadratic time in squared time.<br><br>3. If we allow delete, in fact everything degenerates to square root of n.<br><br>4. One myse alpha is forthe hit, one myse alpha for the squared for the insert.<br><br>5. In the case of the grid implementation,they might all fall in the same square.<br><br>6. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>7. That doesn't work i, t still becomes square root of n.<br><br>8. We can use a two-dimensional arrayto directly index relevant squares.<br>
uncertain|sentence cnt : 2 <br> <br>1. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>2. And depending on the frequency of execution of the uncertain delMax operations, that might work out better.<br>
otherwise|sentence cnt : 29 <br> <br>1. Otherwise if themax is less than low we go right.<br><br>2. Andthat's a very useful thing because otherwise, we might try to define such analgorithm.<br><br>3. Otherwise we go left.<br><br>4. But otherwise, that's a fine method for merging.<br><br>5. So left subtreeis [inaudible] right, okay? Otherwise, we have to check whether the max endpoint inthe left subtree is less than, the low point in our interval.<br><br>6. Otherwise, if it's a string that'snot equal to the hyphen character, it'll just push it onto the stack.<br><br>7. Otherwise, we increment i.<br><br>8. This is a very concise code thatotherwise we'd have various cases about saving which link we went down in order toreset that later on.<br>
sequential|sentence cnt : 5 <br> <br>1. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>2. So, it means that we've divided the search cost which would be Nif we have a sequential search by a factor of M.<br><br>3. And we'll skip that code and just take a look at the comparison betweenthis elementary implementation for symbol tables with the sequentialsearch in an unordered list.<br><br>4. If there were no timelimit computation at all, then I'll just hash everything to the sameplace and then do sequential search.<br><br>5. But a sequential search can beslow if we have lots of keys.<br>
popular|sentence cnt : 4 <br> <br>1.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br><br>2.Another popular closure resolution methodis known as linear probing.<br><br>3. So again, very little codeto implement search and insert using hashin g and that's why it's so popular.<br><br>4. But youreally know that your data structure and algorithm is used by a lot of people whenit appears in the popular culture.<br>
undesirable|sentence cnt : 1 <br> <br>1. It's not somethingthat you will come up with on your own and that's, and that's an undesirable feature,I think for codes so simple as this.<br>
simple|sentence cnt : 118 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>3. So this is a simple test client thatwe can use to test our implementations.<br><br>4. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>5. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>6. And now build asimple table that associates strings with strings.<br><br>7. And Dijkstra's algorithm is very simple toexpress.<br><br>8. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br>
english|sentence cnt : 1 <br> <br>1. He was quiteexcited because he was watching a re-run on, of an English actually Canadian TVshow on French TV.<br>
worthwhile|sentence cnt : 14 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>3. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>4. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>5. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br><br>6.And it's definitely worthwhile taking implementing for a Quicksort.<br><br>7. But it's worthwhile to state them explicitly andmake sure that our algorithms maintain them.<br><br>8. [COUGH] here's a trace of what Mergesortdoes and if you haven't studied a recursive program before it's worthwhilestudying this thing in, in some detail.<br>
downloading|sentence cnt : 1 <br> <br>1. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br>
corresponds|sentence cnt : 12 <br> <br>1. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>2. So what we do is, as we did for MergeSort, is write down a mathematical recurrence relation that corresponds towhat the program does.<br><br>3. And the idea is to build a tree that corresponds torecursively partitioning the plane.<br><br>4. How do they flock together? And we'll look at a simulationthat corresponds to that.<br><br>5. After we do the left rotate, we have a legalleft-leaning red-black tree, and it exactly corresponds to that 2-3 tree, sothe insertion of C gives us exactly what we would want, that correspondence withthe 2-3 tree.<br><br>6.That's corresponds precisely to our temporary four node when we're doing 2-3trees.<br><br>7. So the percolation model onthe left corresponds to the, connection model on the right, according to whatwe've been doing.<br><br>8. So now, every time the line sweep hits arectangle, that corresponds to an interval.<br>
ours|sentence cnt : 64 <br> <br>1. This is not a course on discretemathematics.<br><br>2. And that's one of our main themes in thiscourse.<br><br>3. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>4. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>5. In fact, some were discovered by undergraduates in a course,course like this.<br><br>6. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>7.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>8. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br>
spellchecker|sentence cnt : 1 <br> <br>1. For example, you might have a spellchecker where you want to identifymisspelled words.<br>
garbage|sentence cnt : 4 <br> <br>1. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>2. And then what we can do, is just return that node's right link, then that old node, nobody's pointing to it, so it's available for garbage collection.<br><br>3. And the node that was deleted is available for garbage collections, nobody's pointing to it.<br><br>4. And then that first node is ready tobe reclaimed by the garbage collector.<br>
afterward|sentence cnt : 5 <br> <br>1.If the parent was a 2-node then the transformation is a local transformationand if you look at where the links are, then it's easy to see by induction that ifthere was perfect balance before there's perfect balance afterward,Because we didn't change anything about the perfect balance in any of thosesubtrees.<br><br>2.All the words, pick out our key, s, and again, if, it's not there yet, we create anew set associated with that s, and, then, afterwards, we go ahead and.<br><br>3.If the 3-nodes at the right and this one is one higher and those four are one lowerand afterwards it's the same.<br><br>4. If there was perfect balance beforethere's perfect balance afterwards, because we didn't change the height of anynodes.<br><br>5. And then h's coloris going to be black afterwards.<br>
compression|sentence cnt : 7 <br> <br>1. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>2. But weighted quick union withpath compression in practice is, is close enough that it's going to enable thesolution of huge problems.<br><br>3. With using weighted quick union and with pathcompression, we can solve problems that could not otherwise be addressed.<br><br>4. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>5. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>6. Today, we're goingto talk about event-driven simulation which is an interesting idea that is basedon priority queues but it's also used in numerical computation and we'll see inalgorithms for data compression and graph searching that it's useful.<br><br>7. Andthat's the idea of path compression.<br>
listening|sentence cnt : 1 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br>
cheating|sentence cnt : 1 <br> <br>1. Now, we're cheating in thisimplementation to keep it simple, and we'll take care of thischeat in a little while, by requiring the client to providethe capacity of the stack.<br>
percolated|sentence cnt : 1 <br> <br>1. That's white in the diagram with probablyP or blocked, that's black of the diagram with probability one - P and we define asystem to, we say that a system is percolated if the top and the bottom areconnected by open sites.<br>
linus|sentence cnt : 1 <br> <br>1. Linus Torvalds, who created lin, Linux, saysthat the difference between a bad programmer and a good one is whether heconsiders his code or his data structures more important.<br>
invoked|sentence cnt : 1 <br> <br>1. And thenthe sort code can just use that compareTo() method, invoked in a sense of theobject like an entry in the array and as argument and another instance in theobject like another entry in the array to test whether the first is less than thesecond as in this example.<br>
factorial|sentence cnt : 6 <br> <br>1. So, this three has to have at least N factorial leaves and ifthe three of height h, it has utmost two^h leaves.<br><br>2. And by Stirling'sapproximation, we know that log base two(N) factorial is proportional to N logbased 2N.<br><br>3. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>4. The number of possible shuffles is much more and it's 52, it's 52 factorial which is a lot bigger than two to the 32nd, so it's not close to random or uniform.<br><br>5. So, the lower bound as a proposition, that uses the decision treelike that to prove that any compare base sorting algorithm has to use at least logbase two (N) factorial compares in the worst case.<br><br>6. And the number of leaves has to be greater orequal to N factorial so that implies the height of the tree has to be greater thanor equal to log base two(N) factorial which is proportional to N log N byStirling's formula.<br>
they|sentence cnt : 208 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>4.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>5. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>6. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>7. If they are connected it'll ignore.<br><br>8. They're in their own connected component.<br>
frequencycounter|sentence cnt : 1 <br> <br>1. So for this small data from the beginningof Dickens' Tale of Two Cities, if we run a FrequencyCounter,the FrequencyCounter client.<br>
plagued|sentence cnt : 1 <br> <br>1. This kind of question plagued a lot ofpeople in this late 60's or early 70's as these types of problems emerge forcomputing applications.<br>
carlo|sentence cnt : 2 <br> <br>1. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>2. So what we're going to run is called a so calledMonte Carlo simulation.<br>
leading|sentence cnt : 4 <br> <br>1. So it's all finesorted by name and but then in order to distribute it out to the people leading itto the sections, what we want to do is sort by the second fields, sort bysection.<br><br>2. Essentially, we're finding a node that has only one link leading that node, and then replacing the node that we need to delete with that one.<br><br>3. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br><br>4. It goes to the right of H,leading the wrong way rotate left.<br>
recurrence|sentence cnt : 12 <br> <br>1. We use this same idea on our initialrecurrences for comparison array accesses to show thatthe running, the number of comparison array accesses isproportional to N log N for Mergesort.<br><br>2. So now, this is a recurrence thattelescopes.<br><br>3. And the way to prove this proposition isto from examining the code, to write down what'scalled a recurrence relation.<br><br>4.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br><br>5. So if you have this recurrence [COUGH]which is similar to the ones that we're talkingabout.<br><br>6. So what we do is, as we did for MergeSort, is write down a mathematical recurrence relation that corresponds towhat the program does.<br><br>7. With the inductive hypothesis that D of Nequals N lg N, we want to show that D of 2N equals 2N lg 2N, using the recurrence D of2N equals 2D of N plus throw out the 2N.<br><br>8. But what we then do is show how to solvethe recurrence when N is a power of 2.<br>
warning|sentence cnt : 4 <br> <br>1. So now, when we compile this program we get a, a warning message fromJava.<br><br>2. I, I think maybe they might have added to this warning statement "We apologize for making you do this".<br><br>3. So with that note please don't think there's something wrong with yourcode if you follow our prescriptive and, and get this warning message.<br><br>4. So, we can go aheadand do that and it says that you have put in, in your code an unchecked cast andwe're warning you about that cuz you shouldn't be putting in unchecked cast.<br>
there|sentence cnt : 465 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. Now there's a couple ofconventions around null.<br><br>3. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>4. There's lots of importantapplications for this.<br><br>5. There's a, alarge amount of data.<br><br>6. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>7. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>8.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br>
preferred|sentence cnt : 1 <br> <br>1. So hashing's going to be preferred for short keys where the hashfunction's easy to compute.<br>
reading|sentence cnt : 4 <br> <br>1. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br><br>2.Reading all the strings on an input stream, on standard input,and, splitting em by blank space and putting em into array, sonow all the words, are, in the an array.<br><br>3. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>4. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br>
principles|sentence cnt : 2 <br> <br>1. Any uses of the resizing array,so many of the principles that we consider does also a, a link list interface.<br><br>2. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
intuitive|sentence cnt : 5 <br> <br>1. And they're all quite natural and intuitive.<br><br>2. Now theseproperties are very intuitive.<br><br>3. You can think of it intuitivelyas like a dictionary.<br><br>4. Now, these are the things thathave to be proven and we're not going to get into the details of geometric proofbut they're intuitive and certainly have no trouble accepting that these things aretrue.<br><br>5. But intuitively, we can see kind of whathappens each partitionings that maybe splits the array approximately in half.<br>
months|sentence cnt : 2 <br> <br>1. Otherwise, the year, years must be equalso we have to look at the months to do the compare and so forth down to do the days.<br><br>2. You could spendmillions on a super computer, and maybe you could get it done in six years insteadof 30, or in two months but with a fast logarithm, you can do it in seconds, inseconds on your own PC.<br>
flock|sentence cnt : 2 <br> <br>1. And the idea is to use three simple rules, you get something very close tothis complex flocking behavior.<br><br>2. How do they flock together? And we'll look at a simulationthat corresponds to that.<br>
survey|sentence cnt : 2 <br> <br>1. So, what is this course? It'san intermediate level survey course on algorithms.<br><br>2. So that's a little survey of some operations on a heap and you can see how every operation is done with just a few exchanges along the path from the bottom to the top, or the top to the bottom.<br>
sequences|sentence cnt : 7 <br> <br>1. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. So, an h-sorted array is h different inter leaves sortedsub-sequences so in this case with h=4 if we start at L and look at everyfourth element - M, P, T - then it's sorted.<br><br>4. SoJava has general API for sequences of items and its got things like a, append atthe end, remove from the beginning, and so forth.<br><br>5. So this is 4 interleave sequences, that'sa 4-sorted array.<br><br>6. And what we're going to do is implement a sorting method thath-sort for decreasing sequences of values of h.<br><br>7. And, and in the real world you cannowadays find on the web particular sequences of keys that will causeparticular services to crash.<br>
afterwards|sentence cnt : 4 <br> <br>1.All the words, pick out our key, s, and again, if, it's not there yet, we create anew set associated with that s, and, then, afterwards, we go ahead and.<br><br>2.If the 3-nodes at the right and this one is one higher and those four are one lowerand afterwards it's the same.<br><br>3. If there was perfect balance beforethere's perfect balance afterwards, because we didn't change the height of anynodes.<br><br>4. And then h's coloris going to be black afterwards.<br>
variant|sentence cnt : 25 <br> <br>1. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>2. Then once we've exchangedit, again, we preserved our invariant.<br><br>3. In fact, that's what lead to [unknown] analyze the situation then comeup with a left-leaning variant.<br><br>4. So,now the invariant might be violated so we have to fix it.<br><br>5. So we have to look at the code that'sgoing to maintain that invariant as the pointer increments.<br><br>6. So let's, one way to understand the way that an algorithm works is tothink about invariants .<br><br>7. And what are we supposed to do then? Well, to maintain thevariant there we just need to increment i.<br><br>8. So the invariant of that is thatthe array is always between 25% and 100% full, number one.<br>
tricky|sentence cnt : 6 <br> <br>1. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>2. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>3. So, that's a, a implementation that, that code isdefinitely tricky and a similar code for ceiling.<br><br>4.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>5. Not difficult, but a definitely tricky programming exercisethat people are welcome to try.<br><br>6. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br>
assignment|sentence cnt : 4 <br> <br>1. Wewill provide much more detail information on that as we get into the assignments.<br><br>2. So, we have an assignment whereyou need to generate a random open sites in a percolation system.<br><br>3. Here's a war story fromstudents Programming assignments not that long ago.<br><br>4. And that's every programmer'sfirst introduction to assignment statements.<br>
could|sentence cnt : 120 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>3. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>4. And how close it could get to full withoutsacrificing performance.<br><br>5.You could think of a vacant site as being a conductor and, and a block site as beinginsulated.<br><br>6.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>7. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>8. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br>
ball|sentence cnt : 25 <br> <br>1.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>2. And the CSproblem is how and when to we exactly do these computations for each of the balls.<br><br>3.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>4. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>5. And we have some number of balls,however many keys we have.<br><br>6.So this is the implementation of the ball class.<br><br>7. So, that's all the code for doing the bouncing ball simulation.<br><br>8. After about natural log M tosses,every bin has at least one ball.<br>
storing|sentence cnt : 6 <br> <br>1. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>2. That's restoring the heap border along a path from the place where it's violated to the root.<br><br>3. To get started we map a key to a integerbetween zero and m-1 where m is the sides of our array where we are storing thekeys.<br><br>4. When we put a key value pairon to the symbol table, think of that as using the key to indexan array and storing the value there.<br><br>5. We think of storing the value inthe array position given by that index.<br><br>6. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
dialogue|sentence cnt : 1 <br> <br>1.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br>
source|sentence cnt : 6 <br> <br>1. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>2. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>3. They'reblacklist, and we want to take them out of our source file.<br><br>4. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>5. But there's aproblem so you would think that the system sort would be completely solid with allthis resource with all these research and all of the development that's going intoit.<br><br>6. [cough] So, for this course we have two resources that I wantto talk about and make sure that people are familiar with before entering into thecontent.<br>
gets|sentence cnt : 57 <br> <br>1.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. But as it getsfull.<br><br>4. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>5. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>6. Let's look at it when it's in reverseorder again it gets the first half done now it'sworking on the second half once it gets the second half done then it goesahead and merges together the whole thing it's just as fast in reverse order as asin auditory order.<br><br>7. Whatever the size,bottom of Mergesort gets the job done in log N passes.<br><br>8. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br>
fraud|sentence cnt : 1 <br> <br>1. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br>
recognize|sentence cnt : 2 <br> <br>1. Now, and what's mostimportant to recognize about this is that its the algorithm design that enables thesolution to the problem.<br><br>2.Always, in this class, we have an exercise or exam question is this version of thissort stable or not? So, students learn to recognize whether the code is stable.<br>
landmark|sentence cnt : 1 <br> <br>1. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br>
limitation|sentence cnt : 1 <br> <br>1. If we had no limitation on space at all,then we can have a very huge array with space for every possible key andjust use the key itself as an index.<br>
fields|sentence cnt : 13 <br> <br>1. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>2. We'll populate its fields andthen that old link will change that from null toa pointer to the new node.<br><br>3. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>4. Here's the 31x plus y ruleto combine all the fields.<br><br>5. And that willfill in the fields and then, we put that transaction on the priority queue.<br><br>6. So it's all finesorted by name and but then in order to distribute it out to the people leading itto the sections, what we want to do is sort by the second fields, sort bysection.<br><br>7. And in general, a CSVfile might have many fields separated by comma, comma.<br><br>8. And then, the index in the array is going tobuild the fields that we're going to use.<br>
supply|sentence cnt : 1 <br> <br>1. Supply that operator to those values and put theresulting value that you get back on to the operation stack.<br>
motivation|sentence cnt : 1 <br> <br>1. We're goingto be able to sort the same things in different way sometimes and this exampleis a fine motivation of that.<br>
magic|sentence cnt : 2 <br> <br>1.That's kind of a magical operation and believe me, it's easier to get done in theimplementation than the graphics.<br><br>2.That's a kind of a magic step, but we will see that it makes possible to solve theequation easily.<br>
afforded|sentence cnt : 1 <br> <br>1. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br>
shuffling|sentence cnt : 15 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. Anoth er thing they did was rather thanshuffling the array.<br><br>3. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br><br>4. Here's a way to get shuffling done using a sort, it seems like the opposite.<br><br>5. Quadratic time worstcase but that's unlikely to occur if you do the random shuffling.<br><br>6. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>7. So, that's shuffling our first non-trivial sorting application.<br><br>8. InQuicksort partitioning, after the random shuffling we have the partitioning elementand then we process everybody to the left independently of everybody to the right.<br>
reclaim|sentence cnt : 2 <br> <br>1. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>2. And then that first node is ready tobe reclaimed by the garbage collector.<br>
flocking|sentence cnt : 1 <br> <br>1. And the idea is to use three simple rules, you get something very close tothis complex flocking behavior.<br>
topics|sentence cnt : 2 <br> <br>1. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br><br>2. These are the basic topicsthat we'll cover in part one and part two of the course.<br>
starts|sentence cnt : 4 <br> <br>1. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br><br>2. And then the only instance variableof a stack is a reference to the first node on the list andit starts out being null.<br><br>3. So, in this case, it starts out with the inputexample shown and then the 13-sort - a few items are moved, 4-sort - a fewmore are moved, and then finally, a 1-sort.<br><br>4. Starts looking for a place at a random time.<br>
turing|sentence cnt : 3 <br> <br>1. This method was invented in 1961 by TonyHore, who won the Turing Award in 1980 for this and other work.<br><br>2. Theconcept of an algorithm was formalized actually here at Princeton, by Church andTuring, in the 1930s.<br><br>3. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br>
intuition|sentence cnt : 3 <br> <br>1. So we've drawn the data structure with the links so we have an intuition for what's going on, but all the program sees is the array in gray at the bottom where T is in position one, P and R in position two and three and so forth.<br><br>2. Now the intuition behind Shellsort and actuallythe mathematical fact is that if you've got an array that's h-sorted and then youk-sort it for another value k different from h, it's still h-sorted.<br><br>3. This is interesting because we can draw the tree to get more intuition about what's happening, but in the actual data structure representation, we don't need any links at all, it's just an array.<br>
expand|sentence cnt : 6 <br> <br>1. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>2. And what's more,it expand to more dimensions.<br><br>3. It expands like binary search to handle all these convenient clientoperations in a very natural manner.<br><br>4. So we have to greatly expandour, our table.<br><br>5. And we'll see later on, there's times when we want to expand the API and provide other operations like removing an arbitrary item from the priority queue, or give the client in the API the capability of changing the priority of an item.<br><br>6. Or using either one of those techniquesyou could just get the idea that D of N is close to Log N or you can write a programto expand the recurrence and find that.<br>
versus|sentence cnt : 8 <br> <br>1. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>2.And how can we do it efficiently that is in, in log N time versus quadratic time.<br><br>3.It's a few arithmetic operations to do the hash versus lg N and compares for thebalance tree.<br><br>4. If we have a full stack,which we know by testing N, which is the number of items inthe stack versus the array length, then we just resize the array into one of twicethe length before inserting the item.<br><br>5. So, what are the tradeoffs between usinga resizing array versus a linked list? Those are two differentimplementations of the same API, and the client can usethem interchangeably.<br><br>6. Since N squared over 4versus N squared over 2, insertion sort's going to be abouttwice as fast as selection sort.<br><br>7. So the bottom line isseparate chaining versus linear probin collision resolution message methods.<br><br>8. What about hash tables versus balance search trees? Wellhash tables are really simple to code usually if you don't have to do the hashfunction.<br>
immutability|sentence cnt : 2 <br> <br>1. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>2. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
merge|sentence cnt : 117 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>3. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>4. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>5. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>6. That is, we need that extra auxiliaryarray for the last merge.<br><br>7. To merge an array, put the result back inthe first one.<br><br>8. This gives exactly what happens duringeach of the calls to merge.<br>
iterational|sentence cnt : 1 <br> <br>1. The client is always going to betesting hasNext() as I showed as I showed and that stub code before and so when itgets to null it will return false in the iterational stop.<br>
closer|sentence cnt : 20 <br> <br>1. And so now we're only going tolook in parts of the tree that could give us a point that'scloser to our query point than 3.<br><br>2. And so that idea of getting closer andcloser to the query point is going to cut out different parts ofthe tree as we process.<br><br>3. It's closer, sowe update 3 to be our new champion.<br><br>4. because there could be nopoint on the right subtree, on the right of this splitting line,that's closer to the query point than 3.<br><br>5. So in this case, we have to search both, there might possibly be a closerpoint than 1 over in the right.<br><br>6. So this well illustrates that youneed to use all of the data in the hash function and sometime we do a closeranalysis.<br><br>7. And while the nearest neighbor can't be, we don't have to go down the right subtreeat 6 because you can't have a point in that rectangle that's closerto the query point than 3.<br><br>8. But in time,much closer to N log N than to N squared.<br>
reference|sentence cnt : 33 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>3. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>4. You know, with reference to what weknow about 2-3 trees.<br><br>5. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>6. So, a binary search treein Java is just going to be referenced to a root node.<br><br>7. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>8. Well,if you think about it for just a minute, you see that what you need to do is justremove all references to value from any of the symbol table implementations that we'dlook at.<br>
ycoordinate|sentence cnt : 3 <br> <br>1. So, how do we find the point with the smallest y coordinate? Well youcould, you could sort, you could define an order and compare the points by ycoordinate so essentially sorting is the [cough] answer to that question.<br><br>2. What's the next smallest xcoordinate? In this case it's the line number one there, and we'll remember its ycoordinate in a binary search tree.<br><br>3. So, left endpointinsert the y coordinate into a BST, right endpoint remove that ycoordinate from theBST.<br>
proceed|sentence cnt : 5 <br> <br>1. And then proceeding inthat way, moving bottom up or moving from right to left, the next thing we do is butthen worry about a three node heap that's heap ordered and we're fine.<br><br>2. So that's just a, a way of make suring that the simulation keepsproceeding.<br><br>3. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>4. Or if we did the other way around and proceeded accordingly.<br><br>5. Now, we could use a interval bag or some data structure likethat and hide the link list structure underneath and that's a perfectly fine wayto proceed in modern programming.<br>
boundary|sentence cnt : 3 <br> <br>1. Another one that's the boundary between the keysthat are equal of partitioning elements and the one that is greater.<br><br>2. If we've got some points that are on the boundary but aren'treally vertices they shouldn't be included.<br><br>3. One that is the boundarybetween the keys that are less than the partitioning element and those that areequal of the partitioning element.<br>
implementer|sentence cnt : 1 <br> <br>1. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br>
duplicates|sentence cnt : 5 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>2.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br><br>3. On the other hand,if the array is in descending order and has no duplicates,then every element goes all the way back.<br><br>4. And now, the statistical problems are like that or findingduplicates.<br><br>5. Probably finding duplicates by itself is not quite obvious what to do butthe easy way to solve it is to just go ahead and sort.<br>
regular|sentence cnt : 13 <br> <br>1. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>2.In a regular BST node, the 2-node, we have one link for the keys that are less thanthe key in the node, and one link for the keys that are greater.<br><br>3. So, what they did in this implementation was theyjust put in regular Hibbard deletion in the binary search in the red-black BST.<br><br>4. We started with one dimensionalrange search and just used regular binary search tree to compute ranks to get theanswer.<br><br>5. First when we look at, seemseven simpler than the regular symbol tables, and that's about sets.<br><br>6. Our regular search code doesn't examine the color of a linkand so we can just use it exactly as is.<br><br>7. Now what about inserting?Well, it's a similar type of strategy as with regular binary search trees, exceptthat we manipulate the two and 3-node to keep perfect balance in the tree.<br><br>8. The only downsize as wouldregular Mergesort is that it uses extra space proportional to the size of thearray.<br>
extended|sentence cnt : 3 <br> <br>1. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>2. And they rebuild the whole treeand, and then because of the way they did this deletion, well, the end of the storywas that they had extended the client had extended outage because the implementerdidn't use the full algorithm.<br><br>3. Clearly, these things can be extended in many ways.<br>
where|sentence cnt : 217 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>3. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>4. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>5.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>6. Now, here's an example where we want to use theory as a guide.<br><br>7. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>8. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br>
after|sentence cnt : 59 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>3. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br><br>4. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>5. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br><br>6. So after this operation, we're firstpointing to the beginning of the list.<br><br>7. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>8. And then after those two things are done,the whole thing is sorted.<br>
knuth|sentence cnt : 4 <br> <br>1. So here's the implementation in Javaof Shellsort for Knuth's 3x + 1 increment sequence.<br><br>2. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>3. Don Knuth who wrote several books on, on algorithmsand was a pioneer in the field said that, "An algorithm must be seen to bebelieved.<br><br>4. Knuth when he wrote his books in the 60s proposed the incrementsequence 3x + 1.<br>
operations|sentence cnt : 114 <br> <br>1. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>2. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>3. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>4. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>5. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>6. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>7. So that's our two primary operations.<br><br>8. There's only a few instructions foreach one of the operations.<br>
defining|sentence cnt : 1 <br> <br>1. We don't want to just be able to sort things,we don't want to just be able to sort them by defining and compared to.<br>
lengths|sentence cnt : 2 <br> <br>1.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>2. The 4-node had four links, and the two2-nodes have four lengths, so nothing has to be changed below.<br>
wherever|sentence cnt : 1 <br> <br>1.Now, you, you can see this next insertion is going to cause some splitting whereverit is.<br>
literal|sentence cnt : 2 <br> <br>1. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>2. So that's kind of like when you create a literal value to be assigned to an integer, it has that value.<br>
rhythms|sentence cnt : 2 <br> <br>1. Next we're going to talkabout Binary Search Trees, a classic data structures that'll enables us to provideefficient implementation of symbol table and out rhythms.<br><br>2. Now, the key point is that sorting algorithms rhythms are essentialin a very broad variety of applications and, and all of us use sorting algorithmspretty much every day.<br>
blank|sentence cnt : 3 <br> <br>1.Reading all the strings on an input stream, on standard input,and, splitting em by blank space and putting em into array, sonow all the words, are, in the an array.<br><br>2. So we take the file name as thefirst command line argument, read in array of string from that file separated byblanks, call an Insertion.<br><br>3. [BLANK AUDIO].<br>
focus|sentence cnt : 5 <br> <br>1. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>2. It can't maintain a dynamic table efficiently with binarysearch and that's going to be your focus in the next lecture.<br><br>3. And what we are going to do is focus only on the timeswhen the collisions are going to occur.<br><br>4. We're going to concentrate onprogramming and problem solving in the context of real applications, and ourfocus is going to be on two things, Algorithms which are methods for solvingproblems and data structures which store the information associated in problem,with a problem and go hand in hand with algorithms.<br><br>5. It also allows us to focus onperformance when appropriate.<br>
viewed|sentence cnt : 1 <br> <br>1. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br>
message|sentence cnt : 3 <br> <br>1. So now, when we compile this program we get a, a warning message fromJava.<br><br>2. So with that note please don't think there's something wrong with yourcode if you follow our prescriptive and, and get this warning message.<br><br>3. So the bottom line isseparate chaining versus linear probin collision resolution message methods.<br>
putting|sentence cnt : 18 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2. So when we start putting the keys in the nodes, we're going to impose one more condition that's called heap ordering.<br><br>3. So, that's the way we representcolors by putting the, a color bit in the node for the color of the length thatpoints to it.<br><br>4. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>5. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>6. And now we've added it to the heap by just incrementing in and putting it in there.<br><br>7. And we do that by juts by notputting too many keys in to the table.<br><br>8. We did a long distance exchange and thatcatapulted that first item past any item that it might be equal putting them out oforder.<br>
intent|sentence cnt : 1 <br> <br>1. Now for most of these,the intent is very clear.<br>
occur|sentence cnt : 13 <br> <br>1. And now the integer that we'regoing to associate with each word is the frequency of occurrence ofthat word in the symbol table.<br><br>2. So what you want to do, is given a word, find all occurrences of that word alongwith immediate contexts.<br><br>3. And it might have occurred to you while we are looking at thesealgorithms.<br><br>4. Quadratic time worstcase but that's unlikely to occur if you do the random shuffling.<br><br>5. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br><br>6. So if the word's not in the symbol table,we'll put it there with a frequency of occurrence of 1,that's the first time we saw the word.<br><br>7. And so that one is going to reada sequence of strings from standard input and print out the one thatoccurs with highest frequency.<br><br>8. All different types of problems mightoccur and with some difficulties, it's possible to prove thateven if the tree's balanced, you can get a worse caseproportional to square root of N.<br>
forget|sentence cnt : 3 <br> <br>1. And don't forget to check that we're going off the end of the heap.<br><br>2. People have come up with methods forgetting this done.<br><br>3. Infact, there's an argument for just using this implementation of Quicksort andforgetting about horse because it performs so well in so many practical situations.<br>
funny|sentence cnt : 1 <br> <br>1.And now, lg N is kind of a funny function.<br>
balanced|sentence cnt : 25 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>3. And then we did a right rotate on the top node, and that transformed to thecase where our temporary four node is balanced.<br><br>4. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>5. On the other hand, balanced searchtrees have a much stronger performance guarantee.<br><br>6. And so but, but they still thought that it should be balancedand it shouldn't matter much.<br><br>7. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>8. They d on't need the colors,but they can all benefit from the fact that the trees are much better balanced.<br>
corresponding|sentence cnt : 24 <br> <br>1. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>2. If get returns in non null value, then there's a value correspondingto that key in the table.<br><br>3. The constructor has to create the array and then go through andset the value corresponding to each index I to I.<br><br>4. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br><br>5. So here's the corresponding API forQueueOfStrings.<br><br>6. Alright, here's the code corresponding to the process that we justdemo.<br><br>7. And this is simple and completely well defined partitioning of the plane corresponding to a binary tree.<br><br>8. And then the corresponding oneis, what's the first thing that happened after that time? That's call in to theradio show, I'm going to take that caller, the first call that comes at nine:30.<br>
generally|sentence cnt : 6 <br> <br>1. So, more generally, here's the goal.<br><br>2. And generally programmers, Javaprogrammers know that it's a good idea to try to do these assertions.<br><br>3. Or more generally, people want to oftenprocess, preprocess text to, maybe a huge amount oftext, to support, so called, concordancequeries.<br><br>4. So it's theoretically possible, but themethods are generally too complex to be useful inpractice and their not used.<br><br>5. That one's generally too complicated to use in practice.<br><br>6. But generally if we have comparable types,we'll use compareTo, and if we don't have comparable types,we'll use equals.<br>
fastest|sentence cnt : 2 <br> <br>1. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>2. Un, so what about in actually in practice?This is our fastest sorting algorithm, and there's a few ways to make it even faster.<br>
myself|sentence cnt : 1 <br> <br>1. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br>
proceeded|sentence cnt : 1 <br> <br>1. Or if we did the other way around and proceeded accordingly.<br>
overwrite|sentence cnt : 1 <br> <br>1. And also the associative arrayabstraction is the put() method will overwrite an oldvalue with a new value.<br>
print|sentence cnt : 26 <br> <br>1. And if it does, print the value associated with the key.<br><br>2. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>3. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>4. And then we left out, left out the code where you print out the nine words thatyou want.<br><br>5. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>6. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br><br>7. If the string is equalto the hyphen character, it'll pop the string at the topof the stack and print it.<br><br>8. And then simply print out the set ofstrings associated with that word which is a list of filenames.<br>
most|sentence cnt : 82 <br> <br>1. That's the most recently added item.<br><br>2. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>3. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>4. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>7. Now for most of these,the intent is very clear.<br><br>8. And similarly for the number of arrayaccesses, if you count up the number of times you're accessing an array for amerge you could be at most six in.<br>
stuff|sentence cnt : 7 <br> <br>1. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>2. We want to fill up the memory with stuffto sort and then sort it.<br><br>3. The right goes to the value stack and nowwe got a lot of stuff on the stacks and we got through right parenthesis and that'sgoing to finish up the computation, take the top two items off the stack and thetop operator off the operator stack, perform the operation, put the resultback on the value stack.<br><br>4. And so then at that point,it's half full, and it can either grow by adding stuff orshrink by subtracting stuff.<br><br>5. And a lot of clients only want todo is just iterate through the stuff in the collection.<br><br>6. So now we haveour i pointer which is right to the left of stuff we haven't seen ye t and then, wehave two other pointers that maintain, maintain these boundaries everything tothe right of gt is known to be greater than partitioning element.<br><br>7. What is it that we care about in asort? It's a little bit more complicated than just put stuff in order.<br>
monte|sentence cnt : 2 <br> <br>1. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>2. So what we're going to run is called a so calledMonte Carlo simulation.<br>
applying|sentence cnt : 2 <br> <br>1. So this code is thebasis for applying the sort, system sort method or any sort method for the Grahamscan for the convex hull that we did at the end of the last lecture.<br><br>2. Then if you have a field that'sit's an array you can go ahead and try applying it to each entry andthere's implementations in Java.<br>
promote|sentence cnt : 4 <br> <br>1. And so, it's larger than, it's bothchildren, and the larger of the two children is T, so we promote the T.<br><br>2. Andthe P is larger, the two children promote that and then finally, the E comes down tothe bottom.<br><br>3. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br><br>4. So, S is the larger of the two children R and S, and now H is still smaller than both its children, so we promote the larger which is P.<br>
formulate|sentence cnt : 1 <br> <br>1. No way can you formulate theproblem as so called parking problem.<br>
pair|sentence cnt : 23 <br> <br>1. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>2. And then a series of pairs of object names.<br><br>3. Now we canpair H against the root of the right subtree of E, and that's R and it's lessso we have to go left cuz everybody to the right of R is bigger and H is smaller.<br><br>4. So we're going to have nodes in the linkedlist that have key value pairs.<br><br>5. Now, but the thing is, foreach pair of particles, so if you have N particles and you have todo it for each pair, that's N squared.<br><br>6. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>7. Now, it's essential that the array size is greaterthan the number of key value pairs N.<br><br>8. So, a one-dimensional justmeans we have one key, so we'll insert a key value pairs before and what we want todo is to be able to search for a key, and a value associated with it, want to b eable to delete.<br>
elapsed|sentence cnt : 1 <br> <br>1. We're going to pull off the two particles and then we'regoing to all, we're going to move all particles by the amount of time that haselapsed since the last event.<br>
replaces|sentence cnt : 1 <br> <br>1.And the way we do it is, first make a temporary 4-node that replaces that3-node.<br>
cross|sentence cnt : 9 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. Sothat, that means you'd have, if you did exactly and [inaudible] + n/2 + n/4 and soforth which adds up to about two N compare so linear cross.<br><br>3. So let's, we have 2N over 2s and then for each one of these we have divided into Nover 4s and each one of those 4N over 4s has anextra cross for the merge of N over 4.<br><br>4.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>5. Well 2N over 2 is N, 4N over 4 is N and wekeep going down, doing that til we get down to D of 2 and we always forthe extra cross for the merge, we have N.<br><br>6. If you come straight across,there might be a closer point.<br><br>7. When we get to the pointers cross we breakout of the loop and exchange the partitioning element into position.<br><br>8. So we exchange itwill lt and increment both i and lt and now where the point, where the pointershave crossed i and gt across there's nothing that we haven't examined yet.<br>
proficient|sentence cnt : 2 <br> <br>1. Another reasonmany people study algorithms and I suspect many of you, is it's necessary tounderstand good algorithms, efficient algorithms, a good data structures inorder to be a proficient programmer.<br><br>2. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br>
manipulating|sentence cnt : 2 <br> <br>1. So we don't need so much any more generalprograms for manipulating linked-lists.<br><br>2. And that's just a way to describethat we're going to be manipulating node objects that each consists ofa string and a reference to another node.<br>
iterable|sentence cnt : 8 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. And the iterable just returns allthe key to iterate.<br><br>3. You might also want it to be iterable but we'll skip that for now.<br><br>4. So what we're going to do is look at how tomake our stack, and queue, and other data structures that we consider later onimplement the so-called Iterable interface and it will work for client code no matterwhich implementation we used so let's take a look at the details of that.<br><br>5. And that's, a queue is an iterable data structure, and the clientcan iterate that.<br><br>6. So what'san Iterable? Well, in Java lingo what an Iterable is, it's, it's a class that has amethod that returns an iterator.<br><br>7. So, it's hasNext() and next() and so to make the data structureiterable, we're going to implement those things.<br><br>8.So it's got to implement Iterable so what does that mean implement Iterable? It'sgot to have a, a method iterator() that returns an iterator.<br>
researched|sentence cnt : 1 <br> <br>1. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br>
automatically|sentence cnt : 1 <br> <br>1. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br>
probability|sentence cnt : 10 <br> <br>1. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>2. If the probability is high and there is a lot of open sides, itdefinitely is going to percolate.<br><br>3. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br><br>4. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>5. And that just means that it's well shuffled, that every possible way of shuffling the deck appears with equal probability.<br><br>6. And again, if the uniform hashing assumption holds the probability that thenumber of keys within a list is within a constant factor of N over M is extremelyclose to one.<br><br>7. That's white in the diagram with probablyP or blocked, that's black of the diagram with probability one - P and we define asystem to, we say that a system is percolated if the top and the bottom areconnected by open sites.<br><br>8.So, for every value of k, if you add those up the probability that the partitioningelement is k, plus the cost for the two subfiles, we get this equation.<br>
append|sentence cnt : 2 <br> <br>1. SoJava has general API for sequences of items and its got things like a, append atthe end, remove from the beginning, and so forth.<br><br>2. For example, if you have a large arraywith just a few, that's sorted except for just a few unsorted elementsappended at the end, it's going to be partially sorted.<br>
transition|sentence cnt : 1 <br> <br>1. So the scientific question, or the, mathematical questionfrom this model is, how do we know, whether it's going to percolate or not? Inthis problem and in many similar problems, there's what's called a phase transition.<br>
thinking|sentence cnt : 3 <br> <br>1. And so that's really are thekey to thinking about what are symbol table and symbol tables in general.<br><br>2. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br><br>3. You'll often see programmers thinking that they're implementing a shuffle and for every entry, they just choose a random place in the array to exchange it with, and that doesn't really work.<br>
flip|sentence cnt : 24 <br> <br>1. So, this one we used all three ofour operations, rotate left rotate right and flip the colors.<br><br>2. And then we rotate thetop link right and then, we flip the colors.<br><br>3. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>4. It's called a color flip.<br><br>5. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>6. And we flip the colors and we have a single fournode.<br><br>7. We have to work through other cases that can arise but there's nottoo many so we'll work through and we have the basic operations, left rotate, rightrotate, and flip colors.<br><br>8. We flipped the colorsand now our temporary 4-node is up higher in the tree but it's not balanced so weare going to have to do two rotations to make that balanced.<br>
hashcode|sentence cnt : 5 <br> <br>1. So what we can do is it's pretty easy to find a family of stringsthat have the same hash code for example with just a little fooling around now daysyou can just look it up on the web, you can see that these two character keys,both have the same hash code because when you just do the math in a base 31 hashcode it'll tell you that answer.<br><br>2. If it's a reference type,use that hashCode and apply recursively.<br><br>3. If it's a primitive type,use the wrapper hashCode.<br><br>4. So if it's an integer the hashcodes suppose to be 32-bits, integer supposed to be 32-bits.<br><br>5. There's another family of methodswhere there's no ordering, and there's a special methodcalled hashCode that helps us inject randomness into the process.<br>
performs|sentence cnt : 2 <br> <br>1. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>2. Infact, there's an argument for just using this implementation of Quicksort andforgetting about horse because it performs so well in so many practical situations.<br>
handles|sentence cnt : 5 <br> <br>1. [cough] or in, in youknow, in the case when we're just inserting a new node and it's turns out tobe the right red link attached to a black one, if that handles that case.<br><br>2. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br><br>3. And the key to understanding this code is to realize that the same code,code handles all of the cases.<br><br>4. And, it also handles moregeneral situations, as we'll see later on.<br><br>5.left and that the handles both cases zero and one.<br>
quick|sentence cnt : 115 <br> <br>1.That's a complete implementation of Quicksort.<br><br>2. Quicksort not stable.<br><br>3. This is the Quick-findalgorithm.<br><br>4. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. So, how are we going to do better? Our first attempt is analternative called, Quick-union.<br><br>7. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>8. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br>
raised|sentence cnt : 1 <br> <br>1. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
relating|sentence cnt : 1 <br> <br>1. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br>
grain|sentence cnt : 2 <br> <br>1. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>2. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br>
lowest|sentence cnt : 3 <br> <br>1. The other thing is, ifyou take the point with the lowest y coordinate.<br><br>2. And then fromthat, you can figure out how many keys there are or return them all between theindex, the lowest one in the range, index the highest one in the range.<br><br>3. So, the point with thelowest y coordinates on the convex hull and shows the one that is the smallestpolar angle that creates with the x-axis.<br>
robot|sentence cnt : 1 <br> <br>1. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br>
worse|sentence cnt : 11 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. So we'll, we'll come back to dealing withthat worse case in the next lecture.<br><br>3. The worse that can happen is that it alternates redand black.<br><br>4. All different types of problems mightoccur and with some difficulties, it's possible to prove thateven if the tree's balanced, you can get a worse caseproportional to square root of N.<br><br>5.>> And not only that once you have a big cluster and you hash into the middle of ityou've got a good chance that, that clusters going to get longer, or worse.<br><br>6. With geometric data,the worse case can be bad, so like all the points couldbe arranged in a circle.<br><br>7. And what's worse, if you try to fix it by say, randomly choosing between the left and the right.<br><br>8. It still takes quadratic time in the worse case but Heapsort does both.<br>
genome|sentence cnt : 2 <br> <br>1. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>2. They're used for movies andvideo games, for particle collision simulation, they're used to study thegenome, and all manner of other applications.<br>
mostly|sentence cnt : 2 <br> <br>1. We use the Java language, but we don'tdwell on details of Java, we mostly use it as an expository language.<br><br>2. We're going to start outwith the comparable mostly.<br>
numbers|sentence cnt : 35 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br><br>3. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>4. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>5. So they felt that they got betterpartitioning than a random shuffling and it was also less costly and thengenerating random numbers including this change of state problem.<br><br>6. If you have a hugenumber of operations and every one of them is proportionalto the symbol table size, then you're just not going to be ableto support huge numbers of keys.<br><br>7.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>8. And again, as we know,such an algorithm is not going to be practical, for huge numbers of linesegments.<br>
tree|sentence cnt : 437 <br> <br>1.So we move to the left and compare H against the root of the left subtree.<br><br>2. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>3. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>4. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>5.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>6. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>7. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>8. B and this b treewould go down the left link.<br>
applicable|sentence cnt : 1 <br> <br>1. It's applicable to animportant application that we'll see in a.<br>
arise|sentence cnt : 2 <br> <br>1. These types of things ariseoften in practical applications.<br><br>2. We have to work through other cases that can arise but there's nottoo many so we'll work through and we have the basic operations, left rotate, rightrotate, and flip colors.<br>
probin|sentence cnt : 16 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>3. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>4. But, in linear probing, to insert what we do is when we put it inposition I if that's free, if not we just look at I plus one, and I plus two, andwrap around to the beginning if we reach the end.<br><br>5. So that's a short demo of linear probing hashing.<br><br>6. And, sothere was quite a bit of effort, devoted to figuring it out, how full we could getthe hash table, in linear probing.<br><br>7. So, what happens is that you are on a one waystreet and you are looking for a parking place and, it's, the idea's you startlooking for a parking place at particular times and say "Okay, now I need a parkingplace", and what you're doing is linear probing hashing.<br><br>8. With linear probing is called open addressing and isalso around the same time in the 50's the idea is just use an array.<br>
algorithmically|sentence cnt : 1 <br> <br>1. There's other things that we can doalgorithmically to bring down the search time a little bit.<br>
holds|sentence cnt : 4 <br> <br>1. And again, if the uniform hashing assumption holds the probability that thenumber of keys within a list is within a constant factor of N over M is extremelyclose to one.<br><br>2. So we are going to use a min-oriented priority queue sothat's going to keep, it'll [cough] it'll be one where we can delete the minimumand, and it'll be generic so we'll have a transaction type that holds thisinformation including natural ordering where it's ordered by dollars that lastcolumn.<br><br>3. When you makean assumption you better be sure and you're depending on that assumption, youbetter be sure that it holds somehow.<br><br>4. And then it turns out that it holds forall N, which we can prove by induction fromthe recurrence.<br>
rank|sentence cnt : 25 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. [COUGH] All right, so this is the code for the get operation andthis rank which is binary search.<br><br>3. So now,how do we implement rank? Well, it's a little like floor.<br><br>4. So in this case, the rank of e is twoand h is three and so forth.<br><br>5. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>6. And if it's unsuccessful, you can use that rank to figureout where to insert the new key.<br><br>7. We started with one dimensionalrange search and just used regular binary search tree to compute ranks to get theanswer.<br><br>8. So that's a trace of implementing binarysearch to find the rank of a key in ordered array.<br>
equivalence|sentence cnt : 3 <br> <br>1. So we assume that is connectedto is an equivalence relation.<br><br>2. S that means that, in mathematical terms,equals is called an equivalence relation.<br><br>3. When we have an equivalence relationa set of objects and connections divide into subsets called connected components.<br>
hatch|sentence cnt : 3 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. If we're going to search for say L L's hatch value is six so it's notthere.<br><br>3. Use another hatch function todetermine the stride that we're going to use.<br>
finished|sentence cnt : 1 <br> <br>1. And now H has no right child, just a left child and it's larger than that one so now we're finished with that operation.<br>
kinds|sentence cnt : 17 <br> <br>1. Those areall at the level of exercises in the context of the kinds of algorithms thatwe've seen.<br><br>2. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>3. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br><br>4. A fundamental andextremely important data type that have led to all kinds offascinating implementations and we're going to look at severalof them in this course.<br><br>5. Andthis is a very general concept that's useful in all kinds of context.<br><br>6. There's all kinds of cases where we justhave a lot of information, maybe on our PC or all over the web, and we want to createan index that allows us to specify.<br><br>7. So people have developed all differentkinds of methods for adapting in this way.<br><br>8. We modeled theproblem to try to understand precisely what kinds of data structures andalgorithms we'd need to solve it.<br>
bsts|sentence cnt : 13 <br> <br>1. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>2. So this is, and actually the versionthat we're going to, looking at is called left-leaning red-black BSTs.<br><br>3. So, the 2-3 tree is a way to generalizeBSTs to provide the flexibility that we need to guarantee fast performance.<br><br>4. Here's our summary of where weleft off with red black BSTs.<br><br>5. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br><br>6.Now we're going to look at k-d trees,which is an extension of BSTs that allow us to do efficientprocessing of sets of points in space.<br><br>7. If there is no duplicatekeys Quicksort processes them and referred them out in BSTs and if there's noduplicate keys there's a one-to-one correspondence between what happens withQuicksort and what happens with binary search trees.<br><br>8. And in fact, most of the other operationsthat we implemented on BSTs are also identical.<br>
apologize|sentence cnt : 1 <br> <br>1. I, I think maybe they might have added to this warning statement "We apologize for making you do this".<br>
shuffle|sentence cnt : 28 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. And the question is, can we do better? Can we have a faster way to shuffle? Do we really need to pay the cost of a full sort? The answer to that question is, no.<br><br>3. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>4. So, that's definitely a way to get a deck shuffled quite easily, easy to implement.<br><br>5. You might want to make sure that if you're advertising that you're doing a random shuffle, then you go ahead and do so.<br><br>6. Notice again that it depends on the randomshuffle at the beginning that's going to be important for performance.<br><br>7.That random shuffle at the beginning is important and needed for guaranteeingperformance.<br><br>8.It's gonna to do a shuffle.<br>
machine|sentence cnt : 3 <br> <br>1. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>2. Then, how about space usage? That depends very much onthe implementation and the machine so this is a typical Java implementationthat we do the analysis for.<br><br>3. The other thingthat is probably more significant on modern machines is.<br>
domain|sentence cnt : 1 <br> <br>1. So for example,a domain name server might have a lookup where you've got a tablethat's got an IP address and URL associated with that IP address.<br>
dealt|sentence cnt : 1 <br> <br>1. So, you have to just be aware that these situations have to bedealt with.<br>
fooling|sentence cnt : 1 <br> <br>1. So what we can do is it's pretty easy to find a family of stringsthat have the same hash code for example with just a little fooling around now daysyou can just look it up on the web, you can see that these two character keys,both have the same hash code because when you just do the math in a base 31 hashcode it'll tell you that answer.<br>
iterating|sentence cnt : 5 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>3. Really often what we're doing is just inserting items into a collectionand then, later on, iterating through the items that we have.<br><br>4. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br><br>5. Selection sort is based on iterating that idea.<br>
liner|sentence cnt : 6 <br> <br>1. So that also is a foreliner toimplement the stack push operation.<br><br>2. Then thesecond pass again that's only a two liner, we exchange the first element with the oneat the end and then decrement the size of the heap and then do a sync operations.<br><br>3.Actually to make a one liner code, we use a, a simple variant where we make everyother node in the path point to its grandparent on the way up the tree.<br><br>4. So each of the operations is a one-liner.<br><br>5. And asyou can see, it's a one liner.<br><br>6. So given the sink implementation, we had donea one liner for the first pass and a three liner for the second pass so that gives acomplete implementation of heap sort with the code that we have given so for, sofar.<br>
technical|sentence cnt : 2 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br>
volumes|sentence cnt : 1 <br> <br>1. Now there's four volumes out and moreplanned, and this is where, all computer scientists go.<br>
everything|sentence cnt : 40 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. [COUGH] so the merge implementation then,the first thing it does is copy everything over to theauxiliary array.<br><br>3. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>4. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>5. But fortunately, we can get through prettymuch everything that we're going to do in this course just knowing about this one oflay cast.<br><br>6. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>7. So, that means that you could touch everything in the main memory inabout a second.<br><br>8. If we allow delete, in fact everything degenerates to square root of n.<br>
strength|sentence cnt : 3 <br> <br>1. We can use resizing array in industrial strength implementation, the same that we did for stacks and other data structures where we use arrays.<br><br>2. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br><br>3. That is a fullycomplete industrial strength code for sorting.<br>
presence|sentence cnt : 2 <br> <br>1. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>2.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br>
came|sentence cnt : 8 <br> <br>1. It soonbecame clear that those mathematical models were difficult to solve.<br><br>2. So, even ifit's a huge tree down at the bottom, we just came of a null link.<br><br>3. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br><br>4. But the key point about it is that designing acomputer became a geometric problem.<br><br>5. Even though they came in, in ascending order, the treewinds up being perfectly balanced.<br><br>6. But now, when we have eight to merge with fourand three, we put the eight as the child, no matter which order their argumentscame, because it's the smaller tree.<br><br>7. And we came up with thatbefore when we're talking about using a sort for the Graham scan.<br><br>8. I'm not going tosell tickets to anyone that came after that time.<br>
exchanging|sentence cnt : 8 <br> <br>1. To put it in sorted order, we have to movefrom right to left, exchanging it with every larger elements to its left, andthat's what the code at the bottom does.<br><br>2. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br><br>3. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br><br>4. So we move up the tree exchanging the larger key with its smaller parent until we get to a point where it's larger than both its children.<br><br>5. Again, we take it out by exchanging this time G with a root, and then decrease the size of the heap by one and just take that out.<br><br>6. Exchanging it with the.<br><br>7. And that's going to involve, exchanging withthe T, because T is larger than O.<br><br>8. And exchanging with the P because P is largerthan O.<br>
returns|sentence cnt : 21 <br> <br>1. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>2. If they're equal, it returnstrue.<br><br>3. If get returns in non null value, then there's a value correspondingto that key in the table.<br><br>4. In particular,all Java classes inherit a method called hash code which is returnsa 32-bit int value.<br><br>5. So, we're goingto use a method less() that takes two Comparable objects as arguments and itjust returns, v.<br><br>6. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br><br>7. We change our left link which isright now it's null to whatever put returns.<br><br>8. That returns true if the ported is sortedand false if it's not.<br>
leaving|sentence cnt : 3 <br> <br>1. And actually, you can make some progress with this kind of method, leaving tombstones through out the tree.<br><br>2. And just leaving empty positions around, in a hash table, orusing links in a link list, did not seem like an appropriate use of space.<br><br>3.And then the sum collapses just leaving the last term.<br>
valid|sentence cnt : 8 <br> <br>1. We'regoing to test whether it's valid.<br><br>2. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>3. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>4. But it might be the case thatthere's a third particle that knocks one of those out before that thing happens andthat event would be invalidated.<br><br>5. And then again, we need an, is valid to check aboutintervening collision.<br><br>6.And also, it allows us to develop a math model that we can go ahead and validatewith experimentation.<br><br>7. Then, we test whether that event has been invalidated.<br><br>8. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
debug|sentence cnt : 4 <br> <br>1.We think that one is bad news, we don't use it can lead to insidious debug, bugdebugging problems.<br><br>2.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>3. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br><br>4. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
carefully|sentence cnt : 5 <br> <br>1. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br><br>2. You have to carefully check the code to be sure.<br><br>3. So here's the, this is very concise recursive codebut its tricky because of that last point so its worth reading carefully.<br><br>4. So, taking a look at equal keys is carefully is something thatcan lead us to very efficient Quicksort.<br><br>5. And that's going to be a discipline thatwe're going to follow carefully throughout this course.<br>
crafted|sentence cnt : 1 <br> <br>1. We have ourcarefully crafted code that does array resizing and so forth and we're going tocopy that code and change the data type string to the data type van or int toeverywhere.<br>
incomplete|sentence cnt : 1 <br> <br>1. We consider all null nodes to be black nulllinks to be black, we don't have red links dangling off, that would be incompletepre-nodes.<br>
concept|sentence cnt : 8 <br> <br>1.And the concept is very simple.<br><br>2. Those are some basic data structuresand implementations and it seem quite elementary and simple but actually rightaway we can get to some very sophisticated applications of these basic concepts andthat's what we're going to consider next.<br><br>3. Andthis is a very general concept that's useful in all kinds of context.<br><br>4. And that concept is that there's some naturalordering of the data that you'll want to use most of the time, that's what theComparable interface is all about.<br><br>5. And so the, it's the concept of so called one way hash functions whichmean that we, we, use it for secure to try to be, have some secure fingerprints foruse on the web.<br><br>6. Theconcept of an algorithm was formalized actually here at Princeton, by Church andTuring, in the 1930s.<br><br>7. Is are those precisely the same objects ornot? Now usually in applications where wewant to have something more general than that, we have a concept of a value orlike a key in our case.<br><br>8. So it's a very fundamental concept andwe'll look at plenty of applications.<br>
task|sentence cnt : 1 <br> <br>1. We're given an array of n items that areordered and our task is to find the k-th largest.<br>
consisting|sentence cnt : 1 <br> <br>1. Oneconsisting of just object zero, second one objects one, four and five.<br>
then|sentence cnt : 625 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>3. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>4. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>5. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>6. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>7.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>8.And if it's not a CCW turn, it pops and then continues going.<br>
facility|sentence cnt : 2 <br> <br>1. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>2. There's another facility that Javaprovides that leads to very elegant compact client code that's definitelyworthwhile to add to our basic data types and that's iteration, that's what we'regoing to talk about now.<br>
runs|sentence cnt : 1 <br> <br>1. And what's interesting about insertionsort is that it runs in linear time for partially sorted arrays.<br>
percent|sentence cnt : 2 <br> <br>1. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br><br>2. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
appropriately|sentence cnt : 2 <br> <br>1.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>2. But it's only going to be fast, ifthe, table size is set appropriately.<br>
setting|sentence cnt : 2 <br> <br>1. And, and in many applications evensetting M = 100 or 1,000 is going to be very effective.<br><br>2. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br>
extensive|sentence cnt : 3 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br><br>3. Now, it's important to not create theauxiliary array in the re in the recursive routine because that couldlead to extensive cost of extra array creation.<br>
values|sentence cnt : 59 <br> <br>1. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>2. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>3. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>4. Another right parenthesis, take the top two values off.<br><br>5. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>6. Take one of our symbol table implementationsand get rid of the code that refers to values.<br><br>7. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>8. We start with therandomly ordered input and you can see that it gets more and more in order oneach time that we h-sort for the decreasing values of h.<br>
longer|sentence cnt : 5 <br> <br>1. You get long clusters and they're likely to getlonger.<br><br>2. First thing is the inner loop is longer than Quicksorts.<br><br>3. So, we're going to take T and we're going to exchange it with the last element, and then declare that to be no longer part of the heap.<br><br>4.>> And not only that once you have a big cluster and you hash into the middle of ityou've got a good chance that, that clusters going to get longer, or worse.<br><br>5. So move the H up, and actually put the root value there, just exchange them but it's no longer in the heap.<br>
cars|sentence cnt : 1 <br> <br>1. So, we implemented stack of strings but in applications wehave all different types of data that we might want to implement like stack of intsay or URLs or cars or vans or whatever data that we might be processing.<br>
funtion|sentence cnt : 1 <br> <br>1. So we just essentially, using the hash funtion as anarray index.<br>
processes|sentence cnt : 2 <br> <br>1. If there is no duplicatekeys Quicksort processes them and referred them out in BSTs and if there's noduplicate keys there's a one-to-one correspondence between what happens withQuicksort and what happens with binary search trees.<br><br>2. You processes through the expression from left to right.<br>
records|sentence cnt : 3 <br> <br>1. Say,university has student records and for every student there is a certain amount ofinformation.<br><br>2. But in particular, there's a piece of a recordcalled a key and what we want to do is put the records into order according to thekey.<br><br>3. So, the typicalapplication that I just used as an example is say the set of student records.<br>
well|sentence cnt : 176 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>3. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>4.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>5. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>6. Just put them in anarray, and then, well, insertion is, is fast.<br><br>7. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>8. Well no, the maximum,end point in the left node is eight.<br>
precisely|sentence cnt : 6 <br> <br>1. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>2. We modeled theproblem to try to understand precisely what kinds of data structures andalgorithms we'd need to solve it.<br><br>3. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br><br>4. So this is precisely the binarysearch code that we looked at before.<br><br>5. Is are those precisely the same objects ornot? Now usually in applications where wewant to have something more general than that, we have a concept of a value orlike a key in our case.<br><br>6.That's corresponds precisely to our temporary four node when we're doing 2-3trees.<br>
static|sentence cnt : 4 <br> <br>1. So this isa static method that is supposed to return true if the array is sorted and false if it'snot.<br><br>2. The way we do that is to takethe two primary operations, compares and exchangers that were that were, were usedto refer the data and encapsulate them just the static methods.<br><br>3. So now our sort methods to referthe data will just use this two static methods.<br><br>4. And this is a fine data structure forsymbol tables where there is, [COUGH] that are relatively static, where the values don't change much,and most of the operations are search.<br>
strike|sentence cnt : 1 <br> <br>1. But with random, the random shuffle it'smore likely that this lecture will end, because of a lightning strike.<br>
benefit|sentence cnt : 2 <br> <br>1. They d on't need the colors,but they can all benefit from the fact that the trees are much better balanced.<br><br>2. We don't get any benefit from having it in a treeshape.<br>
last|sentence cnt : 40 <br> <br>1. And then the last thing we need to do isjust return the item that we saved away.<br><br>2. Make sure that both first andlast are always what we want them to be.<br><br>3. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>4. That is, we need that extra auxiliaryarray for the last merge.<br><br>5. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br><br>6. And then the last one changesthe value at E, again, 12.<br><br>7.Now the last element in the left sub array is the one that's going to get moved next.<br><br>8. So we, to add it at the end, so first thing we need to do is save a link,the last node.<br>
mistakes|sentence cnt : 2 <br> <br>1. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>2.Now there are some things that you have to watch out for with Quicksort because theimplementation is a bit fragile and it's easy to make mistakes.<br>
supposed|sentence cnt : 17 <br> <br>1. If we're not done we're supposed to return true and the next() is supposed togive the next item in the iteration.<br><br>2. So, say, four is supposed to be unio n with three.<br><br>3. Supposed to search the right subtreeat 1 next, but we can prune that.<br><br>4. And what are we supposed to do then? Well, to maintain thevariant there we just need to increment i.<br><br>5. So this isa static method that is supposed to return true if the array is sorted and false if it'snot.<br><br>6. So, now suppose we were supposed to add S.<br><br>7. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>8. All it's supposed to do isimplement those operations.<br>
notation|sentence cnt : 2 <br> <br>1. In order to get that done, we're sortingthe left half and the right half and this notation ceiling of N over 2 andfloor of N over 2 that's the N over 2 round up and N over 2 round down, that'sthe size of the two sub-arrays, and we're going to call the same routine forthat size, so the number of compares you needto.<br><br>2. We use the notation Lg always for logarithm to the base two.<br>
taken|sentence cnt : 7 <br> <br>1. That's the average number of comparisonstaken by Quicksort, and actually they for a random permutation of the elements whichis what we do with the shuffle.<br><br>2. And whichever one is taken, we incrementits pointer.<br><br>3. In the case of Quick Sort, the number ofcomparisons taken to sort N items is N+1 for the partitioning.<br><br>4. Out of all the orderings the one that's further stand in the tree that'sthe worst case and so the algorithm, no matter what the input is, the tree tellsus a bound, the number of compares taken by the algorithm.<br><br>5. If the current space istaken, you try the next space and the one after and so forth.<br><br>6. This plot is another way of looking at it, which is the number of array accessestaken as you implement push operations.<br><br>7. The problem is nobody knows an accurate model for describingthe number of compares taken by Shellsort for any interesting increment sequence.<br>
lack|sentence cnt : 84 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>3. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>4. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>5. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>6.right is black and so forth.<br><br>7.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>8. So a blacklist clientwould print out all the words in our source file, tinyTale.<br>
constant|sentence cnt : 37 <br> <br>1. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>2.That's going to be a constant extra cost.<br><br>3.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>4. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>5. In this case, it's easy to see that every operationtakes constant time in the worst case.<br><br>6. Wehave constant time access to every element, but the space is proportional toN.<br><br>7.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>8.Just a constant number of operations and that's why, this operation, is, ingeneral, efficient.<br>
abouta|sentence cnt : 4 <br> <br>1. Today we're going to talk aboutalgorithms and data structures for implementing some fundamental datatypes called bags, queues, and stacks.<br><br>2. If one of the particles is null then we're talking abouta wall, a vertical or horizontal wall.<br><br>3. And for overflow, what happenswhen the client does too much? We're going to talk aboutan approach called resizing that will allow us to avoid overflow forclients.<br><br>4. So if we, we aretalking abouta randomized model where the sites are vacant with the givenprobability.<br>
given|sentence cnt : 58 <br> <br>1. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>2. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>3. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br><br>4. Very little code toimplement the convex hull given that you have a sort and that's our main point forthis lecture - there is many natural applications of sorting but also will beable to develop new algorithms that use sort that gain efficiency because of theefficiency of sorting.<br><br>5. And then, what we're looking for is to find or count the pointsin a given interval in one dimension.<br><br>6. Iwant to be able to create an empty set, we've got methods to add a key to the set,and to check whether a given key is in the set or not.<br><br>7. And we want to be able to find orcount the points in a given rectangle.<br><br>8.If this object is greater than the object given as argument.<br>
adopt|sentence cnt : 4 <br> <br>1. And then,we're going to adopt the convention that the get() method returns null ifthe key is not present in the table.<br><br>2. The way wemaintain, there's a number of ways we can maintain the thing but the one that we'lladopt un iformly because it adapts to more complicated situations is just beforewe're done with the put operation we'll say, okay we've done all our work andbefore we return the pointer to the given subtree we're going to take the size ofwhat's on the left and the size of what's on the right and add one for us and that'sgoing to be our count.<br><br>3. And if we this the, the thing called event which involves it saysbetween two particles, something is going to happen at a certain time and we'regoing to adopt the conventions that, if, neither particle is null then we'retalking about two particles.<br><br>4. There's versions ofmerge sort that come close but they are too complex for practitioners to haveadopted them.<br>
since|sentence cnt : 27 <br> <br>1. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>2. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>3. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>4. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>5. So there's no reference to the old itemleft there and then the garbage collector can reclaim the memory sincethere's no outstanding references.<br><br>6. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>7. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>8. So, since we're making array ofnodes, a node would have generics if we use to key in value.<br>
passing|sentence cnt : 3 <br> <br>1. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br><br>2. It's all about the idea of passing functions asarguments to other functions which is the pair and gets into functional programmingand thinking all the way back to Turing and Church.<br><br>3. So, that'sour basic question, how can sort, now, how to compare data of all those differenttypes without being given any information about the type of an item's key? And theanswer is that what is we set up a mechanism known as a callback or referenceto executable code where the client, by passing an array of objects to the sortfunction.<br>
applicants|sentence cnt : 1 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br>
overflow|sentence cnt : 1 <br> <br>1. And for overflow, what happenswhen the client does too much? We're going to talk aboutan approach called resizing that will allow us to avoid overflow forclients.<br>
standard|sentence cnt : 48 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. And so what the test client'sgoing to do is going to just go in the loop as long asstandard in is not empty.<br><br>3. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>4. And so, this client readsstrings from standard input.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. That's kind of an amazing fact that this rough standard is reallyheld for 50 or 60 years.<br><br>7. So wepick that number, I and then we just go to that list and this is the standard codefor diversing a link list start at the first node as long as it is not null go x= x dot x.<br><br>8. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br>
executed|sentence cnt : 1 <br> <br>1. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br>
roll|sentence cnt : 2 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br><br>2. And if there is, then we couldroll back time just a little bit and I'll try to figure out exactly, the moment ofwhich they collided and then figure out how the position and velocity shouldchange accordingly and then continue the simulation.<br>
collapses|sentence cnt : 1 <br> <br>1.And then the sum collapses just leaving the last term.<br>
usage|sentence cnt : 5 <br> <br>1. Then, how about space usage? That depends very much onthe implementation and the machine so this is a typical Java implementationthat we do the analysis for.<br><br>2. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>3. Really what we proved is that mergesort is optimal withrespect to number of compares but we already know that it's not optimal withrespect to space usage.<br><br>4. So what about memory usage? Well, this is the analysisof memory usage for stacks, and it's actuallyless memory than for strings.<br><br>5. B-trees, there's many different variants that, givedifferent characteristics of, space usage and other characteristics.<br>
laser|sentence cnt : 1 <br> <br>1. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br>
unattractive|sentence cnt : 1 <br> <br>1. But this isunattractive because for large numbers of keys, in order to count the keys that fallwithin a given range, you have to go through all the keys and test whetherthey're in the range or not and to return them the same way.<br>
cast|sentence cnt : 21 <br> <br>1. But fortunately, we can get through prettymuch everything that we're going to do in this course just knowing about this one oflay cast.<br><br>2. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>3. And that way the client code doesn't docasting.<br><br>4. So, we'll build a new array of keys and we have to use an ugly cast because of generic arrays in Java, and that's where it's comparable and we need one more than the capacity to handle this thing where we don't use position zero.<br><br>5. Okay then,it's one of the detail that Java takes care of and that's what about primitivetypes [cough] so the generic type that we're using is for objects and you know,we're casting down from array of objects.<br><br>6. So, we want to avoid cast as much as possible because it,it, it really is declaring some kind of weakness in what we're doing.<br><br>7. And if you find a key that's equal to the key you're looking for,return the value and we have to cast it to value because of the generic recreationproblem in Java, otherwise return null.<br><br>8. Theproblem with this is that the client code has to do this, this casting and it's kindof an insidious bug if it doesn't quite get it.<br>
options|sentence cnt : 2 <br> <br>1. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br><br>2.Welcome back, today we're going to talkabout balance search trees, Which will lead us to an ultimate symboltable implementation that can provide fast performance for all the simulative optionswe've looked at, guaranteed.<br>
games|sentence cnt : 2 <br> <br>1. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br><br>2. They're used for movies andvideo games, for particle collision simulation, they're used to study thegenome, and all manner of other applications.<br>
commands|sentence cnt : 7 <br> <br>1. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>2. So that's our problem, intermixunion, commands and connected queries and we need to be able to officially supportthose commands for a large number of objects.<br><br>3. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>4. So we could have,billions of objects, and hope to do billions of union commands on them.<br><br>5. And our simple client is totake some strings on standard input and some pop commands whichare indicated with hyphens.<br><br>6. So, that's our problem, to be ableto officially support these two commands for given set of objects.<br><br>7. So for example, in this set of ten objects, weperformed already, a bunch of union commands, connecting four and three, threeand eight, six and five, nine and four, two and one.<br>
advantage|sentence cnt : 16 <br> <br>1. But for a lot of applications that disadvantage is not viewed to be significant compared to the advantages.<br><br>2. So, if they're going to be comparable,we might as well take advantage of it, both to get more efficient algorithms and to be able to take advantage ofa broader set of operations.<br><br>3. We'lllook at different methods that take advantage of such properties.<br><br>4. So, there's alot of geometric properties of the convex hull that we can take advantage of todevelop an algorithm.<br><br>5. And so we'll do a sync on the S and bring it into a heap ordering, sothat's with just a few exchanges we got that whole array heap order, and now whatwe want to do is take advantage of the heap ordering in the array to do a sort.<br><br>6.But the advantage of that might be that removing the maximum is easy.<br><br>7. And somehow algorithms take advantageof the ability to use null in this way.<br><br>8.But one of the big advantages of Quicksort over Mergesort is that it doesn't take anyextra space.<br>
algebroid|sentence cnt : 1 <br> <br>1. No intersection in the left means no intersections at all, sothose two cases is enough to show that this algebroid finds an intersection, ifthere is one.<br>
brings|sentence cnt : 7 <br> <br>1. Element in the heap in the largestposition in the array which brings that element into its final position in thesorted array.<br><br>2. And that brings it down somewhat andallows us to keep the tables more full.<br><br>3. It grabs an element andbrings it back into position every time.<br><br>4. And then in that case, we just rotate the top one right andthat brings us to this one.<br><br>5. In this case that brings the X up.<br><br>6. So that brings us to this summary where red-blacktrees, we were happy with a log based two of N for search and insert with separatechaining, you can really get it down to a constant number of operations for searchand insert.<br><br>7. What if we want to havequeues and stacks of other types of data? And that brings us to the topic ofgenerics.<br>
lamb|sentence cnt : 1 <br> <br>1. The word lamb appears both in Tom Sawyerand Aesop's Fables, and so forth.<br>
finally|sentence cnt : 8 <br> <br>1. So, now we canlook finally at the main event driven simulation loop.<br><br>2.Finally, we talk about stability.<br><br>3.And finally, seven and three.<br><br>4. On the red one is the onethat's finally put into place.<br><br>5. Andthe P is larger, the two children promote that and then finally, the E comes down tothe bottom.<br><br>6. You can think of that as kind of like the well-known Peter Principle where a node gets promoted to a level where it finally can't be better than its boss, the level of its maximum incompetence.<br><br>7. So, in this case, it starts out with the inputexample shown and then the 13-sort - a few items are moved, 4-sort - a fewmore are moved, and then finally, a 1-sort.<br><br>8. Put the value on to the value stack and finally, the lastright parenthesis, take the two operators of the value stack, operators of the valuestack, and operator of the operator stack, perform the operation, put the result backon the value stack.<br>
developments|sentence cnt : 1 <br> <br>1. And really have enabled a new developmentsand new technology in all of these kinds of applications.<br>
complicating|sentence cnt : 1 <br> <br>1. So life can be complicating when you try to simulate the naturalworld.<br>
user|sentence cnt : 6 <br> <br>1. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>2. Andthis was taking a look at the Qsort that a user found was broken and, and now, thismethod is incorporated into some plenty of system sorts.<br><br>3. so, with the, more [COUGH] complex userinterface, this is, very much what the spotlight or find functionon your computer is doing.<br><br>4. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>5. But for user defined types,you're on your own and we'll talk a little bit abouthow to implement hash codes.<br><br>6. Okay, so that's a standard, this isjust in words the standard recipe for user type optimize forreference equality check against null.<br>
allocate|sentence cnt : 1 <br> <br>1. I use that same space, and just,allocate an array.<br>
mans|sentence cnt : 1 <br> <br>1. And what that mans is that all we can use iscompare, that's the only way we can access the data.<br>
allowing|sentence cnt : 1 <br> <br>1. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br>
lecture|sentence cnt : 24 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>2. So we'll, we'll come back to dealing withthat worse case in the next lecture.<br><br>3. Very little code toimplement the convex hull given that you have a sort and that's our main point forthis lecture - there is many natural applications of sorting but also will beable to develop new algorithms that use sort that gain efficiency because of theefficiency of sorting.<br><br>4. It's a traditional, text bookthat extensively covers the topics in the course, in fact many more topics than wecan present in lecture.<br><br>5. And we'lllook at the next lecture of what it means the divine ordering among objects, littlemore general than what we do for sorting.<br><br>6. And then, this is just for simplicity to get this done andjust part of a lecture.<br><br>7. It can't maintain a dynamic table efficiently with binarysearch and that's going to be your focus in the next lecture.<br><br>8. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br>
translate|sentence cnt : 1 <br> <br>1. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br>
bins|sentence cnt : 7 <br> <br>1. When does all the bins fill up? That's called the couponcollector problem.<br><br>2. So we've got M bins, that's ourcorrespondence to our hash table.<br><br>3. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>4.And what about the analysis? Well, again this the [cough] standard probabilisticanalysis of the balls and bins problem tells us a lot of information of what goeson.<br><br>5. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br><br>6. And we'd throw them universallyat random into M bins.<br><br>7. In particular,it's known that after you've thrown M balls into the M bins then the most loadedbin has about log M over log M balls.<br>
bags|sentence cnt : 2 <br> <br>1. Today we're going to talk aboutalgorithms and data structures for implementing some fundamental datatypes called bags, queues, and stacks.<br><br>2. We'll consider a number of data structures and algorithmsthat are basic to all the methods we consider including stacks, queues, bagsand priority queues.<br>
maximum|sentence cnt : 31 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. Then delete themaximum.<br><br>3. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>4. Well no, the maximum,end point in the left node is eight.<br><br>5. So, it's just binary treeinsertion, but then after the insertion on the way up, we go ahead and, check, if themaximum that we have is bigger than the maximum there and update it if necessary.<br><br>6. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>7. The maximum end-point in the left is 22, and we're looking for 23, andwe're not gonna find anything there, so we just wanna go right.<br><br>8. So, delete the maximum we have to do two things.<br>
polynomial|sentence cnt : 1 <br> <br>1. A way of evaluating a polynomial ora number.<br>
explanation|sentence cnt : 1 <br> <br>1. And kind of an explanation for how it getsthe sort done so quickly.<br>
hash|sentence cnt : 146 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>3. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>4. So you have to use hashing if you don't havethe comparison.<br><br>5. For example Java publishesits hash function.<br><br>6. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>7. So we've got M bins, that's ourcorrespondence to our hash table.<br><br>8. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br>
decreasing|sentence cnt : 5 <br> <br>1. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>2. We start with therandomly ordered input and you can see that it gets more and more in order oneach time that we h-sort for the decreasing values of h.<br><br>3. And we have the items onthe list in a decreasing order of when they were put onto the stack.<br><br>4. And what we're going to do is implement a sorting method thath-sort for decreasing sequences of values of h.<br><br>5.And continue that way throwing out two over decreasing numbers all the way downuntil we get down to two elements, c1 which is zero.<br>
observed|sentence cnt : 1 <br> <br>1. And people understand properties ofthe universe by doing these kinds of calculations and comparingagainst what's observed in space.<br>
recovery|sentence cnt : 1 <br> <br>1. And they had a complex error recovery process that,that got triggered if the height limit got too big.<br>
concentrate|sentence cnt : 3 <br> <br>1. They the expected number of comparisons isconcentrated around this value.<br><br>2. And it's important for us to know that theory and that willhelp us decide how to choose which algorithms we're going to use in practice,and where to concentrate our effort in trying to find better algorithms.<br><br>3. We're going to concentrate onprogramming and problem solving in the context of real applications, and ourfocus is going to be on two things, Algorithms which are methods for solvingproblems and data structures which store the information associated in problem,with a problem and go hand in hand with algorithms.<br>
feeling|sentence cnt : 7 <br> <br>1.So this gives a feeling for the.<br><br>2.Again, studying this, a, a trace like this, gives a, a good feeling for exactlywhat's going on in the recursive program.<br><br>3.So you got a visual feeling of how this sort getsthe job done.<br><br>4. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br><br>5. And you'll have a good feeling for how this data structure works.<br><br>6. And again, you can get a feeling for where the proposition comes fromby looking at this N by N trace.<br><br>7. It's alittle better feeling for what's going on.<br>
causing|sentence cnt : 2 <br> <br>1. So, what we do is try to figure out why, find a way to addresswhatever's causing that problem, find a new algorithm and iterate until we'resatisfied.<br><br>2. And then we'll pass the s plit up causing asplit up higher so the red keys in the internal nodes are copies of keys downbelow that direct the search.<br>
null|sentence cnt : 75 <br> <br>1. Now there's a couple ofconventions around null.<br><br>2. Links can be null.<br><br>3.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>4. We'll populate its fields andthen that old link will change that from null toa pointer to the new node.<br><br>5. So if xis null, we want to create a new node and return the link to that node.<br><br>6. So wepick that number, I and then we just go to that list and this is the standard codefor diversing a link list start at the first node as long as it is not null go x= x dot x.<br><br>7. If get returns in non null value, then there's a value correspondingto that key in the table.<br><br>8. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br>
something|sentence cnt : 51 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>3. Andthat's definitely something to worry about.<br><br>4. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>5.That is, we allow for the possibility of something called a 3-node that can holdtwo keys, But then it has to have three children.<br><br>6. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>7. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>8. And again, that's a little harder to do withsomething like a red black tree where we have performance guarantees.<br>
computers|sentence cnt : 13 <br> <br>1. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>2. Now it's true whencomputers only have a few thousand words of memory and it's true now that they havebillions or more.<br><br>3. But now, let's look at the computerscience code.<br><br>4. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>5. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>6. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>7. The computers get bigger but they get faster so to toucheverything in the memory is going to take a few seconds.<br><br>8. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br>
unacceptable|sentence cnt : 2 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>2. Quadratic time to insertN items into a stack, that kind of performanceis unacceptable for large problems, as we've seen,as we will see many times.<br>
restoring|sentence cnt : 1 <br> <br>1. That's restoring the heap border along a path from the place where it's violated to the root.<br>
sorts|sentence cnt : 29 <br> <br>1. When we're using inShellsort of course, we find the largest increment less than our file size and thendo the sorts for decreasing values of that increment.<br><br>2. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>3. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>4. The idea is that you create acomparator object and then pass that as a second argument to Java's sort routine andwe can do the same thing for our sorts.<br><br>5. And it's a very interesting extension ofthe ideas that we've looked at for symbol tables for all sorts of familiarapplications.<br><br>6. It was named as one of the most importantalgorithms of the twentieth century and it's widely used for system sorts and manyother applications.<br><br>7. It generalizes thestack and the queue and gives us a data structure that we can use to effectivelydesign algorithm of all sorts.<br><br>8. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br>
immutable|sentence cnt : 14 <br> <br>1. There's many other reasons that people use immutable data types.<br><br>2. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>3. And again as with priority qs the bestpractice is to use immutable types.<br><br>4. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>5. So and actually, since strings are immutable,what Java does is keep the hash value in an instancevariable so it only gets computed once.<br><br>6. And that array, it's got value stored in it, say it doubles and those can change but what immutable implementation would do would be to copy those values into the local data array instance variable and then those values are not going to change.<br><br>7. And so a constructor for an immutable vector data type, it might take an array as its argument.<br><br>8. And the next time you ask forthe hash code of that string, it will just provide it andthat works because strings are immutable.<br>
random|sentence cnt : 94 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>3.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>4. So if the points are randomly distributed,then this is ideal.<br><br>5.And in fact, in many real applications, they're not very random.<br><br>6. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>7. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>8. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br>
preprocess|sentence cnt : 2 <br> <br>1. Or more generally, people want to oftenprocess, preprocess text to, maybe a huge amount oftext, to support, so called, concordancequeries.<br><br>2. And just to simplify the codeand to get it the main principles of the algorithms, we're going to assume that allthe coordinates that we have are distinct that we've preprocessed in some way toremove the ones that touch without intersecting.<br>
geese|sentence cnt : 1 <br> <br>1. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br>
sequence|sentence cnt : 26 <br> <br>1. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>4. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br><br>5. It could be that there aresome increment sequence out there that make Shellsort more efficient than anyother method, any of the sorting method that we know for pratical file size, noone can deny that.<br><br>6. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>7. So, the analysis now says thatthe average running time per operation forwhatever the sequence of operations is, the average running time is going tobe proportional to a constant.<br><br>8. [COUGH] So, the idea andthe consequence of this is, if you insert N items into an array, intoa stack with this array representation, the time will be proportional to N,not N squared.<br>
replaced|sentence cnt : 2 <br> <br>1. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>2. So it's worthwhile youknow, checking that you believe that this code implements the simple binary searchtree algorithm that we demoed where when we fall off a null link we created a newnode and replaced that null link with the new node .<br>
desirable|sentence cnt : 4 <br> <br>1. That's, that's really adesirable way to look at it and let's take a look at that option.<br><br>2. It doesn't have this highly desirableattribute but everything would compile.<br><br>3. So that's obviously a verydesirable characteristic.<br><br>4. It's not somethingthat you will come up with on your own and that's, and that's an undesirable feature,I think for codes so simple as this.<br>
line|sentence cnt : 171 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. So here'sa summary of linear probing, hashing.<br><br>4. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>5. If we have a 10,000 by 10,000 matrix we can get it donenearly instantly linear time versus 10,000^2.<br><br>6. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>7. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>8. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br>
simulation|sentence cnt : 32 <br> <br>1. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>2.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>3. So figuring outthe value of dt that would really work is a huge problem for the time drivensimulation.<br><br>4. So, now we canlook finally at the main event driven simulation loop.<br><br>5. Instead, what we want to do is called an event driven simulation.<br><br>6. So now,let's look at the main loop for the event driven simulation.<br><br>7. So, that's all the code for doing the bouncing ball simulation.<br><br>8. So, the simulation has to be careful to take thatinto account.<br>
sacrificing|sentence cnt : 1 <br> <br>1. And how close it could get to full withoutsacrificing performance.<br>
flaw|sentence cnt : 2 <br> <br>1. Howcould we guarantee that all operations are fast? Binary research is pretty good butthat's a major flaw.<br><br>2. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
expressed|sentence cnt : 1 <br> <br>1.Now, we'll take a look at how the sortingalgorithms that we talked about or expressed in the systems that we useeveryday.<br>
stays|sentence cnt : 4 <br> <br>1. So, that value stays the same.<br><br>2. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>3. That stays to be 24.<br><br>4. The tree staysvery balanced.<br>
extends|sentence cnt : 3 <br> <br>1. We say that our generic type Key extendsComparable of Key.<br><br>2. And as we'll see this extendsto a practical problem in a number of situations.<br><br>3. There's ways toimplement that don't involve this, but its, the code is so simple and it extendsto more powerful data structures later on that we'll introduce this right now and,and you'll see how it works.<br>
brilliant|sentence cnt : 1 <br> <br>1. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br>
orders|sentence cnt : 9 <br> <br>1. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>2. The same data on different sortkeys, different orders.<br><br>3. We needed tohave a comparison for points that orders them by the polar angle they make, makewith the given point p.<br><br>4. Now but there is this problem that theactual worst case height if the keys come in, in order and reverse order and othernatural orders that the time could be proportional to n.<br><br>5. [cough] And actually, in typical applications with any kind ofrandomness or even if there is a lot of order its difficult to find situationsorders of keys that build the trace of height is bigger than actually one log Nin, in a real application, its very close to fully balanced all the time.<br><br>6. The cartoon on the right showsthat not all orders are necessarily total orders.<br><br>7. Now the node at the root violates the heap orders, so we have to exchange it with the largest of its two children, in this case that's R.<br><br>8. But there's a different interface called theComparator Interface which is a way to help a sort, using some alternate order ormany different orders on the same data.<br>
hashin|sentence cnt : 46 <br> <br>1. So here'sa summary of linear probing, hashing.<br><br>2. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>3. So you have to use hashing if you don't havethe comparison.<br><br>4. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>5. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>6. And it'll probably be faster for simple keys to use hashing.<br><br>7. Hashing really at its core isa classic space-time tradeoff.<br><br>8. So here's just simple example onhashing in java.<br>
indication|sentence cnt : 2 <br> <br>1. At leastthat some indication that you understand the performance characteristics.<br><br>2. This is just first indication of that of why ifyou want to do this simulation, you better know about some data structure likepriority queues.<br>
provider|sentence cnt : 1 <br> <br>1. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br>
fore|sentence cnt : 86 <br> <br>1.And then we do the comparisons as, as before and that, and that's all fine.<br><br>2. And we're, we're going to look at a more general model forexternal storage.<br><br>3. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>4. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>5. There's only a few instructions foreach one of the operations.<br><br>6. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>7. And all it does is just go through the array from the one to the length ofthe array and test if each item is less than the one before.<br><br>8. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br>
events|sentence cnt : 3 <br> <br>1. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>2. And put all those new events on to the priority queue.<br><br>3. And then, we're going to test which of the fourtypes of events that it is.<br>
filled|sentence cnt : 2 <br> <br>1. And then when a node gets filled it splits.<br><br>2. So, we do have a quadraticinitialization phase that we perform just once to get the priority queue filled up.<br>
someone|sentence cnt : 3 <br> <br>1. In such a waythat, it's hard for someone else to find another key that collides with that.<br><br>2. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br><br>3. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br>
straight|sentence cnt : 24 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>3. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>4. And it's quite straight forward simple code as simple as binary searchreally.<br><br>5. And usually that's fairly straightforward.<br><br>6. And this code is straight forward way to implement comparators that you canuse as a model.<br><br>7. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>8.Alright, so here's the code for merging, which is quitestraightforward from the demo.<br>
spanning|sentence cnt : 2 <br> <br>1. We'll see later Kruskal's minimum spanning treealgorithm, which is a graph processing algorithm which uses Union-find as asubroutine.<br><br>2. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br>
bounds|sentence cnt : 3 <br> <br>1.Also staying in bounds.<br><br>2.So, all the paths in a 2-3 tree with N nodes have to have length between thosetwo bounds and those are pretty small numbers.<br><br>3. So, worst casefor lower bounds is when the keys are all distinct.<br>
sectional|sentence cnt : 1 <br> <br>1. So in this case we'llgo right 22, 23 no inter sectional left, so we go right and now we do find anintersection 21, 24 does intersect with 23, 25 because 23 is in the middle there,so we find an intersection.<br>
simplifies|sentence cnt : 2 <br> <br>1. We're going to stick to thisassociative array abstraction and no duplicate keys in the symbol table, because it both simplifies implementationsand leads to simpler client code.<br><br>2. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
storage|sentence cnt : 3 <br> <br>1. And we're, we're going to look at a more general model forexternal storage.<br><br>2. Sothe real property of external storage that not your local memory, is that the timerequired to get to a page is way larger than the time to access data within apage.<br><br>3.>> I thought the red door was the storage container.<br>
hull|sentence cnt : 35 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>3. Atthe beginning, 0->1 is a line that's on the convex hull.<br><br>4. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>5. And there's plenty of other applications where people want to be ableto compute the convex hull.<br><br>6. Sopoint 2 can't be on the convex hull either.<br><br>7. [cough]They're, they're going to be extreme points on the convex hull.<br><br>8. The idea though is that this example illustrates that good sortingalgorithm gives us a good convex hull algorithm.<br>
workable|sentence cnt : 1 <br> <br>1. That's a model of a file system that is pretty workable.<br>
properly|sentence cnt : 6 <br> <br>1. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br><br>2. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>3. If it works properly,putting in the subtree on the right, that's what we want our right link to be.<br><br>4. So, if put works properly inserting a new nodeon the left, then that's what we want our left link to be.<br><br>5. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>6. Then to properly maintain a symboltable in a dynamic situation, in many clients you want tosupport a delete operation.<br>
enclosed|sentence cnt : 1 <br> <br>1. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br>
relevant|sentence cnt : 5 <br> <br>1. We can use a two-dimensional arrayto directly index relevant squares.<br><br>2. And it also just supresses a lot of details that are notrelevant to union find.<br><br>3. So there is the stack there that contains all that informationand whether the function calls itself or not is not relevant.<br><br>4. It's not relevant to the client.<br><br>5. That's a very convenient initial starting point for our programs because wecan use integers as an index into an array then, and then quickly access informationrelevant to each object.<br>
overall|sentence cnt : 2 <br> <br>1. That's going to be the overall architecture forstudying algorithms that we're going to use throughout the course.<br><br>2.The first one is that you have t o check all pairs of balls for overlap so that'squadratic, so it's going to be really, really lot of overall texture you're notgoing to be able to do it for a huge, huge value of N.<br>
increments|sentence cnt : 9 <br> <br>1. For example we can say that the number of comparison and theworst case is O(N3/2) for the 3x + 1 increments.<br><br>2. So we have to look at the code that'sgoing to maintain that invariant as the pointer increments.<br><br>3. We'll just goahead and compute the increments that are less than n, n / 3 and then startingat that increment whatever it is and say, we started 364 then next time we need anincrement, we'll just divide it by 3, 364 integer divide by 3, 364 integer /3 it gets 121, 40 and so forth.<br><br>4.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br><br>5. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>6. But finding the best incrementsequence is a research problem that has confounded people for quite a long time.<br><br>7. But the other thing is if the increments are small because we'vedone previous h-sorts for bigger values of h, the array is partially sortedand so Insertions Sort is going to be fast.<br><br>8. Knuth when he wrote his books in the 60s proposed the incrementsequence 3x + 1.<br>
ability|sentence cnt : 27 <br> <br>1. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>2. If the probability is high and there is a lot of open sides, itdefinitely is going to percolate.<br><br>3. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>4. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>5. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br><br>6. And somehow algorithms take advantageof the ability to use null in this way.<br><br>7. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>8. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br>
expression|sentence cnt : 7 <br> <br>1.The value that arithmetic expression is 101.<br><br>2. So the goal is, you got an arithmetic expression this is justactually like a simple stand in for a program and we'll talk about that in asecond but let's say, arithmetic expressions.<br><br>3. So and then whenyou're done then simply print out the value on the stack and that's a fine andelegant implementation using stacks for any arithmetic expression.<br><br>4. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>5. Now a specific example that really shows this off and also will illustratethe utility of being able to process multiple types of data with the same codeis this example is Dijkstra's two-stack algorithm for arithmetic expressionevaluation.<br><br>6. You processes through the expression from left to right.<br><br>7. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br>
atoms|sentence cnt : 2 <br> <br>1. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>2. Sowhether it's individual atoms and molecules or some bigger kinds ofparticles.<br>
isempty|sentence cnt : 2 <br> <br>1. And then isEmpty is just testing whetherthe first note on the list is null.<br><br>2. Then test isEmpty() and we also sometimes have extra method that justgives us the value of the largest key and also size which is useful sometimes incollections.<br>
studying|sentence cnt : 10 <br> <br>1. If you want, again, if you think that thethings we're studying are easy, think about the idea of actuallydoing an in-place merge.<br><br>2. So, here's a bunch of reasons that I justwent through for studying algorithms.<br><br>3.Again, studying this, a, a trace like this, gives a, a good feeling for exactlywhat's going on in the recursive program.<br><br>4.To finish up, we're going to look at therectangle intersection problem that's got important practical applications and, usesthe techniques that we've been studying so far.<br><br>5. That's going to be the overall architecture forstudying algorithms that we're going to use throughout the course.<br><br>6. The idea of complexity is it's a framework for studying the efficiency of all the algorithms for solving a particularproblem.<br><br>7.Again, as with Mergesort, studying a recursive trace is instructive.<br><br>8. [COUGH] here's a trace of what Mergesortdoes and if you haven't studied a recursive program before it's worthwhilestudying this thing in, in some detail.<br>
route|sentence cnt : 6 <br> <br>1.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>2. If it's in thetree, it's gotta be according to the left or right, according to whether it'ssmaller or larger than the key at the route.<br><br>3. 6's route is zero 1's its own route, so zero becomes a child of one.<br><br>4. All we do is set theID of P's route to the ID of Q's route.<br><br>5. So ithas to split and we have to create a new route, just in the same way as we've beendoing.<br><br>6. So, we used the same datastructure except, now we need an extra array, that for each item, gives thenumber of objects in the tree routed at that item.<br>
impact|sentence cnt : 4 <br> <br>1. And that has profound impact on theperformance of this algorithm.<br><br>2. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>3. So, that's one importantreason to study algorithms, their impact is broad and far-reaching.<br><br>4. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br>
required|sentence cnt : 9 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. So from these rules you can see that the man of code required toimplement this intersecting inter role is extremely low.<br><br>3.Increases the number of exchanges paradoxically, cuz more exchanges arerequired when the partition is right in the middle.<br><br>4.Okay, our basic array implementationof stacks had the defect where we required clients to provide the maximumcapacity of the stack ahead of time.<br><br>5. Sothe real property of external storage that not your local memory, is that the timerequired to get to a page is way larger than the time to access data within apage.<br><br>6. The amount of space required is N squared,for the grid plus N.<br><br>7. So,for example this is a rather complicated formula but not too bad but in a sensethat if you know that the i-th key, it occurs xi times you can write down a lowerbound for the number of comparisons that are going to be required in the worstcase.<br><br>8. So anyway, we're required to makesure that X is always equal to X, and that X equals Y is the same as Y equals X,and if X equals Y and Y equals Z, then X equals Z.<br>
encounters|sentence cnt : 1 <br> <br>1. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br>
outgrowth|sentence cnt : 1 <br> <br>1. Floor and ceiling that's again is an outgrowthof the rank operation.<br>
stable|sentence cnt : 28 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. Quicksort not stable.<br><br>3.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>4. So a stable sort is asort that preserves the relative order of items with equal keys.<br><br>5. Insertion Sort is stable.<br><br>6. And what about Mergesort? Mergesort is stable well,it's stable as long as the merge operation is stable and that operation is going tobe stable depending on how we code it.<br><br>7. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>8. But selection sort is not stable.<br>
subtrees|sentence cnt : 8 <br> <br>1. And our data structure then will be a root thatpoints to a node in the tree and then that node will point to subtrees and that willbe the data structure that we use for symbol tables.<br><br>2.If the parent was a 2-node then the transformation is a local transformationand if you look at where the links are, then it's easy to see by induction that ifthere was perfect balance before there's perfect balance afterward,Because we didn't change anything about the perfect balance in any of thosesubtrees.<br><br>3. So, but anyway, starting at point 3,as far as we know, we're going to have tolook at both subtrees.<br><br>4. All those subtrees, those three subtrees areexactly the same relative to the top and bottom of the tree, as they were beforethe rotation.<br><br>5. So, if we are looking for all the keys between f and t then we haveto look at both the subtrees of the root s.<br><br>6. So sometimes we look at both subtrees,but as we get closer and closer, we only look at 1.<br><br>7. This is a different ordering than we have to heap ifwe have a node larger than both its children, this one, every node is betweenthe values, the value of every node is between the values of the nodes in its twosubtrees.<br><br>8. And those six subtrees drawn could behuge.<br>
down|sentence cnt : 82 <br> <br>1. B and this b treewould go down the left link.<br><br>2. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>3.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>4. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>5. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>6. So, it goes down to the middle, and windsup needing to be inserted in the, 3-node in the middle.<br><br>7. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>8. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br>
shortest|sentence cnt : 3 <br> <br>1. It's guaranteed that the longest path which is alternating red andblack can be no more than twice as long as the shortest path which is all blacks.<br><br>2. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>3. You wanted be able to go aroundthe obstacle and it turns out that the shortest path, either it's a straight linefrom s to t or it's part of the convex hull and is not hard to see why that mightbe true.<br>
bottom|sentence cnt : 74 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2.If it happens to hit the left of the wall then you reflect the x-coordinate in theright wall, you reflect the x-coordinate bottom to top, you do the same for they-coordinate.<br><br>3. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>4. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>5. So the idea is we're going to use a bottom upmethod.<br><br>6. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>7.This bottom-up version that has no recursion, it's also quite simple tounderstand and to code up.<br><br>8. To put it in sorted order, we have to movefrom right to left, exchanging it with every larger elements to its left, andthat's what the code at the bottom does.<br>
poor|sentence cnt : 2 <br> <br>1. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>2. And you'll sometimes see Mergesortperforming poorly because of that bug.<br>
operation|sentence cnt : 217 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>3. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>4. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>5. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br><br>6. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>7. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>8. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br>
fits|sentence cnt : 1 <br> <br>1. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br>
zeros|sentence cnt : 4 <br> <br>1. All those zeros have to getchanged to ones.<br><br>2. If you have a sort method that can store anyvalues in an array, it could, for example, store zeros in every array entry thatmethod would pass this test, but it didn't really correctly sort the array becauseoverwrote all the values.<br><br>3. So, even if there's a lot of zeros we, we still have to take the space to storethem all.<br><br>4. Andthe idea is to cut down on that cost by taking advantage of idea that there's alot of zeros.<br>
alternate|sentence cnt : 4 <br> <br>1. The worse that can happen is that it alternates redand black.<br><br>2. Alternate between horizontal andvertical partitioning of the plane.<br><br>3. But there's a different interface called theComparator Interface which is a way to help a sort, using some alternate order ormany different orders on the same data.<br><br>4. And it's really the sameas a binary search tree, it's just that we alternate whichcoordinate we use as the key.<br>
computerated|sentence cnt : 1 <br> <br>1. You have a setof rectangles, and we want to know which of these rectangles intersect? Or how manyrectangles intersections are there? These are interesting problems that have lotsand lots of applications, from computerated design, to games and moviesand also in abstractions such as data bases and other situations where you mighthave multiple keys or multiple dimensions.<br>
satisfied|sentence cnt : 5 <br> <br>1. So the heap order condition is satisfied everywhere except at this node.<br><br>2. Then the heap order condition is satisfied at that node because the parent was smaller, so that one's smaller.<br><br>3. So, what we do is try to figure out why, find a way to addresswhatever's causing that problem, find a new algorithm and iterate until we'resatisfied.<br><br>4.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br><br>5. So, first thing it goes up the exchange with the S, it's still bigger than P so we exchange it with the P and now we're done because S is not bigger than T and the heap order condition is now satisfied everywhere in the heap.<br>
spread|sentence cnt : 1 <br> <br>1. But then the time, though,gets divided by M squared, your number of points, M, are spread outover the M squared different squares.<br>
basics|sentence cnt : 3 <br> <br>1. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>2. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br><br>3.So you can imagine the implementations of priority queues using these two basicstrategies.<br>
ported|sentence cnt : 1 <br> <br>1. That returns true if the ported is sortedand false if it's not.<br>
nearby|sentence cnt : 3 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2. Where's the closest thing? How am I going to findthe closest thing efficiently? What things are nearby and so forth.<br><br>3. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br>
variables|sentence cnt : 10 <br> <br>1. And then we set its instance variables.<br><br>2. Say, for this fictionalclass Student, that's got two instance variables - name and section.<br><br>3. So how about implementing a hash code forour own type of data? And so our transaction type might have a couple of instance variables,a string, a date, and a double.<br><br>4. Inthis implementation, the Date class has three instance variables.<br><br>5. So that's a simple example ofimplementing a hash code for our own type of data that might include severaldifferent types of instance variables.<br><br>6. For convenience, we'll provide a constructor that takes the key and valueas argument and fills in the key and value instance variables then the left and rightlinks are initialized to null.<br><br>7. So, we have a data type called ball that represents justone of the particles and has instance variables that has the position and thevelocity.<br><br>8. We have this inner class that we use tobuild the items in the linked-list and we make it an inner class so we can directlyrefer to those instance variables.<br>
worst|sentence cnt : 31 <br> <br>1.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>2.So complexity's going to tell us that it's a quadratic algorithm if that's what itsworst case is.<br><br>3. In this case, it's easy to see that every operationtakes constant time in the worst case.<br><br>4. For example we can say that the number of comparison and theworst case is O(N3/2) for the 3x + 1 increments.<br><br>5. This isthe average path in a tree, this is the, the worst of all the keys.<br><br>6. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>7. So for linked lists, every operationtakes constant time in the worst case, that's a guarantee.<br><br>8. Now,the height of the tree, as I just mentioned, is the worst case number ofcompares.<br>
terminating|sentence cnt : 1 <br> <br>1.Now you have to be a little bit careful with terminating the loop.<br>
basically|sentence cnt : 8 <br> <br>1. It's basically that distancedivided by the by the velocity.<br><br>2. Try to understand, basically, what are the mainelements of the problem that need to be solved.<br><br>3. And what we're going to look atas one of the most widely used, which is basically to usea tree to represent a recursive subdivision of the plain,of two-dimensional space.<br><br>4. It seems like it should beeasy to implement equals, basically we're just going to check thatall the significant fields are the same.<br><br>5. And basically, these ruleshad to do with doing this ortho, orthogonal rectangle intersection search.<br><br>6. Unfortunately thatsituation at the beginning of Java where we stuck with that and there are plenty ofprogramming languages where basically we're stuck with that so what we want tolook at is a modern approach to avoiding having multiple implementations for eachtype of data.<br><br>7. And basically, the computation is based on computing the interacting force foreach pair of particles.<br><br>8. And basically what thisthing has to do is implement these methods hasNext() and next().<br>
eventually|sentence cnt : 13 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>3. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>4. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>5. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br><br>6. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>7. So, as you can see in this examplewe start out by merging the first two sub arrays of size one to make a array of sizetwo - E, M - that's sorted, and then do the same thing for the next two elements and thenext two and so forth until eventually instead of sixteen individual elements wehave eight sorted subarrays of size two.<br><br>8. Andeventually if the key is in the tree, we're going to hit it.<br>
debates|sentence cnt : 1 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br>
keys|sentence cnt : 238 <br> <br>1. So we have to be sure we've gotthe method that we want for checking whether two keys are equal.<br><br>2. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>3.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>4. And the right link points to all, 2-3 treecontaining all the keys that are larger than the larger of the two keys in the3-node.<br><br>5. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>6. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>7. And the other thing I have referred to butnot talked about in detail is the presence of equal keys.<br><br>8. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br>
trillions|sentence cnt : 3 <br> <br>1. Maintain a dynamic search symbol tablewith trillions of keys, so that you can get to any key just by looking five or sixplaces but that's what B-trees provide for us.<br><br>2. There's trillions of them therecoming through as fast as possible.<br><br>3. Even if it's trillionsof, of pieces of data in this huge, huge file.<br>
insistence|sentence cnt : 1 <br> <br>1. So our insistence in this course is thatstudents should not use the library until we've implemented it in class.<br>
statements|sentence cnt : 4 <br> <br>1. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>2. Not an easyanalysis, but we actually could make precise accurate statements about theperformance of this algorithm.<br><br>3. Like these are all the ones associatedwith this, lecture, so we might build an indexfrom that set of files, and then we might wonder well where do we use the importstatements.<br><br>4. And that's every programmer'sfirst introduction to assignment statements.<br>
improvement|sentence cnt : 10 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>3.So, that's a first improvement.<br><br>4. A very effective improvement, it's calledweighting.<br><br>5. The second improvement that we can makethat'll improve the performance for cases when the array is partly sorted,is to just stop if it's already sorted.<br><br>6. Quick Find and Quick Union, and some applications and improvements ofthose algorithms.<br><br>7. In, in that case, thenthe expected length of the longest chain will be lg, lg N which is quite animprovement.<br><br>8. A second improvement is to, try toestimate the partitioning element to be near the middle.<br>
functionality|sentence cnt : 4 <br> <br>1. But we can also provide a lot of convenient functionalityfor the client that's what we are going to look at next.<br><br>2. So, a very smallamount of code based on a symbol table implementation that gives us thedictionary functionality.<br><br>3. So, all kinds of information processing that we might needto do for large amounts of data, represented in comma, comma separatedvalue files this one client which is based on a symbol table will provide usefulfunctionality.<br><br>4. Again, quite useful and familiarfunctionality and very easy to implement with our simul tableclient.<br>
associative|sentence cnt : 6 <br> <br>1. And also the associative arrayabstraction is the put() method will overwrite an oldvalue with a new value.<br><br>2. So those are the basic operationsthat we're going to want to implement to get the associative arrayabstraction and then there's many, many possibilities for clients andwe'll look at some later on.<br><br>3. So the way that it's convenient to set up a symbol table is to implement theso-called Associative array abstraction.<br><br>4. That's the associative array abstraction.<br><br>5. We're going to stick to thisassociative array abstraction and no duplicate keys in the symbol table, because it both simplifies implementationsand leads to simpler client code.<br><br>6. And notice it's an associativearray implementation, so for example, we have two Es.<br>
bound|sentence cnt : 30 <br> <br>1.Also staying in bounds.<br><br>2. That's a lower bound on the complexity of sorting.<br><br>3. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>4. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>5. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>6. So, here's the basic idea for proving a lower bound forsorting.<br><br>7. One is an, what'scalled an upper bound which is a cost guarantee that's provided by somealgorithm for solving the problem.<br><br>8. So and this is just some test datawhere we've got all, all these transactions and so we are going to beable to take in data like this and again an unbounded stream of data.<br>
randomized|sentence cnt : 3 <br> <br>1. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br><br>2.You have to be a little bit careful of that and even if everything is randomizedif there's lots of duplicates and the implementation is not done quite right thequick sort might take quadratic time.<br><br>3. So if we, we aretalking abouta randomized model where the sites are vacant with the givenprobability.<br>
virtual|sentence cnt : 2 <br> <br>1. And then, when we want to know whetherthis system percolates, we just check whether the virtual top site is connectedto the virtual bottom site.<br><br>2. Instead, what we do is create avirtual site on the top and on the bottom.<br>
their|sentence cnt : 34 <br> <br>1. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>2. They're in their own connected component.<br><br>3.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>4. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>5. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>6. So, that's why we make a bunch of them and then we have a, a while loopwhich is just every 50 milliseconds clear the, the whole drawing and then move theballs a little bit and then draw them in their current position.<br><br>7. So, that's one importantreason to study algorithms, their impact is broad and far-reaching.<br><br>8. And it's a requirement that if x and y are equal then theirhash code should be equal.<br>
fashion|sentence cnt : 1 <br> <br>1. To maintain the sorted array in dynamic fashion is going to takelinear time you have to go through the whole thing.<br>
take|sentence cnt : 243 <br> <br>1. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>2. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>3. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>4. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>5. We can discover mistakes in typed mismatches at compile-time instead of atrun-time.<br><br>6. Now instead of the initialization always takes timeproportional to N.<br><br>7.It takes it, boolean condition.<br><br>8. Forexample, if you have a billion operations and a billion objects I said before itmight take thirty years.<br>
outline|sentence cnt : 1 <br> <br>1. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br>
fairly|sentence cnt : 6 <br> <br>1. And usually that's fairly straightforward.<br><br>2. Actuallyfairly easy to understand why it works.<br><br>3. Like stability, that'sa fairly sophisticated attribute that you really have to think about, you maybe notbe aware of.<br><br>4. So again, that's, fairly little code, to implement, a fastsymbol table and insert, search and insert.<br><br>5.This looks like a fairly daunting equation, but actually it's not toodifficult to solve.<br><br>6. Well, each one of these operations are fairly straightforward but just to check our ability to manipulate this data structure, we'll takea look at each.<br>
theory|sentence cnt : 12 <br> <br>1. Now, here's an example where we want to use theory as a guide.<br><br>2. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>3. And that's pretty close to the best thatwe could do in theory and is very important and useful, practicalimplementation and data structure.<br><br>4. But still again, using theory as a guide maybe there's a way to decrease costs a little bit from binary heaps.<br><br>5. So, there's a lot of theory that goes behind thealgorithms that we use.<br><br>6. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>7. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br><br>8. This is another example where we use theory as a guide.<br>
plenty|sentence cnt : 18 <br> <br>1. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>2. And so, there are plenty ofapplications where we want to just be able to implement, this really simple API.<br><br>3. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>4. And there's plenty of natural total ordersin the types of data that we normally want to consider for sort keys.<br><br>5.There's plenty of time by the memory model.<br><br>6. And there's plenty of other applications where people want to be ableto compute the convex hull.<br><br>7. All of these operations are very useful forclients and we'll see plenty of examples later on.<br><br>8. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br>
rubber|sentence cnt : 1 <br> <br>1. Well, there'sactually a way to compute the convex hull just mechanically if you put the nailsaround the points and put a rubber band around it, that gives you the convex hull.<br>
grows|sentence cnt : 4 <br> <br>1.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>2.And then the height of the tree grows by one.<br><br>3. If Ngrows from a million to a billion, that cost goes from twenty to 30, which isquite not acceptable.<br><br>4. So the tree grows from the bottomin the little side to side motion it's just accommodating room for each new keyas it's added.<br>
characters|sentence cnt : 2 <br> <br>1. The operandstack the operator stack is string, it could be characters which is just ouroperator.<br><br>2. And again it involves allthe characters of the string in computing the hash function.<br>
resize|sentence cnt : 6 <br> <br>1. If we have a full stack,which we know by testing N, which is the number of items inthe stack versus the array length, then we just resize the array into one of twicethe length before inserting the item.<br><br>2. So what we want to choose is this squaresize that would best balance these two needs.<br><br>3. We can just test if the arrayis one quarter full, if it is, we resize it to half full.<br><br>4. And how do we resize to a new capacity? We create a new array of that capacity andjust go ahead and copy our current stack into the firsthalf of that and then return it.<br><br>5. And number two, that every time youresize, you've already paid for it in an amortized sense by inserting,pushing or popping.<br><br>6. And if, in theclassic algorithm or computer science problems for people to think about is whatdo we do to delete in these two situations and exactly how do we resize.<br>
buying|sentence cnt : 1 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br>
statistics|sentence cnt : 3 <br> <br>1. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>2. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>3. I wanted to findthe top k or the medium or other order statistics so that's what selection is allabout.<br>
character|sentence cnt : 18 <br> <br>1. At leastthat some indication that you understand the performance characteristics.<br><br>2. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>3. Otherwise, if it's a string that'snot equal to the hyphen character, it'll just push it onto the stack.<br><br>4. The operandstack the operator stack is string, it could be characters which is just ouroperator.<br><br>5.Now we'll look at insertion sort, which is another elementary methodthat interestingly has quite different performancecharacteristics than selection sort.<br><br>6. So that seems as if it should work but that doesn't have all the characteristicswe need in the Java implementation.<br><br>7. If the string is equalto the hyphen character, it'll pop the string at the topof the stack and print it.<br><br>8. And again it involves allthe characters of the string in computing the hash function.<br>
minor|sentence cnt : 1 <br> <br>1. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br>
subtree|sentence cnt : 46 <br> <br>1.So we move to the left and compare H against the root of the left subtree.<br><br>2. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>3. The floor of K is in the right subtree, ifthere is any key smaller than K in the right subtree.<br><br>4. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>5. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>6. And every node's got fourfields, a key and a value, and references to the left subtree, that contains thesmaller keys, and the right subtree that contains the larger keys.<br><br>7. Supposed to search the right subtreeat 1 next, but we can prune that.<br><br>8. Now we canpair H against the root of the right subtree of E, and that's R and it's lessso we have to go left cuz everybody to the right of R is bigger and H is smaller.<br>
seemed|sentence cnt : 1 <br> <br>1. The designers found that the cost of computing the hashfunction for strings seemed to be excessive, particularly for long strings.<br>
template|sentence cnt : 2 <br> <br>1. The Javaimplementation of tree map and tree set is red black trees, C++, the standardtemplate library uses, red black trees.<br><br>2. So anyway,that code down at the bottom is you can use that as a template forwhat you might want to do.<br>
except|sentence cnt : 38 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. So the heap order condition is satisfied everywhere except at this node.<br><br>3. So that now, we have our set ofexceptional words.<br><br>4. And what assert will do is it will throwan exception unless that condition is true.<br><br>5. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br><br>6. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>7. Except that it compute a skip that wouldmean that, that only look at about every eight key and they wouldn't have to doquite so much work performing the hash function.<br><br>8. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br>
first|sentence cnt : 221 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. You can see it's got the first half sorted, now it's working on the secondhalf.<br><br>3. That's first = new Node.<br><br>4. Make sure that both first andlast are always what we want them to be.<br><br>5. So first we exchange it with the 10,it's still not in place, so we exchange it with the 7.<br><br>6. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>7. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>8. The first part is data typesorting and searching.<br>
seeking|sentence cnt : 2 <br> <br>1. You can figure out from the last index when you don't find yourelement that you're seeking.<br><br>2. So, what we want to find is so say, we're seeking the floorof G.<br>
grand|sentence cnt : 2 <br> <br>1. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br><br>2.Actually to make a one liner code, we use a, a simple variant where we make everyother node in the path point to its grandparent on the way up the tree.<br>
operands|sentence cnt : 2 <br> <br>1. The operandstack the operator stack is string, it could be characters which is just ouroperator.<br><br>2. We have operands andoperators and you want to evaluate it.<br>
framing|sentence cnt : 1 <br> <br>1. Nowin framing of the difficulty of problems were only two things.<br>
adjusting|sentence cnt : 2 <br> <br>1.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>2. And then adjusting the heap ordering with the sync operation.<br>
works|sentence cnt : 48 <br> <br>1.If you look at this visual trace you can see how it works.<br><br>2. And we'll continue to do a few more so you'llget an idea of how it works.<br><br>3. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>4. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>5. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>6. And it's definitelyan instructive exercise to check that you believe that, that method works.<br><br>7. That's a fine implementation for deleteMin and it also works for deleteMax.<br><br>8. Actuallyfairly easy to understand why it works.<br>
optimal|sentence cnt : 10 <br> <br>1. It's optimal with respect to both space and time.<br><br>2. On the other hand, maybe there is an algorithm that uses N log N comparesand also uses optimal space.<br><br>3. Sothat's entropy-optimal and what that means is whatever the distribution of equal keysin there, this thing is going to use a number of compares that's proportional tothe best that you could possibly do.<br><br>4. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>5. And the quicksummary is that every one of those operations, while ordered iteration isoptimal, it just gets them in linear time.<br><br>6. Optimal representation of the data and only a little arithmetic with array indices.<br><br>7. There's a trivial lower bound which says you have tolook at all the data, that's N and we'll look at a better lower bound and see thatmergesort is optimal.<br><br>8. Really what we proved is that mergesort is optimal withrespect to number of compares but we already know that it's not optimal withrespect to space usage.<br>
flowing|sentence cnt : 1 <br> <br>1. Or, you could think of it as, as water flowing through a poroussubstance of some kind.<br>
poetry|sentence cnt : 1 <br> <br>1.Another quote from Francis Sullivan, says, "The great algorithms are the poetry ofcomputation.<br>
checking|sentence cnt : 12 <br> <br>1. So we have to be sure we've gotthe method that we want for checking whether two keys are equal.<br><br>2. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>3. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>4. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>5.Now, once we can calculate these roots, then we can implement the find operationjust by checking whether the two items that we're supposed to check with areconnective where they have the same root.<br><br>6. Is empty, it is just checking whether YN is equal to zero.<br><br>7. You shouldn't use them for the things likechecking if the input is the way you like it.<br><br>8. And typically, indesign rule checking, you wouldn't expect too many intersections.<br>
traversing|sentence cnt : 1 <br> <br>1. And then, [COUGH] to computethe total force traversing the tree of all the information that you need,to complete the N-body calculation.<br>
subarray|sentence cnt : 19 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>4. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>5. Now in this case the second subarray to be sorted is smallerbut the merge routine doesn't really care about that so much.<br><br>6. And we have four subarrays ofsize four.<br><br>7. And eventually we get down to smallsubfiles, actually our code doesn't do anything at all for subarrays of size one,so we just leave those in gray, and then it does the right subfile, and so forth.<br><br>8. This animation does the whole h-sort for each subarray.<br>
steps|sentence cnt : 6 <br> <br>1. What about insertion? Well, to insert a new key, allwe do is follow the same steps as we did for search.<br><br>2. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br><br>3. And now to do the high ones pretty quicklyand now it's doing the 1-sort and again it steps through the array pretty quickly.<br><br>4. The idea is to when implementing the quick union algorithmtake steps to avoid having tall trees.<br><br>5. So that's the end of the twosteps in Heapsort.<br><br>6. The subtext of today's lecture really is to go through the stepsthat we'll follow over and over again to develop a useful algorithm.<br>
factor|sentence cnt : 16 <br> <br>1. So, this three has to have at least N factorial leaves and ifthe three of height h, it has utmost two^h leaves.<br><br>2. Idon't want to spend a lot of time with this cuz I think this is a unsatisfactorysolution.<br><br>3. And by Stirling'sapproximation, we know that log base two(N) factorial is proportional to N logbased 2N.<br><br>4. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>5. That really seems unsatisfactory.<br><br>6. So, it means that we've divided the search cost which would be Nif we have a sequential search by a factor of M.<br><br>7. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br><br>8. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br>
examining|sentence cnt : 2 <br> <br>1. And the way to prove this proposition isto from examining the code, to write down what'scalled a recurrence relation.<br><br>2.So this is a mathematical formula that we derive by examining the code but itcompletely describes mathematically what we an upper bound on the number ofcompares that are going to be needed.<br>
recursive|sentence cnt : 54 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>4. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>5. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>6. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>7. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>8. Alright, so with that mergeimplementation, then the sort implementation is a quite simple,recursive procedure shown here.<br>
designing|sentence cnt : 3 <br> <br>1. But the key point about it is that designing acomputer became a geometric problem.<br><br>2. That's an extremely importantprinciple in designing good algorithms.<br><br>3. This is the scientific approach to designing and analyzing algorithms,where we build mathematical models to try and understand what's going on, and thenwe do experiments to validate those models and help us improve things.<br>
stretched|sentence cnt : 1 <br> <br>1. In this case, the 4 subfiles stretched out at seven each onlyhave two elements in them.<br>
graphical|sentence cnt : 3 <br> <br>1.It's kind of a graphical proof or a proof by picture that thatrecurrence has that solution.<br><br>2. So this is just a graphical representationif we want to compute D of N we want to computeD of N over 2 twice.<br><br>3. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
depending|sentence cnt : 10 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>3. And what about Mergesort? Mergesort is stable well,it's stable as long as the merge operation is stable and that operation is going tobe stable depending on how we code it.<br><br>4. The amount used is between 8N and 32N, depending on how full the array is and just a quick analysis of the amountof space that arrays take in Java.<br><br>5. And, depending on the valueof the parameter, M, you have a space time trade-off.<br><br>6. And depending on the frequency of execution of the uncertain delMax operations, that might work out better.<br><br>7. And actually there's differentassumptions that we'd make in our implementations dependingon the application.<br><br>8.It'll compare this object against the object given as argument and depending onsome complicated tests, it'll return -1, meaning less, +1, meaning greater or0, meaning equal.<br>
scissors|sentence cnt : 1 <br> <br>1. So, rock, paper, scissors is intransitive.<br>
prediction|sentence cnt : 8 <br> <br>1. There's do this prediction for every one of the particles.<br><br>2. And so we have twophases, we have prediction and resolution.<br><br>3. And then here's the skeleton of what's going to happen withthe collision system which is the key thing is this prediction method that takesa particle as argument, and adds to the priority queue, all the possiblecollisions involving this particle.<br><br>4. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>5. So, we have to do collision prediction, which is givenposition, velocity, and radius when's it going to hit with another particle or, orthe wall.<br><br>6. And then we'll go ahead and do thepredictions of each of those particles, A and B, against all other particles.<br><br>7. So that's just an example of collision, ofcollision prediction, when's it going to hit the wall and resolution what do you dowhen it gets to the wall.<br><br>8. And so that's the prediction.<br>
powerful|sentence cnt : 1 <br> <br>1. There's ways toimplement that don't involve this, but its, the code is so simple and it extendsto more powerful data structures later on that we'll introduce this right now and,and you'll see how it works.<br>
when|sentence cnt : 228 <br> <br>1. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>2. And thisis a big difference between the binary search implementation where the keys arekept in order in an array, in the sequential search implementation, whenthey're all in a link list.<br><br>3. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>4. So this is when the itemscome in in reverse order.<br><br>5. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>6. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>7. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>8. When does all the bins fill up? That's called the couponcollector problem.<br>
nefarious|sentence cnt : 1 <br> <br>1. There is this test fornull that has to be there and if it's not there it can lead tonefarious bugs and unusual problems.<br>
recursion|sentence cnt : 8 <br> <br>1. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>2.This bottom-up version that has no recursion, it's also quite simple tounderstand and to code up.<br><br>3. The bottom line in this is sequence of passes through thewhole array and there's no recursion needed at all.<br><br>4. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>5. The depth of recursion.<br><br>6. The stack containsthe recursion.<br><br>7. They have some exposure toobject oriented programming and recursion.<br><br>8.So what is the Quicksort method? It's also a recursive method, but thebasic idea behind Quicksort is that it does the recursion after it does the work,whereas Mergesort did it before it did the work.<br>
condtion|sentence cnt : 1 <br> <br>1.We might have violated the heap order condtion at the heap right now.<br>
conducts|sentence cnt : 1 <br> <br>1. And so if there's a conductor from top to bottom then the thing conductselectricity.<br>
average|sentence cnt : 31 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>3. And if everything's random, then on average you only have to lookhalfway through for a successful search.<br><br>4. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>5. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>6. The average case, which is extremelylikely for any practical application, is going to be about 1.<br><br>7. This isthe average path in a tree, this is the, the worst of all the keys.<br><br>8. And you can see that for a large arraythat's randomly ordered, the element that we put into place is going to goabout halfway back on the average.<br>
physical|sentence cnt : 9 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. Remember in the first computers, each bit was a physicalthing, a magnetic core that somebody had to string a wire through, so.<br><br>3. There's algorithms in physics for understanding physical phenomenon thatwe'll look at an example and many others on this list.<br><br>4. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>5. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>6. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>7. The Physics problem is exactly what happenswhen two balls hit and they bounce off each other according to somewell-understood physical process, and that's the high school Physics.<br><br>8. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br>
insidious|sentence cnt : 3 <br> <br>1. That's aninsidious bug.<br><br>2.We think that one is bad news, we don't use it can lead to insidious debug, bugdebugging problems.<br><br>3. Theproblem with this is that the client code has to do this, this casting and it's kindof an insidious bug if it doesn't quite get it.<br>
zero|sentence cnt : 75 <br> <br>1.compareTo(w) less than zero.<br><br>2. That way, we leave a of zero empty.<br><br>3. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>4. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>5. All those zeros have to getchanged to ones.<br><br>6.So in a typical thing, say, maybe the matrix dimension would be 10,000, andmaybe there would only be ten non-zero entries per row.<br><br>7. So, [cough] in this case, for example, forselection sort, when we do that first exchange oops, [cough] where we found theminimum A and B is in position zero.<br><br>8. And so, symbol tables provide us with a way to provide a moreefficient implementation of, of this process when we have lots of zero entries.<br>
confounded|sentence cnt : 1 <br> <br>1. But finding the best incrementsequence is a research problem that has confounded people for quite a long time.<br>
refers|sentence cnt : 2 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2. Take one of our symbol table implementationsand get rid of the code that refers to values.<br>
notice|sentence cnt : 7 <br> <br>1. Notice already that will meanwhen we get back to 0.<br><br>2. Notice again that it depends on the randomshuffle at the beginning that's going to be important for performance.<br><br>3. Notice that we didn't increment ibecause that element z that is over in the right, really hasn't been compared to thepartitioning element yet.<br><br>4. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br><br>5. And notice since it's just going from bottom to top in the heap, it takes at most 1 plus log base 2 of N compares.<br><br>6. So, notice, we're in this case we do this rotationfirst, we're on this node and then , that returns and we come up to deal with thesituation on this node after the return, and then we do that rotation.<br><br>7. And notice it's an associativearray implementation, so for example, we have two Es.<br>
initialize|sentence cnt : 6 <br> <br>1. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>2. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>3. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>4. For convenience, we'll provide a constructor that takes the key and valueas argument and fills in the key and value instance variables then the left and rightlinks are initialized to null.<br><br>5. And then there is a constructorand maybe we have a constructor that takes arguments that would initialize theposition and the velocity or maybe initialize them to a random position ifthere's no arguments.<br><br>6. It takes this linear time toinitialize the data structure.<br>
earlier|sentence cnt : 3 <br> <br>1. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>2. We have the swim and sink functions that we showed earlier.<br><br>3. And we looked at the binary searchalgorithm earlier in the course.<br>
positive|sentence cnt : 4 <br> <br>1. In our hash function is pull out the system hash code, make it positive byending off the sign bit and then mark with M to get a number of, zero and -one.<br><br>2. And also by convention, itreturns a negative integer for its less zero if it's equal positive its greater.<br><br>3. Get the hash code out, make itpositive and MOD M is the way to go.<br><br>4. And then hasNext() is okay as long as that thing is positive.<br>
rightmost|sentence cnt : 2 <br> <br>1. So at the root, the maximum endpoint orthe rightmost point covered by an interval, is 24.<br><br>2. J points to the, rightmost element in theleft subfiles, everything that's not greater than K.<br>
removes|sentence cnt : 1 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br>
intransitive|sentence cnt : 1 <br> <br>1. So, rock, paper, scissors is intransitive.<br>
slowed|sentence cnt : 1 <br> <br>1. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br>
indicative|sentence cnt : 1 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br>
operating|sentence cnt : 3 <br> <br>1. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>2. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br><br>3. Operator, put on theoperating stack.<br>
region|sentence cnt : 1 <br> <br>1. Again, it's not too good to use the firstthree digits because they're associated with some geographic region andit's better to use the last three digits.<br>
casting|sentence cnt : 5 <br> <br>1. And that way the client code doesn't docasting.<br><br>2. Okay then,it's one of the detail that Java takes care of and that's what about primitivetypes [cough] so the generic type that we're using is for objects and you know,we're casting down from array of objects.<br><br>3. Theproblem with this is that the client code has to do this, this casting and it's kindof an insidious bug if it doesn't quite get it.<br><br>4. So the a quick hack that is widely used is to use casting to implementto reuse the code for different data types.<br><br>5. Make sure they're the sametype can do the casting, and then compare all the similar andsignificant fields.<br>
salaries|sentence cnt : 1 <br> <br>1. Youwant to return how many taxpayers have salaries between one million and tenmillion and then which ones are they and so forth.<br>
gravitational|sentence cnt : 1 <br> <br>1. And so, then there'll bemutual gravitational pull and this is what happens with a large numberof particles in a certain simulation.<br>
loitering|sentence cnt : 2 <br> <br>1. But we do have to worry in Javaabout a problem called Loitering and that is the idea that we havereferences to an object in our array implementation in the stackarray when we're not really using it.<br><br>2. Now, in this case, to implement delete max we save away that value at the root in max, and we eliminate loitering by nulling out that vacated position, then return the max value.<br>
video|sentence cnt : 1 <br> <br>1. They're used for movies andvideo games, for particle collision simulation, they're used to study thegenome, and all manner of other applications.<br>
going|sentence cnt : 560 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>4. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>5. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>6.That's going to be a constant extra cost.<br><br>7. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>8. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br>
wipes|sentence cnt : 1 <br> <br>1. And that pretty much wipes out clustering but it, it is moredifficult to implement delete for that one.<br>
diagram|sentence cnt : 10 <br> <br>1. Probability that a site is vacantis low as on the left, two examples on the left in this diagram, it's not going topercolate.<br><br>2.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>3. The x's depth will increase by one, when its tree, T1 inthis diagram, is merged into some other tree, T2 in this diagram.<br><br>4. Sothat's the first piece of code for heap ordering an array with arbitrary valuesand then these diagrams summarize the sync calls that, that we just went through inthe demo starting at five, four, three, two, one.<br><br>5.And these diagrams summarize the sync operations that we showed in the demo.<br><br>6. So as I've mentioned and this diagramshows, the splitting of 4-node and a 2-3 tree is a local transformation.<br><br>7. That's white in the diagram with probablyP or blocked, that's black of the diagram with probability one - P and we define asystem to, we say that a system is percolated if the top and the bottom areconnected by open sites.<br><br>8. In this diagram, the entries in black, are theones that are examined in order to find the minimum each time with the minimum inred.<br>
array|sentence cnt : 375 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. And the reason is that you only createa new array every time it doubles.<br><br>4. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>5. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>6. So to insert N items,it's about three array accesses.<br><br>7.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>8. The thing is remember represented in array one two three and so forth.<br>
flips|sentence cnt : 1 <br> <br>1. And what we want todo is split that four node and in this case, since we are at the root that's allso that just flips the colors.<br>
implies|sentence cnt : 1 <br> <br>1. And the number of leaves has to be greater orequal to N factorial so that implies the height of the tree has to be greater thanor equal to log base two(N) factorial which is proportional to N log N byStirling's formula.<br>
probabilistic|sentence cnt : 4 <br> <br>1.39 log N and that's probabilistic ifthey are in random order, its extremely likely to be there.<br><br>2. Its a probabilistic guaranteed fast algorithm.<br><br>3.And what about the analysis? Well, again this the [cough] standard probabilisticanalysis of the balls and bins problem tells us a lot of information of what goeson.<br><br>4. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br>
weighting|sentence cnt : 2 <br> <br>1. A very effective improvement, it's calledweighting.<br><br>2. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br>
hack|sentence cnt : 3 <br> <br>1. That's a bit of a hack, but it cuts down on a lot ofcode.<br><br>2. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br><br>3. So the a quick hack that is widely used is to use casting to implementto reuse the code for different data types.<br>
chosen|sentence cnt : 3 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2.And again, when there's a lot of equal keys then there's going to be place whereone of those is chosen, it's partitioning element then a big chunk of the array getshandled just in a partitioning process.<br><br>3. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br>
violation|sentence cnt : 3 <br> <br>1. That's the swim operation to eliminate violation when a key value increases.<br><br>2. Again just a few lines of code to eliminate the violation when a key value in a heap decreases.<br><br>3. So how do we fix that violation? Well, that one's also easy.<br>
hardware|sentence cnt : 2 <br> <br>1. It's often used in embedded systems or in hardware sort type systems becausethere's so little code involved to implement it.<br><br>2. So, if your business does depend on shuffling, people have looked at all sorts of options, including using hardware random number generators, and there's various tests available to make sure that it's random.<br>
exchanged|sentence cnt : 2 <br> <br>1. Then once we've exchangedit, again, we preserved our invariant.<br><br>2. The southern is still smaller, so T after it's exchanged up here will be bigger than both its children.<br>
catapulted|sentence cnt : 1 <br> <br>1. We did a long distance exchange and thatcatapulted that first item past any item that it might be equal putting them out oforder.<br>
showing|sentence cnt : 9 <br> <br>1. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>2. So, for this example at right we have insert a numberof keys and, and we're just showing them in sorted order.<br><br>3. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>4. It moves keys pastother keys that could be equal and so its easy to construct examples showing thatSelection Sort is not stable.<br><br>5. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br><br>6. So here we just as, as it goes up we'reshowing each key getting inserted in the number of probes of the table that areneeded for the insertions are J hash to the same position that A; you had to lookfor a while, and the one thing to notice is as the table gets full, is that firstof all.<br><br>7. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br><br>8. And then this isanother famous physics experiment showing diffusion.<br>
deeper|sentence cnt : 1 <br> <br>1. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br>
introduces|sentence cnt : 1 <br> <br>1.That's the only time the height of a 2-3 tree changes, when the roots splits theheight introduces increases by one.<br>
programing|sentence cnt : 1 <br> <br>1. Andthis is an elementary programing exercise that is the, the code at the left has theeffects shown at the right.<br>
lookups|sentence cnt : 1 <br> <br>1. So, with one client we can handle lookups of all kinds in CSV files.<br>
sees|sentence cnt : 2 <br> <br>1. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>2. So we've drawn the data structure with the links so we have an intuition for what's going on, but all the program sees is the array in gray at the bottom where T is in position one, P and R in position two and three and so forth.<br>
refined|sentence cnt : 1 <br> <br>1. And then we test those models throughexperimentation enabling us to improve algorithms iterating, developing betteralgorithms and more refined models until we get what we need to solve the practicalproblems that we have of interest.<br>
satisfies|sentence cnt : 1 <br> <br>1. Now, K is inserted into the 2-3 tree andit satisfies all the rules.<br>
shuffled|sentence cnt : 8 <br> <br>1. But if we shuffled randomly, it'sextremely unlikely to happen.<br><br>2. So, that's definitely a way to get a deck shuffled quite easily, easy to implement.<br><br>3. Since we shuffled the array, that's ourrandom element from the array.<br><br>4. And that just means that it's well shuffled, that every possible way of shuffling the deck appears with equal probability.<br><br>5. The point is that the cards to the left of i are uniform randomly shuffled.<br><br>6. So, our first one is, the way that random works, it actually never gets to 52, which means that the last card can end up in the last place, so it's definitely not shuffled because of that.<br><br>7. And at the end, we have the deck shuffled.<br><br>8. That's an effective way to get things shuffled.<br>
comparators|sentence cnt : 11 <br> <br>1. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>2. And this code is straight forward way to implement comparators that you canuse as a model.<br><br>3. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>4.Or, did we use comparators anywhere here? In, this Index will tell us no.<br><br>5. With comparators, we can do that outside of thedata type even at some later time.<br><br>6. And really it doesn't makesense if you don't know about comparators which we just introduced.<br><br>7. So in oursort implementations we can change them as shown in this example to supportcomparators.<br><br>8. I won't go through it all in detail just to point out that thisimplements two different comparators as nested classes.<br>
knauf|sentence cnt : 1 <br> <br>1. Now this was studied in detail by Knauf, DonKnauf, in the 1960's and actually this problem, Knauf says, was the origin of theorigin of analysis of algorithms.<br>
cluster|sentence cnt : 12 <br> <br>1. So the clustering in the data is going tomake the implementation inefficient.<br><br>2. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>3.That's it's even going to merge with another big cluster.<br><br>4. You get long clusters and they're likely to getlonger.<br><br>5. And that pretty much wipes out clustering but it, it is moredifficult to implement delete for that one.<br><br>6. And his idea was that if some particle isway away from some cluster of particles, we can treat that cluster asa single aggregate particle.<br><br>7.Group of four key, continuous keys in a table space there is called a cluster andclearly we want to keep those clusters small.<br><br>8.>> And not only that once you have a big cluster and you hash into the middle of ityou've got a good chance that, that clusters going to get longer, or worse.<br>
slight|sentence cnt : 5 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. Slightly reduces the number of compares.<br><br>3. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>4. So implementing this is a simple example of linked list processing, a slightmodification of our stack and queue code.<br><br>5.Okay next we're gonna look at anotherextension of geometric algorithms to process slightly more complicated objectsand then we'll see an important application.<br>
discussion|sentence cnt : 1 <br> <br>1. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br>
machines|sentence cnt : 2 <br> <br>1. And there weremachines that would take drawings and, and return, [cough] and from those drawings,like this, make, physical things that implemented computers with differentlayers and different, physical materials interacting, in different ways.<br><br>2. The other thingthat is probably more significant on modern machines is.<br>
sometime|sentence cnt : 16 <br> <br>1. Sometimes during theinsertion, we might wind up with a node that's got two red links coming out of it.<br><br>2. We're goingto be able to sort the same things in different way sometimes and this exampleis a fine motivation of that.<br><br>3. Whereas on the other hand, sometimes the whole purpose of a data type is to maintain a changing value.<br><br>4. So this well illustrates that youneed to use all of the data in the hash function and sometime we do a closeranalysis.<br><br>5. Well, it'sleft leaning and the process is a little bit different and sometimes the left pathcan get long but not that long.<br><br>6. Now paradoxically and you'll see why very soon it also turns out thatto get the insertion done properly we sometimes need to take a left-leaning redlink and temporarily make it lean right.<br><br>7. The value of M is maybe a power of two orsometimes we'd pick a prime because of the waythat we normally would get the big hash code value down to bea number between zero and M minus one.<br><br>8. And the idea isthat during the construction of a tree, or during an insertion operation, sometimeswe wind up with red links that are leaning in the wrong direction.<br>
drawn|sentence cnt : 3 <br> <br>1. It's an easy way to get things drawn.<br><br>2. So we've drawn the data structure with the links so we have an intuition for what's going on, but all the program sees is the array in gray at the bottom where T is in position one, P and R in position two and three and so forth.<br><br>3. And those six subtrees drawn could behuge.<br>
shows|sentence cnt : 18 <br> <br>1. S o this shows the process ofbuilding a large B-tree.<br><br>2. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>3. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>4.And so, for example, what this table shows, if you were to tryto use a insertion sort for a huge file, say a file with a billion elements,on your PC it'd take a few centuries tofinish.<br><br>5.Shows the state of the array before partitioning.<br><br>6. This is a bigger trace that shows, again, about half the elements belowthe diagonal are involved in the sort.<br><br>7.So, in this example, it shows the general situation, when the 4-node to be split isthe middle length, But the same is true if it's a left orright.<br><br>8. The cartoon on the right showsthat not all orders are necessarily total orders.<br>
debate|sentence cnt : 3 <br> <br>1. So there's various technical reasons for that and you canread, read extensive debates about this on the web that's going to go beyond ourscope.<br><br>2. They have to be in the same class and well there's a couple of differentways to check about the same class and that's another religiousdebate that we'll ignore.<br><br>3. And experts debate about that and people who are interested can lookon the web for that kind of date.<br>
addresses|sentence cnt : 2 <br> <br>1. So, in that case, it'll build a symboltable with IP addresses as keys and we can type in an IP address and get theassociated URL.<br><br>2. In this example or CSV file relates URLs to IP addresses.<br>
path|sentence cnt : 45 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. Now, the algorithms that we're looking at today are not goingto actually give the path connecting the two objects.<br><br>3.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>4. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>5. That's restoring the heap border along a path from the place where it's violated to the root.<br><br>6. This isthe average path in a tree, this is the, the worst of all the keys.<br><br>7. Thereis a path from eight to three to four to nine.<br><br>8. Every path from the rootdown to a null link has the same number of black links that just follows directlyfrom the corresponding property for 2-3 trees.<br>
telescope|sentence cnt : 3 <br> <br>1. So now, this is a recurrence thattelescopes.<br><br>2.Substitute the previous equation telescope.<br><br>3. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br>
correspond|sentence cnt : 49 <br> <br>1. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>2. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>3.Now, what's interesting about binary search trees is that there are manydifferent binary search trees that correspond to the same set of keys.<br><br>4. So we've got M bins, that's ourcorrespondence to our hash table.<br><br>5. So, just following those threecases, I see t hat this correspondence is going to work.<br><br>6. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>7. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>8. If get returns in non null value, then there's a value correspondingto that key in the table.<br>
remark|sentence cnt : 4 <br> <br>1.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>2. It's quite remarkable, actually.<br><br>3. And one ofthe things to remark about it is that it only uses N exchanges and so forth.<br><br>4. So one remark before we do theanalysis is that actually binary search trees correspond exactly to Quicksortpartitioning.<br>
transformations|sentence cnt : 3 <br> <br>1. So, those local transformations,converting a 2-node to a 3-node or converting a three to a four, and thensplitting and passing a node up.<br><br>2.It's a bunch of transformations but they're all simple using our flip colorsor left or right rotation.<br><br>3. And to prove that, we just need to showthat each transformation maintains symmetric order and perfect balance, andthese are all the possible transformations that we could do.<br>
trategy|sentence cnt : 7 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>3. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>4. Now what about inserting?Well, it's a similar type of strategy as with regular binary search trees, exceptthat we manipulate the two and 3-node to keep perfect balance in the tree.<br><br>5. So, the basic s trategy is, with thoseoperations, maintain one-to-one correspondence with 2-3 trees when we doinsertions.<br><br>6. We're going to get the situation where twovalues hash to the same array index and we need a collision resolution strategy totry to figure out what to do in that case.<br><br>7. So, that's asummary of linear probing or second hash, collision avoidance strategy.<br>
searching|sentence cnt : 14 <br> <br>1. The first part is data typesorting and searching.<br><br>2. And then find the index associatedwith the key that we're searching for using binary search.<br><br>3. The cost of computing the hash function can mean that something like redblack trees will even outperform hashing even for just searching and insert.<br><br>4. In this case, if we're searchingfor G, it's gotta go left, because it's less than S.<br><br>5. Okay, let's take a look at a demo ofsearching in a 2-3 tree.<br><br>6. And that's diffidently one thingto consider when using hashing is that the cost of computing the hash function for acomplicated key might exceed the cost of searching and using a simpler structurelike a binary search tree.<br><br>7. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>8. So, range searching is a veryimportant fundamental operation.<br>
save|sentence cnt : 17 <br> <br>1. And then the last thing we need to do isjust return the item that we saved away.<br><br>2. So the first point that's the closestwe found so far to the query point, so we'll save our number 1 as the distance.<br><br>3. So we, to add it at the end, so first thing we need to do is save a link,the last node.<br><br>4. While we know the one that we want to return is the one at the root, so we'll save that value away to return to the client.<br><br>5.Is to save a little bit of time you don't really haveto copy over into the auxiliary array.<br><br>6.We have to save it some of way.<br><br>7. Now, in this case, to implement delete max we save away that value at the root in max, and we eliminate loitering by nulling out that vacated position, then return the max value.<br><br>8. And it's effective, it means you don'thave to actually move items, and that saves a little bit oftime.<br>
pairwise|sentence cnt : 1 <br> <br>1. For example, in the firstlecture, we're going to talk about the network connectivity problem, where theproblem is, given a large set of items that are connected together pairwise isthere a way to get from one to another with a path through the connections.<br>
annoying|sentence cnt : 2 <br> <br>1. And so, it'san annoying surprise for many people and many applications.<br><br>2. The problem is that when we do that, it messes up the sort by name andthat's annoying.<br>
theirs|sentence cnt : 2 <br> <br>1. And so client programs andsystem programs on the Java system were having terrible performance on theirsymbol table because of the shortcut in hashing.<br><br>2. It's larger than the keys in this two children and they're larger than theirs and so forth, so it's the largest key in the data structure.<br>
quicksort|sentence cnt : 59 <br> <br>1.That's a complete implementation of Quicksort.<br><br>2. Quicksort not stable.<br><br>3. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>4. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>5. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>6. And the idea is just a version of Quicksort in away.<br><br>7. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>8. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br>
moved|sentence cnt : 9 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2. We just moved things around locally withinnodes.<br><br>3.Now the last element in the left sub array is the one that's going to get moved next.<br><br>4. We looked to the push downstack where we removed the item that was most recently added, And the queue where weremove the item that was least recently added.<br><br>5. So thislittle example if we insert P, Q, and E then when we do remove max, we want to getthe Q out and for later, we insert X, A, and M and then we removed max.<br><br>6. So, in this case, it starts out with the inputexample shown and then the 13-sort - a few items are moved, 4-sort - a fewmore are moved, and then finally, a 1-sort.<br><br>7. So to avoid that andreally allow most efficient use of memory, it's best to set thatremoved item entry to null.<br><br>8. We've removed the maximum and we still have our data structure heap order and our N keys stored in the first N positions in the array.<br>
correctly|sentence cnt : 3 <br> <br>1. We can have more confidence that our priority queue operations are going to work correctly, if we know that the type of data that's on the property queue is immutable.<br><br>2. If you have a sort method that can store anyvalues in an array, it could, for example, store zeros in every array entry thatmethod would pass this test, but it didn't really correctly sort the array becauseoverwrote all the values.<br><br>3.That's pretty simple code, the question is, if you have a sorting algorithm thatpasses that test, are you sure that it correctly sorted the array? Well theanswer to that question is, yes if, yes if you used only the less() and exchange()methods to implement, to refer the data because then you know because you used theexchange() method that the data in the array after the sort is the same data as was inthe array before the sort, sort.<br>
obvious|sentence cnt : 7 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. So that's obviously a verydesirable characteristic.<br><br>3. Which isobviously much higher than we want.<br><br>4. Probably finding duplicates by itself is not quite obvious what to do butthe easy way to solve it is to just go ahead and sort.<br><br>5. This is oneof those mathematical facts that seems obvious but then if you try to prove thatmaybe it's a little more subtle than you think.<br><br>6. Obviously, not practical toaddress such a problem on today's computer.<br><br>7. There's some other applications that are not so obvious wherewe use sorting as a to make a problem easy once you know that they're sorted.<br>
unifying|sentence cnt : 1 <br> <br>1. Now that we've seen efficientimplementations of algorithms that can solve the unifying problem for hugeproblem instances let's look to see how that might be applied.<br>
theorem|sentence cnt : 1 <br> <br>1. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
solving|sentence cnt : 16 <br> <br>1. So now what about solving a problem likethis, range search problem for a 2d tree.<br><br>2. That's the a Quicksort like implementationsolving the selection problem.<br><br>3. Now we're going to look at a technique forresolving that problem.<br><br>4. That's the idea for solving any problem.<br><br>5.Now we'll look at our first implementationof an algorithm for solving the dynamic connectivity problem, called Quick-find.<br><br>6. One is an, what'scalled an upper bound which is a cost guarantee that's provided by somealgorithm for solving the problem.<br><br>7.This is a so called eager algorithm, for solving kind activity problem.<br><br>8. We saw a few easy algorithms for solving theproblem, and quickly saw that they were inadequate for addressing huge problems.<br>
wasted|sentence cnt : 1 <br> <br>1. We have less wasted space and probablyfaster implementation of each operation.<br>
slowly|sentence cnt : 3 <br> <br>1. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>2. And another pointabout this is it< /i> seems that this is</i> so close to being linear that is t imeproportional to N instead of time proportional to N times the slowly growingfunction in N.<br><br>3.And, it's a extremely, simple algorithim, but surprisingly, complicated tounderstand, so we'll go slowly.<br>
qsort|sentence cnt : 3 <br> <br>1. Andthis was taking a look at the Qsort that a user found was broken and, and now, thismethod is incorporated into some plenty of system sorts.<br><br>2. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br><br>3. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
acknowledge|sentence cnt : 1 <br> <br>1. So here's the Java library implementationsfor a few standard types and they are what they are andwhat we'll do is we acknowledge that that'swhat the hash code is.<br>
scale|sentence cnt : 5 <br> <br>1.Because if we have a computational process that takes quadratic time, then it's notgoing to scale, we're not going to be able to do large number of particles.<br><br>2. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>3. And, and the reason is, and theproblem is that quadratic algorithms don't scale with technology.<br><br>4. Thereason is they don't scale.<br><br>5. And that is an algorithm that scales.<br>
setup|sentence cnt : 4 <br> <br>1. So, that's the setup.<br><br>2. So we need to fill in this one table, what's the cost of deletion in a binary search tree? How we're going to really do that? Well, let's take a look at a very lazy approach which we setup for in our basic conventions for symbol tables.<br><br>3. So, that's our basic setup.<br><br>4. So that's the basic setup or the invariant that we want to maintain in this data structure.<br>
yourself|sentence cnt : 5 <br> <br>1. And that's really easy to convince yourself that that's true because the height if we add nodes one at a time going from left to right on the bottom level say, the height only increases when N is the power of 2.<br><br>2. You can [cough] convinceyourself with that quite easily.<br><br>3. Interesting to think just, justabout this case and to prove to yourself that it's always going to be perfectlybalanced when it's descending.<br><br>4. It's a little mind bending atfirst because of the recursive structure but it won't take you long to convinceyourself that this little bit of extra code completes the implementation ofleft-leaning red-black trees.<br><br>5. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br>
legal|sentence cnt : 19 <br> <br>1. And that's a legal red-black BST.<br><br>2. If it goes on the right, then we attach a new node with thered link on the right but we have to rotate it to the left to make a legalthree node.<br><br>3. That's a legal left-leaning red-blacktree.<br><br>4.Okay? And that's the legal of 2-3 trees, So we stop inserting A into that.<br><br>5. That's a temporary 4-node and we split andmove R to the parent, Now that parent's a legal and there'snothing more to be done.<br><br>6. And then, flip the colorsand that's a legal red-black BST.<br><br>7. So, now we need to rotate left and then once we've done that,now we have a legal left-leaning red-black tree.<br><br>8. After we do the left rotate, we have a legalleft-leaning red-black tree, and it exactly corresponds to that 2-3 tree, sothe insertion of C gives us exactly what we would want, that correspondence withthe 2-3 tree.<br>
like|sentence cnt : 162 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br><br>2. Like using anotherhatch function rather than looking at the next entry.<br><br>3. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>4. So, here's what the implementation of a sparsevector might look like.<br><br>5. In fact, some were discovered by undergraduates in a course,course like this.<br><br>6. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>7. So now what about solving a problem likethis, range search problem for a 2d tree.<br><br>8. And there's plenty of other algorithms waiting to be discoveredby students like you.<br>
spurred|sentence cnt : 1 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br>
shuffles|sentence cnt : 3 <br> <br>1. The other thing is that the seed is just the number of milliseconds since midnight and that cuts down the number of shuffles even more.<br><br>2. The number of possible shuffles is much more and it's 52, it's 52 factorial which is a lot bigger than two to the 32nd, so it's not close to random or uniform.<br><br>3. Another problem is in this implementation, the random uses just a 32-bit seed, if you do that, there's not enough possible shuffles.<br>
covered|sentence cnt : 16 <br> <br>1. In fact, some were discovered by undergraduates in a course,course like this.<br><br>2. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>3. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>4. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>5. But most algorithms that we consider, were discovered inrecent decades.<br><br>6. So at the root, the maximum endpoint orthe rightmost point covered by an interval, is 24.<br><br>7. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>8. That's another great algorithm waiting tobe discovered.<br>
initialization|sentence cnt : 2 <br> <br>1. Now instead of the initialization always takes timeproportional to N.<br><br>2. So, we do have a quadraticinitialization phase that we perform just once to get the priority queue filled up.<br>
animations|sentence cnt : 1 <br> <br>1. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
depend|sentence cnt : 31 <br> <br>1. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>2. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>3. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>4. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>5.Plus what happens next depends on what the partitioning element was.<br><br>6. And so all that says is thatall the objects are independent.<br><br>7. And what about Mergesort? Mergesort is stable well,it's stable as long as the merge operation is stable and that operation is going tobe stable depending on how we code it.<br><br>8. Notice again that it depends on the randomshuffle at the beginning that's going to be important for performance.<br>
immediately|sentence cnt : 7 <br> <br>1. Well, just looking at one example you can see almost immediatelywhat to do to find the minimum, we move left from the root until we find a nullkey, that's where the smallest key in the data structure is.<br><br>2. And that immediately gives this code forinsertion sort, which is similar to our code forselection sort and just as simple.<br><br>3.x) and we see that calculation here gives youimmediately whether it's counter clockwise, clockwise or co-linear.<br><br>4. And so you can kind of immediately arrive at that performanceeven for simple clients.<br><br>5. Again, we exchange as long as the cardimmediately to the left is greater.<br><br>6. [cough] and that gives us immediately our code for the selectionsort implementation.<br><br>7. And those counts are going to notonly enable us to immediately implement the size function, just return the countat the root but also, they'll give us good implementations of rank and select.<br>
throughout|sentence cnt : 5 <br> <br>1. And these methods are all widely used throughout ourcomputational infrastructure.<br><br>2. We use to implementlinked list in all linked data structures throughout the course, weuse what's called an inner class in Java.<br><br>3. That's going to be the overall architecture forstudying algorithms that we're going to use throughout the course.<br><br>4. And that's going to be a discipline thatwe're going to follow carefully throughout this course.<br><br>5. Even if you are familiar with linkedlists, it's worth taking a look at this code because it's the style of codingthat we'll use throughout the course for much more complicated data structures.<br>
implement|sentence cnt : 442 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2.That's a complete implementation of Quicksort.<br><br>3. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>4.But the other test is not in our implementation.<br><br>5. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>6. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>7. So the clustering in the data is going tomake the implementation inefficient.<br><br>8. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br>
elements|sentence cnt : 41 <br> <br>1. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>2. The partitioning elements in between themand they're in the wrong order.<br><br>3.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>4. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>5. To put it in sorted order, we have to movefrom right to left, exchanging it with every larger elements to its left, andthat's what the code at the bottom does.<br><br>6. If the array happens to be already sorted,all insertion sort does is really validate that each elementhas got smaller elements to its left.<br><br>7. Now, what about when we get one that's greaterthan the partitioning elements? So, in that case, we exchange greater the oneover at the right with i and decrement gt.<br><br>8. It starts j at i, and decrements j, exchanging j withthe elements to its left, a of j with the element to its left,a of j-1, as long as a of j is less than a of j-1 orj is bigger than 0.<br>
previous|sentence cnt : 7 <br> <br>1. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>2. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br><br>3.Substitute the previous equation telescope.<br><br>4. And the idea is that each of thesorts can be implemented with only a few exchanges given that the previous oneshappened.<br><br>5. The inner class node is the code that was given on the previousslide, and then we'll need implementations of put and get, and we'll also look at animplementation of delete, and an iterator as well.<br><br>6. But the other thing is if the increments are small because we'vedone previous h-sorts for bigger values of h, the array is partially sortedand so Insertions Sort is going to be fast.<br><br>7. And then push is the four lines of codethat I gave on the previous line and pop is the three lines of code thatI gave on the slide before that.<br>
programming|sentence cnt : 39 <br> <br>1.3 of the book, or in our introduction to programming andJava book.<br><br>2.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>3. So, because there's all these applications most programmingsystems have a fast sort as an important part of their infrastructure and Java isno exemption.<br><br>4. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>5. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>6. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>7. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>8. There's a lot of different ways toimplement callbacks and that's programming language specific.<br>
providing|sentence cnt : 2 <br> <br>1. But the problem bycomparison with sorting is, we don't get to randomize the order the client isproviding the keys.<br><br>2. That's the, our basicimplementation is providing rank.<br>
asks|sentence cnt : 2 <br> <br>1. And then key partof the problem is find query or the connected query, which just asks, is therea path connecting the two objects.<br><br>2.Now there is more complicated versions of Mergesort and Quicksort that can do thisin theory but Heapsort is pretty simple algorithm that gets both done, so in a jobinterview somebody asks you what's an in-place sorting algorithm that'sguaranteed N lg n? Your answer's going to be Heapsort.<br>
challenge|sentence cnt : 7 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>2. This gets to the intellectual challenge of developingalgorithms.<br><br>3. So our challenge is to look formethods that give us more efficient implementations forthese search and insert operations.<br><br>4. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br><br>5. That's our challenge.<br><br>6. So the challenge is to do the resizing,but somehow ensure that ithappens infrequently.<br><br>7. And the real practical challengewith hashing is that developing a hash function is that every typeof key needs a hash function and you need a different approach forevery key type.<br>
summarizes|sentence cnt : 1 <br> <br>1. This, slide summarizes the code for, heap construction.<br>
group|sentence cnt : 4 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>2.Group of four key, continuous keys in a table space there is called a cluster andclearly we want to keep those clusters small.<br><br>3.Or you could think of a social network where it's people connected and eitherthere's a c onnection between two people or not and these are a way not to get fromone group of people to another communicating through that social network.<br><br>4. Now we compare the minimum again, again,the one pointed group by j is smaller, so we move that one to k.<br>
situations|sentence cnt : 25 <br> <br>1. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>2. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>3. And the other thing that we could dois we can use null and some situations are temporary situations to implementa lazy version of the delete() operation.<br><br>4. Duplicate keys, we may notneed N log N compares, we're going to look at the method that I guess that down inlinear time and a lot of situations.<br><br>5. Now, in other situations,maybe they're not comparable and all we're allowed to use isto use the equals operations.<br><br>6. And since sorting is an operation that'sused in so many situations, many of the standard Java types that you would expectto involve sorts will implement Comparable.<br><br>7. So there is going tobe situations that are going to require an understanding of what it takes to engineera, a sort method that's appropriate for your application.<br><br>8. And as we'll see this extendsto a practical problem in a number of situations.<br>
closure|sentence cnt : 1 <br> <br>1.Another popular closure resolution methodis known as linear probing.<br>
ugly|sentence cnt : 3 <br> <br>1. So, we'll build a new array of keys and we have to use an ugly cast because of generic arrays in Java, and that's where it's comparable and we need one more than the capacity to handle this thing where we don't use position zero.<br><br>2. But in thiscase we have to put in this one cast and so what we've heard about that is the uglycast it doesn't, it doesn't make you feel good about the code.<br><br>3. And we have to use ugly cast, 'cause we can't have a race ofgenerics.<br>
classic|sentence cnt : 21 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2. Hashing really at its core isa classic space-time tradeoff.<br><br>3. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>4. And that allows us to model the situationwith a so-called Bins and Balls model that directly relates the study of hashfunctions to classical probability theory.<br><br>5. Next we're going to talkabout Binary Search Trees, a classic data structures that'll enables us to provideefficient implementation of symbol table and out rhythms.<br><br>6. We'll look at two classicalgorithms.<br><br>7. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>8. And those are just examples ofclassic results from combinatorial analysis that help us understandwhat happens when we do this, which is what we're doing with hashing.<br>
undergraduate|sentence cnt : 4 <br> <br>1. In fact, some were discovered by undergraduates in a course,course like this.<br><br>2. So that's John Bentley who discoveredthis while an undergraduate at Stanford.<br><br>3. So, another undergraduate in an algorithmsclass discovered this idea for N-body simulation and that's Andrew Appel.<br><br>4. And also one point to make forthis class is that this algorithm was discovered by an undergraduatein an algorithm school.<br>
chains|sentence cnt : 3 <br> <br>1. So, you can't make Mtoo large, you have too much space and you'll have empty chains or short chains.<br><br>2. You have, these clusters or these chains building.<br><br>3. Another way to use two hash functions is just to hash the twopositions and put the key in the shorter of the two chains.<br>
concerned|sentence cnt : 1 <br> <br>1. In ancient times, memory was, at quite apremium and so people were very concerned in m-m-making sure that the hash tablenever, got too empty.<br>
unix|sentence cnt : 1 <br> <br>1. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
precise|sentence cnt : 7 <br> <br>1. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>2. Not an easyanalysis, but we actually could make precise accurate statements about theperformance of this algorithm.<br><br>3. We modeled theproblem to try to understand precisely what kinds of data structures andalgorithms we'd need to solve it.<br><br>4. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br><br>5. So this is precisely the binarysearch code that we looked at before.<br><br>6. Is are those precisely the same objects ornot? Now usually in applications where wewant to have something more general than that, we have a concept of a value orlike a key in our case.<br><br>7.That's corresponds precisely to our temporary four node when we're doing 2-3trees.<br>
finding|sentence cnt : 14 <br> <br>1. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>2. Nowhow we are going implement or solve this problem or you can think of lots of waysto go ahead and solve this problem of finding the largest M items in the streamof N items.<br><br>3. And now, the statistical problems are like that or findingduplicates.<br><br>4. But finding the best incrementsequence is a research problem that has confounded people for quite a long time.<br><br>5. So, finding, incrementing I, as long asit's less is a simple while loop.<br><br>6. And so,for example, finding the median and if it's already sorted, it's much easy tofind the median.<br><br>7. And then there are plentyof applications that we'll see later in this course like data compression orcomputer graphics like finding the convex hull, applications in science such ascomputational biology or, or in systems development.<br><br>8. [COUGH] And if it's changing the value associated with a key that's alreadythere, then it's just a matter of finding where the key is andchanging the value at that index.<br>
adversary|sentence cnt : 1 <br> <br>1. Anadversary can learn your hash function and just send you data that causes hugeperformance problem by just making all that data hash to one particular item.<br>
errors|sentence cnt : 1 <br> <br>1. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
assigning|sentence cnt : 1 <br> <br>1. So wehave them sorted by name and this is say, something that we do just before assigningfinal grades.<br>
unusual|sentence cnt : 3 <br> <br>1. Or if it's some application where the order of insertion of the keys is wellmodeled by random order and that's not unusual at all.<br><br>2. There is this test fornull that has to be there and if it's not there it can lead tonefarious bugs and unusual problems.<br><br>3.Now we're going to take a look at whathappens when we have significant numbers of duplicate keys which is not at allunusual in practical applications.<br>
variable|sentence cnt : 30 <br> <br>1. And then we set its instance variables.<br><br>2. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>3. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>4. Then wehave a for loop that goes through every element in the array, we keep a variablemin in that is the index of the going to be the index of the smallest element tothe right of pointer i.<br><br>5. Say, for this fictionalclass Student, that's got two instance variables - name and section.<br><br>6. And that will reset our instance variable, which is our stack,to this new, bigger array.<br><br>7. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>8. The only instance variable is a link to the rootnode called root.<br>
perfect|sentence cnt : 20 <br> <br>1. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>2. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>3.Another property of these 2-3 trees is that we are going to have perfect balance,That is every path from the route to a null link is going to have the same linkin the 2-3 tree.<br><br>4. If there was perfect balance before,there's perfect balance after, because we didn't change the heights of anything elsein the tree.<br><br>5.If the parent was a 2-node then the transformation is a local transformationand if you look at where the links are, then it's easy to see by induction that ifthere was perfect balance before there's perfect balance afterward,Because we didn't change anything about the perfect balance in any of thosesubtrees.<br><br>6. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br><br>7. Now what about inserting?Well, it's a similar type of strategy as with regular binary search trees, exceptthat we manipulate the two and 3-node to keep perfect balance in the tree.<br><br>8.That is the word that we defined, for 2-nodes and 3-nodes, and we also have theperfect balance.<br>
orthogonal|sentence cnt : 5 <br> <br>1. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>2. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br><br>3. So, it's called the orthogonal line segment, segment intersection searchwhere the lines segments or constrained to be either horizontal or vertical.<br><br>4. But with the basic interval search tree algorithmand the sweep line process that we've talked about, you can get the orthogonal,orthogonal rectangle intersection search problem solved in time proportional toanalog N log N + R log N, where R is the number of intersections.<br><br>5. And basically, these ruleshad to do with doing this ortho, orthogonal rectangle intersection search.<br>
ourselves|sentence cnt : 3 <br> <br>1. And that's easyto convince ourselves of that just from, from what we did in the demo.<br><br>2. Once we have a good algorithm, if we haveanother problem we can say to ourselves, well, we've got a good solution to thisalgorithm, can we use that solution to solve our new problem? Convex hull, whenwe have a good sorting algorithm, it gives us a good convex hull algorithm.<br><br>3. We should convinceourselves really that it always works and so we'll spend just a moment on a shortproof.<br>
counts|sentence cnt : 5 <br> <br>1. And also, we have to update the count, something happened down below, and we use that code to update the counts in a consistent way.<br><br>2. And again, update all the counts after the recursive calls.<br><br>3. So to delete the node that has no children, just return null and then go back up to update the counts as usual, that's the easy case.<br><br>4. So maybe a node got deleted down there, but always the invariant is, that the count of the node is one plus size the left and right, and then return x and fix the links from the counts on the way up.<br><br>5. And those counts are going to notonly enable us to immediately implement the size function, just return the countat the root but also, they'll give us good implementations of rank and select.<br>
hired|sentence cnt : 1 <br> <br>1. And that's maybe a little bit what happens when a new boss is hired from the outside and then the two subordinates struggle to take over that position and then the boss would get demoted to it's level of competence.<br>
deny|sentence cnt : 1 <br> <br>1. It could be that there aresome increment sequence out there that make Shellsort more efficient than anyother method, any of the sorting method that we know for pratical file size, noone can deny that.<br>
center|sentence cnt : 5 <br> <br>1. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>2. But use the center of mass andyou get a very accurate [COUGH] approximation tothe N-body doing that.<br><br>3. For example,if they're all arranged in a circle and your query point's in the center orsomething of that sort.<br><br>4. And what we wanted to do with the temporary four node was to split it andpass the center node up to the root.<br><br>5. You have centering, where you try to point near the centerof mass of the k nearest boids.<br>
delete|sentence cnt : 62 <br> <br>1.Delete code is a bit more complicated but it's on the book side and in the book.<br><br>2. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>3. Then delete themaximum.<br><br>4. So, a lot of people didn't seethe delete implementation.<br><br>5. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>6. And in this case it's H, and we put that node in T spot and then delete the minimum.<br><br>7. If it does have a right child and we do this, find the minimum on the right, deleteMin on the right and then fix the links, and then update our count that covers all cases.<br><br>8. That's a fine implementation for deleteMin and it also works for deleteMax.<br>
check|sentence cnt : 79 <br> <br>1. So we have to be sure we've gotthe method that we want for checking whether two keys are equal.<br><br>2. And so we search to the left sub-tree andwe check if it contains point 5 and it does, that's the one that we return.<br><br>3. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br><br>4. Find implementation is identical to for quick union, you're justchecking whether the roots are equal.<br><br>5. Because it would have N^2,calls to find, to check whether they're connected.<br><br>6. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>7. For the union implementation, we're going tomodify the code to check the sizes.<br><br>8. And don't forget to check that we're going off the end of the heap.<br>
need|sentence cnt : 143 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. But when N is large, 40 N is a very closeestimate to the amount of space needed.<br><br>3. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>4. And then the last thing we need to do isjust return the item that we saved away.<br><br>5. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>6. And if you don't have order in the keys at all then you need the compareto, to implement balance search trees.<br><br>7. That is, we need that extra auxiliaryarray for the last merge.<br><br>8. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br>
sync|sentence cnt : 16 <br> <br>1.Again root of a three node heap may or may not be heap ordered, we do have to do thesync operation.<br><br>2. We may need to fix it with the sync operation.<br><br>3. And so we'll do a sync on the S and bring it into a heap ordering, sothat's with just a few exchanges we got that whole array heap order, and now whatwe want to do is take advantage of the heap ordering in the array to do a sort.<br><br>4. Then thesecond pass again that's only a two liner, we exchange the first element with the oneat the end and then decrement the size of the heap and then do a sync operations.<br><br>5. Onevery smaller heap, now we continue just performing sync operations at the rootuntil we get a completely sorted array.<br><br>6. Do the sync operation onthe A.<br><br>7. The R goes off theheap, do the sync operation on the M, and now we have a heap ordered array.<br><br>8. Do the sync operation on E which involves promoting the larger of its twochildren, until it gets to the bottom, or a place where it's larger than both itschildren.<br>
collided|sentence cnt : 1 <br> <br>1. And if there is, then we couldroll back time just a little bit and I'll try to figure out exactly, the moment ofwhich they collided and then figure out how the position and velocity shouldchange accordingly and then continue the simulation.<br>
note|sentence cnt : 13 <br> <br>1. If we're sorting N items then let C of Ndenote the number of compares that we need tosort the N items.<br><br>2. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>3. To add a note, or enqueue,add a new note to a linked-list.<br><br>4. And then isEmpty is just testing whetherthe first note on the list is null.<br><br>5. Also, of course,if they're not equal then you'd like it to be that they're hash code's are notequal but you can't always get.<br><br>6. So we have 40 bytes per stack note.<br><br>7. So, we had a single temporary four note and we split itup into a two, two note not connected to a four note.<br><br>8. But in many other cases maybe it's not fast enough, or there's notenough memory.<br>
speed|sentence cnt : 4 <br> <br>1. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>2. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>3. The dt speed, speed variable that's given as argumentdt.<br><br>4. And the move method again,most of the times, just takes the x and y coordinates and adds the current velocitytimes the speed constant.<br>
complete|sentence cnt : 38 <br> <br>1.That's a complete implementation of Quicksort.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>4. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>5. So that's three different clients, three completelydifferent types of data.<br><br>6. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>7. So,our partitioning is complete.<br><br>8. But now you can see that, that localtransformation on the 2-3 tree completes the insertion.<br>
complimentary|sentence cnt : 1 <br> <br>1. So this two, complimentary ways to look atthis.<br>
hyphen|sentence cnt : 4 <br> <br>1. Otherwise, if it's a string that'snot equal to the hyphen character, it'll just push it onto the stack.<br><br>2. If the string is equalto the hyphen character, it'll pop the string at the topof the stack and print it.<br><br>3. And our simple client is totake some strings on standard input and some pop commands whichare indicated with hyphens.<br><br>4. Then when it comes to this hyphen, it'll pop the most recently inserteditem which is 'to' in this case.<br>
specify|sentence cnt : 4 <br> <br>1. So, what we are going to do with thisclient is specify with integers which field is the key, and which is the value.<br><br>2. There's all kinds of cases where we justhave a lot of information, maybe on our PC or all over the web, and we want to createan index that allows us to specify.<br><br>3.So say your geometric objects are points in the plane and you specify a rectanglethat's oriented with the horizontal/vertical axes.<br><br>4. All of that leads up to, in a programmingworld to specifying, a data type which is simply specification of the methods thatwe are want to going to implement in order to solve this problem.<br>
sites|sentence cnt : 11 <br> <br>1. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>2. If they're connected by open sites.<br><br>3. People often ask aboutprerequisites.<br><br>4. So, we have an assignment whereyou need to generate a random open sites in a percolation system.<br><br>5. Or in a browser you might want to mark your visited pages orblock sites and so forth.<br><br>6. So how do we model opening a new site? Well to open asite we just connect it to all it's adjacent open sites.<br><br>7. These are used for digital photos, where the objectsare pixels they're used for networks, where the objects are computers, socialnetworks, where it's people, or computer chips, where it's circuit elements orabstract things like variable names in a program, or elements in a mathematicalset, or physical things like metallic sites in a composite system.<br><br>8. This is with a hundred sites and 88 unionoperations.<br>
people|sentence cnt : 58 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>3. So, a lot of people didn't seethe delete implementation.<br><br>4. So, that's an answer to the question for people t hat have beenasking.<br><br>5. And there's plenty of other applications where people want to be ableto compute the convex hull.<br><br>6. There's many other reasons that people use immutable data types.<br><br>7. Is there a simple algorithm that is linear? And people, looked for along time for that, and actually it works out to be the case that we can prove thatthere is no such algorithm.<br><br>8. People have come up with methods forgetting this done.<br>
connections|sentence cnt : 4 <br> <br>1. Now, theconnections, well, we need, a few abstract properties that these connections have tosatisfy.<br><br>2. For example, in the firstlecture, we're going to talk about the network connectivity problem, where theproblem is, given a large set of items that are connected together pairwise isthere a way to get from one to another with a path through the connections.<br><br>3. So forexample in this example with our ten objects the idea array that describes thesituation after seven connections is illustrated in the middle of the slide.<br><br>4. When we have an equivalence relationa set of objects and connections divide into subsets called connected components.<br>
explain|sentence cnt : 1 <br> <br>1. So here's just a particular client that will helpexplain the idea.<br>
represents|sentence cnt : 4 <br> <br>1. Whenever we're at a node, it represents apoint, so we're going to check that point and we'll compute the distance fromthat point to our query point.<br><br>2. So, in this case, the first field is three letters from theDNA sequence which, represents a codon.<br><br>3. So, we have a data type called ball that represents justone of the particles and has instance variables that has the position and thevelocity.<br><br>4. Well, we're going to use the 2dtree represents our points and we're going to use the structure anddefinition of that tree to go ahead and help us find the pointsthat are in the rectangle.<br>
nodes|sentence cnt : 72 <br> <br>1. A binary search tree, each node has a key and everynodes key is larger than all the keys in its left subtree and smaller than all thekeys in its right subtree.<br><br>2. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>3. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>4. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>5. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>6. So when we start putting the keys in the nodes, we're going to impose one more condition that's called heap ordering.<br><br>7.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>8. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br>
pushes|sentence cnt : 3 <br> <br>1. So how are we going to grow andshrink the array? Well, first thing you might think of is,when the client pushes a new item onto the stack, increase the size ofthe array by 1, and when it pops, decrease the size of the array by 1.<br><br>2. But the advantage that weget is very fast pushes and pops, just access array and increment it,and very efficient for most operations.<br><br>3. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br>
fewer|sentence cnt : 1 <br> <br>1. And this first argument is just ignorewords fewer than this many letters.<br>
edvac|sentence cnt : 1 <br> <br>1. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br>
bouncing|sentence cnt : 5 <br> <br>1. If you got one bigparticle like a pollen grain and lots of little particles like atoms molecules andbouncing against it the big one is going to move about randomly.<br><br>2. So, that's all the code for doing the bouncing ball simulation.<br><br>3. So, this is just extending our ball data type that we use for thebouncing balls that didn't collide to take in, into account these extra things.<br><br>4. And then the onlyto move [cough] operation does is to update the position of the ball by thevelocity, which is just another number and then it does the bouncing off the walls.<br><br>5. [cough] So, asa wa rm-up, here's code to implement bouncing balls without the collisions.<br>
unsatisfactory|sentence cnt : 3 <br> <br>1. Idon't want to spend a lot of time with this cuz I think this is a unsatisfactorysolution.<br><br>2. That really seems unsatisfactory.<br><br>3. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br>
simulator|sentence cnt : 1 <br> <br>1. So for example,if you've played the game Doom or used a flight simulator that these types of graphical simulations andanimations are made possible.<br>
fingerprints|sentence cnt : 2 <br> <br>1. And so the, it's the concept of so called one way hash functions whichmean that we, we, use it for secure to try to be, have some secure fingerprints foruse on the web.<br><br>2. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
sweet|sentence cnt : 1 <br> <br>1. So Java has a customized implementationsfor the standard data types that people would use for similar table keysand that's the sweet spot for hashing.<br>
passwords|sentence cnt : 1 <br> <br>1. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
formulas|sentence cnt : 5 <br> <br>1. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>2. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>3. So there's simple formulas to tell us what todo and we can also figure out the formulas for what we do o nce they do collide.<br><br>4. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>5. So these are mathematical formulas andthere's techniques for solving them and we won't go intothat.<br>
totaled|sentence cnt : 1 <br> <br>1. And because the interval search trees take logN for every operation, the insert and delete intervals is N log N totaled andthe searches is N log N + R log N.<br>
growth|sentence cnt : 2 <br> <br>1. The other things that we didn't talk about, the implementation should throw an exception if the client tries to delete from an empty priority queue, and we should have a no-argument constructor and use a resizing array to account for a gradual growth and shrinkage in a industrial strength implementation.<br><br>2. Floor and ceiling that's again is an outgrowthof the rank operation.<br>
flaws|sentence cnt : 1 <br> <br>1. And the fact was that all the qsort implementations at that time in Unix hadthis flaw well, there are two flaws and one of them is a little complicated aboutthe way they are raised order and the other one was for a raise that had lots ofequal keys and this is Wilks and Becker problem and have lot of equal keys, it wasquadratic time.<br>
motivating|sentence cnt : 1 <br> <br>1. And those simulations are only enable by fast union findalgorithms, that's our motivating example for why we might need fast union findalgorithms, so let's look at that.<br>
solid|sentence cnt : 1 <br> <br>1. But there's aproblem so you would think that the system sort would be completely solid with allthis resource with all these research and all of the development that's going intoit.<br>
hacking|sentence cnt : 1 <br> <br>1. And in fact, it didn't take that much hacking for someone to realize that after seeing five cards and figuring out what the server clock was doing, you could get all the future cards in real time in a program, and that's a pretty tough thing to have happen if you're implementing online poker.<br>
whenever|sentence cnt : 8 <br> <br>1. And for linear probing hashing, really, theimplementation needs to include array resizing, whenever the hash table gets toofull.<br><br>2.Whenever we get a new one, then we throw away the smallest one that's there.<br><br>3. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>4. Whenever we're at a node, it represents apoint, so we're going to check that point and we'll compute the distance fromthat point to our query point.<br><br>5. Whenever you're processing geometric data, you're doing some kindof geometric search.<br><br>6. So, whenever we find a right link, we're sitting on aright red link we just rotate it left and return that.<br><br>7. [cough]and because in this implementation for left-leaning red-black trees we're goingto return the link whenever we're done, and then that will get that link installedup in the node above whether it be left or right.<br><br>8. A regular binary search tree will just be all strung out in a single lineand wouldn't have quadratic time for this input but a left-leaning red-black treeactually when, whenever it becomes a power of two is completely balanced as you cansee from this example.<br>
just|sentence cnt : 503 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>3. It's always refers tosomething that's nearby something else that I just referred to.<br><br>4. And then the last thing we need to do isjust return the item that we saved away.<br><br>5. It's just complicated code to understand.<br><br>6. Sothis is just another typical example where we've got things sorted by time, and thenwhat we want to do is maybe these are important events.<br><br>7.So, one thing we can do is just run it for a 100 balls in random position at randomvelocity.<br><br>8. We just put a test in the recursiveMergesort for that, through this one line of code, to checkwhether we're done.<br>
unsafe|sentence cnt : 1 <br> <br>1. It says that we're using unchecked or unsafe operations and we shouldrecompile with a minus -Xlint equals unchecked for details.<br>
temperature|sentence cnt : 2 <br> <br>1. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>2. As I mentioned, it goes back to the study of physics with [cough] thetrying to understand the pressure and temperature in Einstein's famousexperiment on a pollen grain showing that their motion was brownian and random.<br>
parc|sentence cnt : 1 <br> <br>1. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br>
saved|sentence cnt : 2 <br> <br>1. And then the last thing we need to do isjust return the item that we saved away.<br><br>2. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br>
determine|sentence cnt : 9 <br> <br>1. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>2. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>3. Use another hatch function todetermine the stride that we're going to use.<br><br>4. Again one path through the tree to determine anintersection.<br><br>5. So, how are we going to be able to determinethese intersections efficiently? Now, the natural algorithm, or the naivebrute-force algorithm, is quadratic in time.<br><br>6. So, in this case, if you go from top to bottom in the tree with threecompares at most you can determine the ordering of the three different items.<br><br>7. The only solution we have comes from acomputational model, where we run simulations to try and determine the valueof that probability.<br><br>8. If b less than c goes theother way, then it takes another comparison to determine the order.<br>
starlings|sentence cnt : 1 <br> <br>1. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br>
comparisons|sentence cnt : 11 <br> <br>1.And then we do the comparisons as, as before and that, and that's all fine.<br><br>2. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>3. And that approximation gives us, it'sabout two M+1 natural log N comparisons for Quicksort.<br><br>4. They the expected number of comparisons isconcentrated around this value.<br><br>5. That's the average number of comparisonstaken by Quicksort, and actually they for a random permutation of the elements whichis what we do with the shuffle.<br><br>6. For sorting that's kind of straight forward,what we're going to do is have a cost model where we count the comparisons.<br><br>7. And the proof is, the number ofcomparisons and the number of exchanges is equal to the number of exchanges equalto the number of inversions, and there's an extra compare forevery element except the first.<br><br>8. In the case of Quick Sort, the number ofcomparisons taken to sort N items is N+1 for the partitioning.<br>
symmetric|sentence cnt : 12 <br> <br>1. And the right rotationimplements this and again that's going to maintain a, a symmetric order in perfectblack balance we change the way the red goes but we didn't change anything aboutthe black.<br><br>2. That is, every object's connected to itself, it'ssymmetric.<br><br>3. It's a little bit asymmetric.<br><br>4. A binary tree in symmetric order that's the data structur ethat we're going to use to implement symbol table operations.<br><br>5. Now, the property of this operation that's very important is itmaintains a symmetric order.<br><br>6. The two things that are critical is thatthe, in a, in a 2-3 tree, we always have symmetric order.<br><br>7. And sothat's just the symmetric code to the code that we just did.<br><br>8. A binary search tree is abinary tree in symmetric order.<br>
simul|sentence cnt : 42 <br> <br>1. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>2.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>3. So figuring outthe value of dt that would really work is a huge problem for the time drivensimulation.<br><br>4. So, we want to simulate the motion of N moving particlesthat might collide with the priority.<br><br>5. So, now we canlook finally at the main event driven simulation loop.<br><br>6. Instead, what we want to do is called an event driven simulation.<br><br>7. So now,let's look at the main loop for the event driven simulation.<br><br>8. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br>
horse|sentence cnt : 1 <br> <br>1. Infact, there's an argument for just using this implementation of Quicksort andforgetting about horse because it performs so well in so many practical situations.<br>
longest|sentence cnt : 5 <br> <br>1. It's guaranteed that the longest path which is alternating red andblack can be no more than twice as long as the shortest path which is all blacks.<br><br>2. Andso in this case the longest path is ten and the average path is seven for 255.<br><br>3. When you're enqueue you go at the end, and when the one that's been in therethe longest is the one that comes off.<br><br>4. In, in that case, thenthe expected length of the longest chain will be lg, lg N which is quite animprovement.<br><br>5.How long can those paths be? Well, it's not hard to see that the, inthe worst case, if they're all 2-nodes, that's the longest they can be is log basetwo of N.<br>
deep|sentence cnt : 2 <br> <br>1. So, this isn't just an example about software security, there's a lot of difficult and deep issues to worry about in software security, and we're not going to worry about all of them.<br><br>2. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br>
afford|sentence cnt : 2 <br> <br>1. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>2. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br>
devoted|sentence cnt : 1 <br> <br>1. And, sothere was quite a bit of effort, devoted to figuring it out, how full we could getthe hash table, in linear probing.<br>
assorted|sentence cnt : 1 <br> <br>1. In this case, this insertion just says wewant to be sure that a of lo to mid assorted andthat mid plus one to high is sorted before our code andthen we want to check that, the whole thing issorted after our code.<br>
passes|sentence cnt : 5 <br> <br>1. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>2. Whatever the size,bottom of Mergesort gets the job done in log N passes.<br><br>3. Because if you're looking for thesmallest, you can just go through the array and find the small or the smallestin one pass through or if you're two, you'll find it and two passes through.<br><br>4. The bottom line in this is sequence of passes through thewhole array and there's no recursion needed at all.<br><br>5.That's pretty simple code, the question is, if you have a sorting algorithm thatpasses that test, are you sure that it correctly sorted the array? Well theanswer to that question is, yes if, yes if you used only the less() and exchange()methods to implement, to refer the data because then you know because you used theexchange() method that the data in the array after the sort is the same data as was inthe array before the sort, sort.<br>
fifo|sentence cnt : 1 <br> <br>1. And that's also call the FIFO discipline,first in, first out.<br>
neither|sentence cnt : 2 <br> <br>1. If neither one exhausts, we need exactly Ncompares.<br><br>2. And if we this the, the thing called event which involves it saysbetween two particles, something is going to happen at a certain time and we'regoing to adopt the conventions that, if, neither particle is null then we'retalking about two particles.<br>
constructor|sentence cnt : 14 <br> <br>1. The constructor has to create the array and then go through andset the value corresponding to each index I to I.<br><br>2.So let's start with the constructor, well we have a, a private integer array.<br><br>3. We have a constructor tocreate an empty stack.<br><br>4. It's a class, the constructor doesn't haveto do anything, there's no constructor.<br><br>5. For convenience, we'll provide a constructor that takes the key and valueas argument and fills in the key and value instance variables then the left and rightlinks are initialized to null.<br><br>6. And so a constructor for an immutable vector data type, it might take an array as its argument.<br><br>7.The constructor is the same as the other one.<br><br>8. The constructor, takes SR unit, the number of objects, so that it canbuild data structure based on the number of objects.<br>
arbitrarily|sentence cnt : 4 <br> <br>1.The idea is to arbitrarily choose the first element to be the partitioningelement.<br><br>2. And arbitrarily we choose to change the ones that are thesame as P to the ones that are same as Q.<br><br>3.Rather than just arbitrarily using the first element.<br><br>4. So arbitrarily our first point,we're going to divide the plane into two parts basedon a vertical line through that point.<br>
connected|sentence cnt : 51 <br> <br>1. If they are connected it'll ignore.<br><br>2. They're in their own connected component.<br><br>3. Because it would have N^2,calls to find, to check whether they're connected.<br><br>4. But if we ask is eight connected to nine? We are goingto say yes, even no we don't have a direct connection between eight and nine.<br><br>5. If they're connected by open sites.<br><br>6.Elements that are all by themselves in just, in their own connected component,point to themselves, so one points to itself but also nine points to itself.<br><br>7. That is, every object's connected to itself, it'ssymmetric.<br><br>8. They're either connectedor not then that will take quadratic time in squared time.<br>
produces|sentence cnt : 1 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br>
recreation|sentence cnt : 1 <br> <br>1. And if you find a key that's equal to the key you're looking for,return the value and we have to cast it to value because of the generic recreationproblem in Java, otherwise return null.<br>
foreliner|sentence cnt : 1 <br> <br>1. So that also is a foreliner toimplement the stack push operation.<br>
needing|sentence cnt : 1 <br> <br>1. So, it goes down to the middle, and windsup needing to be inserted in the, 3-node in the middle.<br>
helpful|sentence cnt : 1 <br> <br>1. That's pretty helpful although not, nottotally helpful but there's a lot of situations wherethat's helpful.<br>
shorter|sentence cnt : 1 <br> <br>1. Another way to use two hash functions is just to hash the twopositions and put the key in the shorter of the two chains.<br>
slower|sentence cnt : 6 <br> <br>1. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>2. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>3. In the second case,it's slower than selection sort, because it uses about the same number ofcompares, but it uses many more exchanges.<br><br>4. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br><br>5. So it's going to be slower.<br><br>6. As computers get faster and bigger, quadraticalgorithms actually get slower.<br>
using|sentence cnt : 107 <br> <br>1. Like using anotherhatch function rather than looking at the next entry.<br><br>2. So, one thing is we're usinga different key interface.<br><br>3. Even though we know we're not using it,the Java system doesn't know that.<br><br>4. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>5. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>6. Okay, here's the complete Java implementation of a priority queue, we're using the binary heap data structure.<br><br>7. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>8. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br>
flows|sentence cnt : 1 <br> <br>1. Where a vacant side is just empty and a block side hasgot some material, and either the water flows through from top to bottom, or not.<br>
helps|sentence cnt : 5 <br> <br>1. And we point that outbecause that helps with the mathematical analysis.<br><br>2. So the Java language helps us with thisComparable mechanism so that we can sort data of any type.<br><br>3.Next we'll take a look at comparatorswhich is a Java mechanism that helps us sort.<br><br>4. So now we'll look at adata structure called an interval search tree that helps to solve this problem.<br><br>5. There's another family of methodswhere there's no ordering, and there's a special methodcalled hashCode that helps us inject randomness into the process.<br>
distinguish|sentence cnt : 4 <br> <br>1. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>2. Going from a to b you turn left to get to c in the first case and you goright to get to c in the second case and we want to do a computation thatdistinguishes this.<br><br>3. So,that's why we picked the color red to distinguish red links the types of linksin three nodes.<br><br>4. In those operations to distinguish them, we call NQ to insert an item andDQ to remove an item.<br>
devices|sentence cnt : 1 <br> <br>1. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br>
genomics|sentence cnt : 1 <br> <br>1. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br>
invent|sentence cnt : 8 <br> <br>1. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>2. This method was invented in 1961 by TonyHore, who won the Turing Award in 1980 for this and other work.<br><br>3. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>4. He's widely accredited as being theinventor of Mergesort.<br><br>5. But one of the things that was invented there, was thelaser printing and we were very excited to have nearby color laser printer that couldprint things out in color and out of the colors, the red looked the best.<br><br>6. This is one of the oldest sortingmethods invented by Shell in 1959.<br><br>7. And so, there is still the goal of a, of afast guaranteed linear time selection algorithm maybe somebody in this classwill invent someday.<br><br>8. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br>
quote|sentence cnt : 3 <br> <br>1. Here's a quote from one of Javas architect Josh Block, "Classes should be immutable unless there's a very good reason to make the mutable.<br><br>2.Another quote from Francis Sullivan, says, "The great algorithms are the poetry ofcomputation.<br><br>3. A famous quote and there's many similar quotes, 'The generation of random numbers is too important to be left to chance'.<br>
named|sentence cnt : 1 <br> <br>1. It was named as one of the most importantalgorithms of the twentieth century and it's widely used for system sorts and manyother applications.<br>
sawyer|sentence cnt : 2 <br> <br>1. The word lamb appears both in Tom Sawyerand Aesop's Fables, and so forth.<br><br>2. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br>
oracles|sentence cnt : 1 <br> <br>1. Sql or Oracles database and others,are based on, some variant of B-trees because they're so, so effective.<br>
which|sentence cnt : 206 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>3. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>4. It could be that,if one of the fields is an object, then you use that object's equalswhich applies the rule recursively.<br><br>5. This does not include the space for the strings themselves,which are owned by the client.<br><br>6. We figure out which of the children is larger.<br><br>7. [COUGH] All right, so this is the code for the get operation andthis rank which is binary search.<br><br>8. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br>
switch|sentence cnt : 9 <br> <br>1. If you need that kind of order,maybe in an internet switch where packets are coming through at a great rate, youwouldn't want to be in a situation where you're missing some data becausesomething got slow all of a sudden.<br><br>2. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br><br>3. You can kind of switch the role of theinput and the auxiliary array every time youmake a recursive call.<br><br>4. In the1970s, when we switched to very large scale integration for computers, we wereswitching from a situation where we were wiring physical devices together, to asituation where we were essentially drawing the computer.<br><br>5. Somethings are wires, and some things are switches that, are used to, implementmemory bits and computer logic.<br><br>6. Again, now when we go to one level below,we switch again to vertical.<br><br>7. So it's recursive argument switchery toget the job done.<br><br>8. So it's a regular binary search tree butit's got this interpretation based on the geometric data,where we switch which key we use for the comparison, the x coordinate orthe y coordinate at each level.<br>
fills|sentence cnt : 10 <br> <br>1. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>2. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>3. And so, that's thesituation as the table fills up.<br><br>4. For convenience, we'll provide a constructor that takes the key and valueas argument and fills in the key and value instance variables then the left and rightlinks are initialized to null.<br><br>5. And one way to think about what goes on is to just watchwhat happens when a hash table fills up.<br><br>6. Whenit fills up, it's red, and that splits into two half pages and then keys getadded on one side or the other so each.<br><br>7. Now we have three pages andwe keep going eventually one of them fills up and splits.<br><br>8. This is a simulation that shows a, agrowing B-tree so when a page, at the top, there's just one page that fills up.<br>
invalidates|sentence cnt : 1 <br> <br>1. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br>
satisfactory|sentence cnt : 4 <br> <br>1. Idon't want to spend a lot of time with this cuz I think this is a unsatisfactorysolution.<br><br>2. That really seems unsatisfactory.<br><br>3. This is a general method that people often use in all different types of implementations, but in modern systems it's rather unsatisfactory.<br><br>4. It's not really satisfactory because of that, and we'll come back to this, but it works.<br>
disjoint|sentence cnt : 1 <br> <br>1. It's got what we call nodes which containinformation and every node's got two links to Binary Trees that are disjoint from oneanother, a left tree and right tree associated with each node.<br>
unoccupied|sentence cnt : 1 <br> <br>1. The white is the unoccupied part.<br>
stub|sentence cnt : 1 <br> <br>1. The client is always going to betesting hasNext() as I showed as I showed and that stub code before and so when itgets to null it will return false in the iterational stop.<br>
ways|sentence cnt : 70 <br> <br>1. It's always refers tosomething that's nearby something else that I just referred to.<br><br>2. Make sure that both first andlast are always what we want them to be.<br><br>3. Now instead of the initialization always takes timeproportional to N.<br><br>4. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>5. And we'll always go towardsthe query point first.<br><br>6. As far as the algorithms go, as far asthe rules go, you can always return 17.<br><br>7. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>8. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br>
light|sentence cnt : 12 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. But once unlocked, they cast a brilliant new light on some aspect ofcomputing.<br><br>3. Slightly reduces the number of compares.<br><br>4. so, with the, more [COUGH] complex userinterface, this is, very much what the spotlight or find functionon your computer is doing.<br><br>5. It's actually going to be quadratic in the worst case but again, thechance of that it will happen with a random shuffle is less than the chancethat we'll be struck by lightning.<br><br>6. So, what we wouldlike to do is just declare a new array using our generic name Item as in thehighlighted line here.<br><br>7. So, just adding thisextra loop for h-sorting and this extra loop to compute the increments toInsertion Sort, we get a slightly more complicated piece of code but its much,much more efficient.<br><br>8. But with random, the random shuffle it'smore likely that this lecture will end, because of a lightning strike.<br>
guaranteeing|sentence cnt : 1 <br> <br>1.That random shuffle at the beginning is important and needed for guaranteeingperformance.<br>
versions|sentence cnt : 11 <br> <br>1. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>2. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>3.That's the basic Mergesort algorithm that we're going to look at differentversions of in the next.<br><br>4. And the proof is, the number ofcomparisons and the number of exchanges is equal to the number of exchanges equalto the number of inversions, and there's an extra compare forevery element except the first.<br><br>5. If you have huge numbers ofparticles and you measure the number that hit the size and the frequency with whichthey hit they sides you can do experiments relating temperature and pressure and manyother things or do three-dimensional versions.<br><br>6. This array has six inversions.<br><br>7. So this array has six inversions, T and R are out of order,because R should go before T.<br><br>8.Now there is more complicated versions of Mergesort and Quicksort that can do thisin theory but Heapsort is pretty simple algorithm that gets both done, so in a jobinterview somebody asks you what's an in-place sorting algorithm that'sguaranteed N lg n? Your answer's going to be Heapsort.<br>
methods|sentence cnt : 38 <br> <br>1.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>2. Now, if you're going to be using methods that depend on randomness in real applications, you do have to be careful.<br><br>3. In the instance, methods won't change them and the client can't change them.<br><br>4. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>5. We'lllook at different methods that take advantage of such properties.<br><br>6. Iwant to be able to create an empty set, we've got methods to add a key to the set,and to check whether a given key is in the set or not.<br><br>7. People have come up with methods forgetting this done.<br><br>8. And these methods are all widely used throughout ourcomputational infrastructure.<br>
input|sentence cnt : 35 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. And so, this client readsstrings from standard input.<br><br>3. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>4. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>5. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>6. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>7. We start with therandomly ordered input and you can see that it gets more and more in order oneach time that we h-sort for the decreasing values of h.<br><br>8. You can kind of switch the role of theinput and the auxiliary array every time youmake a recursive call.<br>
lingo|sentence cnt : 1 <br> <br>1. So what'san Iterable? Well, in Java lingo what an Iterable is, it's, it's a class that has amethod that returns an iterator.<br>
realized|sentence cnt : 3 <br> <br>1. John Von Norman realized that thedevelopment of the EDVAC, his EDVAC computer, one of thefirst general purpose computers that is going toneed a sorting method and he came up withMergesort.<br><br>2. Mathematicians were trying hard tounderstand this problem and were ready to give up and he realized you could useclassical balls and bins type probabilistic analysis.<br><br>3. And in 1991, there were some scientists that,that Bell Labs that were using qsort for a scientific problem and they were used totaking just a few minutes and then they realized that it was taking hours of CPUtime.<br>
trying|sentence cnt : 20 <br> <br>1. And all we want to count isthe first time we access a page, because the main cost is trying to find where thepage is.<br><br>2. And so if you're trying to provide a service over the web.<br><br>3. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>4. So there's a number ofthings that you might consider trying.<br><br>5. And it's important for us to know that theory and that willhelp us decide how to choose which algorithms we're going to use in practice,and where to concentrate our effort in trying to find better algorithms.<br><br>6. You're both testing that these conditions hold, and also telling someone reading thecode, what you're trying to do with it.<br><br>7.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>8. So,you can imagine trying to look for a selection algorithm that takes timeproportional to n and also the lower bound is n because you have to look ateverything.<br>
clients|sentence cnt : 27 <br> <br>1. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>2. So that's three different clients, three completelydifferent types of data.<br><br>3. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>4. So we can,implement these, efficiently and they are, convenient and useful for the clients.<br><br>5. And the first rule of the game that we have to thinkabout is, how can we make it so that we can implement one sort program that can beused by these three different clients to implement three different types of data.<br><br>6. So those are the basic operationsthat we're going to want to implement to get the associative arrayabstraction and then there's many, many possibilities for clients andwe'll look at some later on.<br><br>7. All of these operations are very useful forclients and we'll see plenty of examples later on.<br><br>8. And so you can kind of immediately arrive at that performanceeven for simple clients.<br>
wrapper|sentence cnt : 5 <br> <br>1. And the same with the wrapper types like integer and double or color and lots of things.<br><br>2. If it's a primitive type,use the wrapper hashCode.<br><br>3. And there's aprocess called auto-boxing which automatically cast between primitive typesand wrappers so all of that handles of the, the problem of dealing with primitivetypes, kind of behind the scenes.<br><br>4. And for primitive types takethe wrapper type and use the hash code.<br><br>5. So in order to handle generic types wehave to use Java's wrapper object types.<br>
resetting|sentence cnt : 1 <br> <br>1. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br>
mutability|sentence cnt : 3 <br> <br>1. So what about immutability? So, everything in Java is implemented as a data type, a set of values and operations on those values.<br><br>2. If a class cannot be made immutable, you should still limit its mutability as much as possible.<br><br>3. So the advantages of immutability and again, maybe this isn't the place to really solve those advantages, it's more for a programming language course, is that it really simplifies debugging.<br>
approximate|sentence cnt : 4 <br> <br>1. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>2.And then that gives us an easy sum that we can approximate by an integral.<br><br>3. And, again these formulas are nice approximate formulas, but Knuth, oncehe figured this out, in 1963, tells stories, that time, he decided to writehis famous series of books on algorithms.<br><br>4. But intuitively, we can see kind of whathappens each partitionings that maybe splits the array approximately in half.<br>
sorting|sentence cnt : 75 <br> <br>1. The first part is data typesorting and searching.<br><br>2. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>3. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br><br>4. One of the most useful onesis to have comparable keys just as in sorting algorithms.<br><br>5. That's a lower bound on the complexity of sorting.<br><br>6. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br><br>7. The idea behind Shellsort is that we'll move entries severalpositions at a time and the way we're going to do it, it's called h-sorting thearray.<br><br>8.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br>
inheritance|sentence cnt : 2 <br> <br>1. So shouldn't use it inconnection with inheritance.<br><br>2. So we don't use inheritance that much soI won't talk about that.<br>
routine|sentence cnt : 7 <br> <br>1. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>2. Now in this case the second subarray to be sorted is smallerbut the merge routine doesn't really care about that so much.<br><br>3. The idea is that you create acomparator object and then pass that as a second argument to Java's sort routine andwe can do the same thing for our sorts.<br><br>4. Now, it's important to not create theauxiliary array in the re in the recursive routine because that couldlead to extensive cost of extra array creation.<br><br>5. We'll see later Kruskal's minimum spanning treealgorithm, which is a graph processing algorithm which uses Union-find as asubroutine.<br><br>6. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>7. In order to get that done, we're sortingthe left half and the right half and this notation ceiling of N over 2 andfloor of N over 2 that's the N over 2 round up and N over 2 round down, that'sthe size of the two sub-arrays, and we're going to call the same routine forthat size, so the number of compares you needto.<br>
understood|sentence cnt : 4 <br> <br>1. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>2. The Physics problem is exactly what happenswhen two balls hit and they bounce off each other according to somewell-understood physical process, and that's the high school Physics.<br><br>3. So, all of the operations thatwe're going to look at for red-black trees can be understood in terms of thecorresponding operations on 2-3 trees.<br><br>4. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br>
reuse|sentence cnt : 2 <br> <br>1. In that way, many clients canreuse the same implementation.<br><br>2. So the a quick hack that is widely used is to use casting to implementto reuse the code for different data types.<br>
symbol|sentence cnt : 123 <br> <br>1. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>2. So these are our consequences, so it's the contains implementation is the samefor all our symbol type implementations.<br><br>3. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>4. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>5. And so[COUGH] this statement builds a new symbol table with string keys and integer values.<br><br>6. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>7. That's building a symbol table associatingkeys with sets of files.<br><br>8. And a good way to think of a symboltable is as shown in the right here.<br>
proofs|sentence cnt : 2 <br> <br>1. We do some mathematical proofs in, in thiscourse when they're critical such as this one.<br><br>2. We'll look at three proofs of that, justassuming that N is a power of 2.<br>
version|sentence cnt : 24 <br> <br>1. And the idea is just a version of Quicksort in away.<br><br>2. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>3.This bottom-up version that has no recursion, it's also quite simple tounderstand and to code up.<br><br>4. And the other thing that we could dois we can use null and some situations are temporary situations to implementa lazy version of the delete() operation.<br><br>5. So this is, and actually the versionthat we're going to, looking at is called left-leaning red-black BSTs.<br><br>6. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>7.That's the basic Mergesort algorithm that we're going to look at differentversions of in the next.<br><br>8. And the proof is, the number ofcomparisons and the number of exchanges is equal to the number of exchanges equalto the number of inversions, and there's an extra compare forevery element except the first.<br>
longhand|sentence cnt : 1 <br> <br>1. And if we didn't have that we would now, if we're usingiterators, we could go ahead and write this longhand code but nobody would everdo that cuz it's equivalent to the shorthand or we might have to write clientcode that does a lot of unnecessary pushes and pops just to do this iteration.<br>
doug|sentence cnt : 1 <br> <br>1. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br>
hypothesis|sentence cnt : 1 <br> <br>1. With the inductive hypothesis that D of Nequals N lg N, we want to show that D of 2N equals 2N lg 2N, using the recurrence D of2N equals 2D of N plus throw out the 2N.<br>
isnot|sentence cnt : 3 <br> <br>1. A binary search tree is asimple and extremely effective data structure that can support all of theseoperations in a quickly, much better than binary search in an ordered array which isnot dynamic and slow for insertion.<br><br>2. And on the other thing is it's not stable,sometimes people choose to use Mergesort in practice because of the stability butHeapsort isnot stable for the usual reason that it does long distance exchanges thatmight bring items that have equal keys back out of order.<br><br>3. So 6 isnot there.<br>
unsatisfied|sentence cnt : 1 <br> <br>1.Now, from a theoretical standpoint that's a little unsatisfied and in, in 1973,there's a famous paper that found a compared base selection algorithm thatguarantees to solve the problem in linear time.<br>
discipline|sentence cnt : 4 <br> <br>1. And that's also call the FIFO discipline,first in, first out.<br><br>2. That's also called the LIFO discipline,last in, first out.<br><br>3. And that's going to be a discipline thatwe're going to follow carefully throughout this course.<br><br>4. And we'll be very disciplinedin our use of this style.<br>
correspondingly|sentence cnt : 1 <br> <br>1. And correspondingly given a red-black BST then you can get the 2-3tree if you wanted it.<br>
reasonable|sentence cnt : 6 <br> <br>1. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>2. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>3. But anyway, those arereasonable goals.<br><br>4. Unreasonable to expectthe implementation to work well if the client can change the valuesof keys that are in the table.<br><br>5. So if you have a quadratic time algorithmfor implementing symbol tables or linear time for each operation,you're not going to be able to run this client in a reasonableamount of time for a big amount of data.<br><br>6. And we've got a reasonable hash function.<br>
significance|sentence cnt : 1 <br> <br>1. You can sort from that heap and that's significance be,significant because it's the first sorting algorithm that we've seen that is both inplace.<br>
fire|sentence cnt : 1 <br> <br>1. Now we're going to look at an applicationwhere we simulate a phenomenon in nature, and this is, what kind of patternsdo things like starlings and geese or cranes, or fish, or fire flies.<br>
passed|sentence cnt : 3 <br> <br>1. To support comparators in our sort implementations we'll pass an arrayof objects and instead of an array of comparable and then, there's a secondargument passed a comparator.<br><br>2. So, here's another one that involves, remember, wepassed that red link up.<br><br>3. There might, if that gets passed up to a three node, thenwe have to continue moving up the tree and just treat it in the same way as we justtreated inserting at the bottom.<br>
seems|sentence cnt : 13 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. It seems strange to be ignoring parenthesis and we'll getback to that in a second.<br><br>3. Here's a way to get shuffling done using a sort, it seems like the opposite.<br><br>4. And this seems to be a problem, we can't be supposedly having a dynamic situation that is going to allow support of lots of different inserts and leads and in the end, wind up with a less balanced treat.<br><br>5. So that seems as if it should work but that doesn't have all the characteristicswe need in the Java implementation.<br><br>6. That really seems unsatisfactory.<br><br>7. First when we look at, seemseven simpler than the regular symbol tables, and that's about sets.<br><br>8.This seems to be with a small value, multiple of n times the number of incrementsused which is some multiple maybe of n log n but nobody is been able to find anaccurate model that proves that for any interesting increment sequence forShellsort.<br>
warehouse|sentence cnt : 1 <br> <br>1. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br>
base|sentence cnt : 59 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>3. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>4. And the algorithm that he usedis based on 3d-trees with the N particles as nodes, and storing the centerof the mass in the subtree in each node.<br><br>5. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>6. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>7. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>8. That's exactly log base 2 of N, so thegrand total of all the costs for the merge, which iswhere the compares are, is log N times N, N log N.<br>
method|sentence cnt : 150 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. So we have to be sure we've gotthe method that we want for checking whether two keys are equal.<br><br>3.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>4. And then, here's the move method.<br><br>5. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>6. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>7. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>8. This paper was veryinfluential and, and that basic method is widely used.<br>
supresses|sentence cnt : 1 <br> <br>1. And it also just supresses a lot of details that are notrelevant to union find.<br>
reactor|sentence cnt : 1 <br> <br>1. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
replace|sentence cnt : 11 <br> <br>1. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>2. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>3. So actually with a good generic implementation it's not difficultto simply [cough], take every place that we used string and replace it with ageneric type name as in this code here.<br><br>4. So we take the E, replace it with the H, and delete the H, and then everything's fine.<br><br>5. And it's easyto extend that to handle other types of things and so, why does this work? Well,when the algorithm encounters an operator, say, in the inside, we got the parenthesis,operand, operator, operand, parenthesis its easy to see that what its going to doinside there is put the at the top of the stack whatever it is, is to put the twoand three on the top of the value stack and plus on the top of the operating stackand when it hits that right parenthesis, it's going to perform the operation andit's going to proceed then exactly as if the original input where that, where thevalue replaced.<br><br>6. Now,replace STFI with a new node that links to the old STFI.<br><br>7.And the way we do it is, first make a temporary 4-node that replaces that3-node.<br><br>8. So we take that element and replace the root with it.<br>
inductive|sentence cnt : 1 <br> <br>1. With the inductive hypothesis that D of Nequals N lg N, we want to show that D of 2N equals 2N lg 2N, using the recurrence D of2N equals 2D of N plus throw out the 2N.<br>
equation|sentence cnt : 9 <br> <br>1.Substitute the previous equation telescope.<br><br>2.Now that's looking like a much simpler equation.<br><br>3.This looks like a fairly daunting equation, but actually it's not toodifficult to solve.<br><br>4. Because that equation, with C over N plusone equals CN minus one over N, is an equation that telescopes the first term atthe right.<br><br>5.It's a simpler equation already.<br><br>6.So we can apply the same equation so its two over n + one.<br><br>7.That's a kind of a magic step, but we will see that it makes possible to solve theequation easily.<br><br>8.So, for every value of k, if you add those up the probability that the partitioningelement is k, plus the cost for the two subfiles, we get this equation.<br>
discovered|sentence cnt : 14 <br> <br>1. In fact, some were discovered by undergraduates in a course,course like this.<br><br>2. And there's plenty of other algorithms waiting to be discoveredby students like you.<br><br>3. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>4. But just a fewyears ago for this course I found a much simpler implementation of red-black treesand this is just the a case study showing that there are simple algorithms still outthere waiting to be discovered and this is one of them that we're going to talkabout.<br><br>5. But most algorithms that we consider, were discovered inrecent decades.<br><br>6. Now, this algorithm people discovered rather earlyon after figuring out the weighting and it turns out to be fascinating to analyzequite beyond our scope.<br><br>7. That's another great algorithm waiting tobe discovered.<br><br>8. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br>
ascending|sentence cnt : 8 <br> <br>1. So everything to the left of i is inascending order, everything to the right, we haven't seen it all yet.<br><br>2. And once we've done that, then we have everything tothe left by in ascending order.<br><br>3. First exampleis to just sort some random real numbers into ascending order.<br><br>4. Watching the [unknown], this is a balanced tree gettingconstructed in the worst case where everything that comes in is in ascendingorder.<br><br>5. The invariants are that the entries on ontothe left of the arrow are never changed and they're in ascending order.<br><br>6. Re-arrange an array of n items into ascending orderaccording to a defined key which is part of the item.<br><br>7. 4, exchange it with everybodyto its left that's greater, until we find a smaller element,then it's in ascending order.<br><br>8. Even though they came in, in ascending order, the treewinds up being perfectly balanced.<br>
grabs|sentence cnt : 1 <br> <br>1. It grabs an element andbrings it back into position every time.<br>
terrible|sentence cnt : 1 <br> <br>1. And so client programs andsystem programs on the Java system were having terrible performance on theirsymbol table because of the shortcut in hashing.<br>
religious|sentence cnt : 1 <br> <br>1. They have to be in the same class and well there's a couple of differentways to check about the same class and that's another religiousdebate that we'll ignore.<br>
attributes|sentence cnt : 5 <br> <br>1. There can't be a systemsort out there that's going to cover all possible combinations of attributes.<br><br>2. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>3.Then, we've talked about a bunch of attributes.<br><br>4. There's alot of attributes, the different applications have.<br><br>5. But the thing is, there is way morepossible combinations of attributes than there are algorithms.<br>
convex|sentence cnt : 36 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. It's not onthe convex hull so, and what about the angle from 1 to 2 to 4? That's notcounterclockwise either.<br><br>3. Atthe beginning, 0->1 is a line that's on the convex hull.<br><br>4. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>5. And there's plenty of other applications where people want to be ableto compute the convex hull.<br><br>6. Sopoint 2 can't be on the convex hull either.<br><br>7. [cough]They're, they're going to be extreme points on the convex hull.<br><br>8. The idea though is that this example illustrates that good sortingalgorithm gives us a good convex hull algorithm.<br>
givas|sentence cnt : 1 <br> <br>1. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br>
internally|sentence cnt : 1 <br> <br>1. We can associate the keywith null internally then apply or know the differencewhether that's in there or not.<br>
inconvenient|sentence cnt : 1 <br> <br>1. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br>
iterator|sentence cnt : 13 <br> <br>1. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>2. To remove a key, and maybereturn the number of keys in the set, and also have an iterator to iterate throughkeys in the set.<br><br>3. We have that's the, our first item in the list and we're goingto maintain an instance variable current inside this iterator which is the currentthing that we're iterating.<br><br>4. And then it will have a clientthat uses the iterator going through all the keysin the symbol table.<br><br>5. That's a very simple implementation of an iterator for these symbol table withcomparable keys.<br><br>6. The inner class node is the code that was given on the previousslide, and then we'll need implementations of put and get, and we'll also look at animplementation of delete, and an iterator as well.<br><br>7. And so now, just we, we know we have a symbol table implementationthat has efficient iterator.<br><br>8. So what's aniterator? So, we're going to use an inner class.<br>
column|sentence cnt : 7 <br> <br>1. And then they get initialized in some way, but the main computation is apair of nested four loops for each row in the matrix we have to go through eachentry in the column vector and compute a running sum of for that row in the matrix,that corresponding expanding entry with the entry in the column and them, keep therunning sum and then that's the result that we put in the result column factorfor every value of i.<br><br>2.This is extending the table we looked at last time, and you can see over in theright column here, Quicksort is quite a bit faster than Mergesort.<br><br>3. So we are going to use a min-oriented priority queue sothat's going to keep, it'll [cough] it'll be one where we can delete the minimumand, and it'll be generic so we'll have a transaction type that holds thisinformation including natural ordering where it's ordered by dollars that lastcolumn.<br><br>4. We have atwo-dimensional matrix one-dimensional column vector for the multiplicand and theresult.<br><br>5. So, this is a standard matrix vectormultiplication that you learn in Math where we have a square matrix and a columnvector and we want to do a dot product of, of first row with the column vector to getthe first entry in the result.<br><br>6. But let'ssay, we want to keep track of the top five [cough] values using the third column asthe value.<br><br>7. And then similarly, dot product of this with that column is 0.<br>
turned|sentence cnt : 11 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. So in this case, that first callwill return a link and whatever link gets returned, that will be set to root.<br><br>3. Whenthere's a function call the whole local environment is pushed and then along withthe return address and then the function returned is pop the return address in thelocal environment.<br><br>4. But otherwise, it's a simple modification ofrecursive tree search to find all the keys and it's easy to see the running time tothat is going to be proportional to the number of keys returned plus log N.<br><br>5. It's going to be cre ated a new node and the link to that node will be returnedand that's the link that we'll put in the left.<br><br>6. So they just returned the value.<br><br>7. But what we'll do is invoke a recursive method starting at the root andwhatever link gets returned, we'll set that to root.<br><br>8. Now,when it's returned then that's the point at which we're going to check whether theleft, the links are leaning to the left as they are suppose to and whether or notthere are any double links or not.<br>
huge|sentence cnt : 58 <br> <br>1.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>2.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>3. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>4.Even on your PC you can sort huge array of a million items in less then a second anda million items in only a few minutes.<br><br>5. So figuring outthe value of dt that would really work is a huge problem for the time drivensimulation.<br><br>6. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>7.All right so QuickFind is too slow forhuge problems.<br><br>8. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br>
track|sentence cnt : 10 <br> <br>1. The red black tree tracks every simplepath from a node to a descendant leaf that has the same number of black nodes.<br><br>2. So, we're going to keep trackof y coordinates in a binary search tree.<br><br>3. Now, ifthe priority queue has more than M items because we inserted that one, then we wantto delete the smallest one there and that way, we're keeping track of the largest M.<br><br>4. And there's many, many other applications including scientificapplications where say, in genomics people use symboltables to keep track of finding markers in a genome andagain many other applications.<br><br>5. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>6. What we'll do is we'll keep track of the number of objects in eachtree and then, we'll maintain balance by always making sure that we link the rootof the smaller tree to the root of the larger tree.<br><br>7.So, even with this huge stream of items coming through, we're only keeping trackof the M largest items and that's a fine canonical client for priority queue.<br><br>8. We have to take track, keep track thelinks as we go up and down the tree to take, handle the splitting,And there's, and there's a lot of cases.<br>
removed|sentence cnt : 6 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2. We looked to the push downstack where we removed the item that was most recently added, And the queue where weremove the item that was least recently added.<br><br>3. So thislittle example if we insert P, Q, and E then when we do remove max, we want to getthe Q out and for later, we insert X, A, and M and then we removed max.<br><br>4. So to avoid that andreally allow most efficient use of memory, it's best to set thatremoved item entry to null.<br><br>5. We've removed the maximum and we still have our data structure heap order and our N keys stored in the first N positions in the array.<br><br>6. Again G is not larger than its two children so we have to exchange it with the larger of the two, that's O, and now we're done, we've removed the largest again.<br>
became|sentence cnt : 2 <br> <br>1. It soonbecame clear that those mathematical models were difficult to solve.<br><br>2. But the key point about it is that designing acomputer became a geometric problem.<br>
integers|sentence cnt : 14 <br> <br>1. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>2. So, what we are going to do with thisclient is specify with integers which field is the key, and which is the value.<br><br>3. Well, it's like in a Javaarray of integers say, our keys in that case are indexes that arerestricted between zero and array size.<br><br>4. So first N items would takethe sum of the first N integers, which we know is about N squared over 2.<br><br>5. And again the string is the key and thesets of integers are going to be the places in the arraywhere the given work appears.<br><br>6. Now for standard keys like integers andstrings and doubles and so forth,we can count on the designers and implementors at Java toimplement good hash functions.<br><br>7. And then as long as standard input is not empty, it's going to read twointegers from the input.<br><br>8. That's going to associateintegers with strings.<br>
sized|sentence cnt : 1 <br> <br>1. It's going to beat even theclassical sophisticated methods for medium sized arrays.<br>
procedures|sentence cnt : 3 <br> <br>1. We need those procedures that implement those Physics rules for everyparticle.<br><br>2. So, we're going to need a bunch of procedures which do the prediction andthe collision resolution.<br><br>3. Okay, so that's the procedures that weneed and then they're similar ones for the horizontal and vertical walls.<br>
intellectual|sentence cnt : 4 <br> <br>1. This gets to the intellectual challenge of developingalgorithms.<br><br>2. Another reason to studyalgorithms is for intellectual stimulation.<br><br>3. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br><br>4. Algorithms are interesting for intellectual stimulation.<br>
swap|sentence cnt : 23 <br> <br>1. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>2. And continue in that way, swap.<br><br>3. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br><br>4. Increment i, generate a random integer, this time it's going to be the first one again, swap them.<br><br>5. In this case, it's the one to the left and we swap those.<br><br>6. Findthe smallest, swap that with i, increment i.<br><br>7. Swap that with i, increment i.<br><br>8. And every time we pick an integer between zero and i uniformly at random, and swap a of i with that integer.<br>
trivial|sentence cnt : 11 <br> <br>1. So, with that one copied at this code, it's almost trivial and it's a method in our standard random class.<br><br>2. So we need to remove this cheat andwe will, but the code is nearly trivialif we have the capacity.<br><br>3. But what's nice about data driven code is now that the code's workingand again we, we're not saying that this is a trivial code to write but it'sdefinitely manageable.<br><br>4. So this is a useful and non trivialclient that's enabled by symbol table.<br><br>5. So that's not much code, and it's trivialcode at that for doing an efficient symbol table search using hashing.<br><br>6. There's a trivial lower bound which says you have tolook at all the data, that's N and we'll look at a better lower bound and see thatmergesort is optimal.<br><br>7. So, that's shuffling our first non-trivial sorting application.<br><br>8. So, if you think of all this is,is, is trivial and easy, go ahead and try to write down a proof that a g-sortedarray remains g-sorted even after it's h-sorted.<br>
replacing|sentence cnt : 3 <br> <br>1.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>2. Essentially, we're finding a node that has only one link leading that node, and then replacing the node that we need to delete with that one.<br><br>3. So, just go in from the inside out for every operation enclosedwithin parenthesis like that it's just repeat the argument that's exactly as ifthe original expression were (one + five) twenty and then again, replacing that one,one + 100, 101.<br>
hitting|sentence cnt : 2 <br> <br>1. Which how many balls do you throw beforeyou find two hitting the same bin, when do you get the first collision? And the answer to that is it'sabout square root of pi M over two.<br><br>2. I want, what's the, given a particle what's the time tillwe hit that particle? What's the time till we hit vertical horizontal wall? And thesame thing is if we're at the point where we're hitting a particle, what would wedo, the, the same way with the vertical and horizontal wall.<br>
expected|sentence cnt : 6 <br> <br>1. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>2. They the expected number of comparisons isconcentrated around this value.<br><br>3. It also has been shown actuallynot that long ago, that the expected height of the tree if they're inserted inrandom order, the height that's the worst case length of a path in the tree.<br><br>4. You get constant time expected and lg, lg N worst case.<br><br>5. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br><br>6. In, in that case, thenthe expected length of the longest chain will be lg, lg N which is quite animprovement.<br>
ordering|sentence cnt : 28 <br> <br>1. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>2. So when we start putting the keys in the nodes, we're going to impose one more condition that's called heap ordering.<br><br>3. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>4. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>5. And we'lllook at the next lecture of what it means the divine ordering among objects, littlemore general than what we do for sorting.<br><br>6. And so we'll do a sync on the S and bring it into a heap ordering, sothat's with just a few exchanges we got that whole array heap order, and now whatwe want to do is take advantage of the heap ordering in the array to do a sort.<br><br>7. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>8. So it has the infrastructure that allows us tobe used for all types of data types and all types of ordering so it's got a methodthat implements comparable then its got methods easy compare order.<br>
eager|sentence cnt : 1 <br> <br>1.This is a so called eager algorithm, for solving kind activity problem.<br>
distinct|sentence cnt : 10 <br> <br>1. Our proposition says that insertion sort,to sort randomly ordered array with distinct keys, it'll use aboutone quarter N squared compares, and about the same number, one quarterN squared exchanges, on the average.<br><br>2. About half a million distinct ones andin that [COUGH] corpus, the word government appearsabout 25,000 times.<br><br>3. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>4. And again, to keep the code simplewe're going to assume that all the coordinates are distinct.<br><br>5. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>6. Now, there's actually some deeper reasonswhy this method is important and one thing to do is to realize that the lower boundthat we talked about before depended on the keys being distinct.<br><br>7. So, amathematical set is just a collection of distinct keys.<br><br>8. Either it's yes or it's not yes,let's, let's say, they're distinct.<br>
accomplishes|sentence cnt : 1 <br> <br>1. And then that sets up for this four loop that accomplishes themerge.<br>
initializing|sentence cnt : 1 <br> <br>1. So, now we start by initializingi at the first card, and we take the idea that everything from ito its left is going to be sorted, and everything from the right we'renot going to look at at all.<br>
arithmetic|sentence cnt : 13 <br> <br>1. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>2. It uses an arithmetic.<br><br>3.The value that arithmetic expression is 101.<br><br>4.It's a few arithmetic operations to do the hash versus lg N and compares for thebalance tree.<br><br>5. So the goal is, you got an arithmetic expression this is justactually like a simple stand in for a program and we'll talk about that in asecond but let's say, arithmetic expressions.<br><br>6. Optimal representation of the data and only a little arithmetic with array indices.<br><br>7. And then there is some that array index arithmetic.<br><br>8. So and then whenyou're done then simply print out the value on the stack and that's a fine andelegant implementation using stacks for any arithmetic expression.<br>
appeared|sentence cnt : 2 <br> <br>1. And at the end,E is associated with the value of 12, the place where it most recently appeared.<br><br>2. And it's going to read a string ofstandard input and then put it in the symbol table associated with the valuei, where it appeared in the input.<br>
align|sentence cnt : 1 <br> <br>1. And we have a 2d rangeis a rectangle oriented to align with the horizontalvertical axis.<br>
usual|sentence cnt : 34 <br> <br>1. Then, asusual we'll connect, the entry corresponding to both five and six tozero.<br><br>2.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>3. And usually that's fairly straightforward.<br><br>4. Actually it usually crashes because it's recursive andit crashes the system stack.<br><br>5. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>6. All of which are private as usual.<br><br>7. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br><br>8. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br>
splits|sentence cnt : 10 <br> <br>1. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>2. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>3.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>4.That's the only time the height of a 2-3 tree changes, when the roots splits theheight introduces increases by one.<br><br>5. That essentially splits the four node.<br><br>6. And then when a node gets filled it splits.<br><br>7. Whenit fills up, it's red, and that splits into two half pages and then keys getadded on one side or the other so each.<br><br>8. Now we have three pages andwe keep going eventually one of them fills up and splits.<br>
entering|sentence cnt : 4 <br> <br>1. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>2. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>3. You have centering, where you try to point near the centerof mass of the k nearest boids.<br><br>4. [cough] So, for this course we have two resources that I wantto talk about and make sure that people are familiar with before entering into thecontent.<br>
precedence|sentence cnt : 1 <br> <br>1. And you can go ahead and extend thisalgorithm to add functions like logs and sines or other operators and haveprecedence among operators, have them associate and multiple operations, and soforth.<br>
wanna|sentence cnt : 5 <br> <br>1. The maximum end-point in the left is 22, and we're looking for 23, andwe're not gonna find anything there, so we just wanna go right.<br><br>2. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>3. And if we wanna find all intervals we just have to run thealgorithm fur Each interval that's, until we come up against no intersection, soit'll take time proportional to R log N if there's R intervals that intersect.<br><br>4. We wanna be able to insert an interval.<br><br>5.We wanna be able to Insert an interval search for an interval, delete an intervalbut the main thing is we want the interval intersection query.<br>
substance|sentence cnt : 1 <br> <br>1. Or, you could think of it as, as water flowing through a poroussubstance of some kind.<br>
prove|sentence cnt : 44 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br><br>3. It'samazing fact that was eventually proved by Friedman and Sachs, that there is nolinear time algorithm for the union find problem.<br><br>4. So easy to prove by correspondence with 2-3 treesthat t he height is guaranteed to be less than two log base two N.<br><br>5. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>6. Is there a simple algorithm that is linear? And people, looked for along time for that, and actually it works out to be the case that we can prove thatthere is no such algorithm.<br><br>7. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>8. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br>
rray|sentence cnt : 375 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>3. And the reason is that you only createa new array every time it doubles.<br><br>4. It's not our fault that we had to do that, wehad to do that cuz of your requirement about not allowing us to declare genericarrays.<br><br>5. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>6. So to insert N items,it's about three array accesses.<br><br>7.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>8. The thing is remember represented in array one two three and so forth.<br>
remind|sentence cnt : 1 <br> <br>1. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br>
known|sentence cnt : 22 <br> <br>1. It's a well-known phenomenon knownas clustering that says that the points aren't going to be evenlydistributed all over the whole thing.<br><br>2. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>3. With a very simple modification,we can take a 2D tree and create a data structure known as a Kdtree, which even works for K dimensions.<br><br>4. In fact, that's what lead to [unknown] analyze the situation then comeup with a left-leaning variant.<br><br>5. And that's an association that'swell known to biologist and then you can use this lookup CSV client to quickly getthe name associated with any given codon.<br><br>6. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br><br>7. Watching the [unknown], this is a balanced tree gettingconstructed in the worst case where everything that comes in is in ascendingorder.<br><br>8. And again, it's well known that mostgeometric data has this kind of problem.<br>
weighted|sentence cnt : 7 <br> <br>1. So, the weighted algorithm always makes sure that the smaller tree goesbelow.<br><br>2. So, here's an example that shows theeffect of doing the weighted quick union where we always put the smaller tree downbelow for the same set of union commands.<br><br>3. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>4. In the bottom, for the weighted algorithm all the nodes arewithin distance four from the root.<br><br>5. But weighted quick union withpath compression in practice is, is close enough that it's going to enable thesolution of huge problems.<br><br>6. With using weighted quick union and with pathcompression, we can solve problems that could not otherwise be addressed.<br><br>7. In the weighted algorithm, wealways put the smaller tree lower.<br>
boundaries|sentence cnt : 1 <br> <br>1. So now we haveour i pointer which is right to the left of stuff we haven't seen ye t and then, wehave two other pointers that maintain, maintain these boundaries everything tothe right of gt is known to be greater than partitioning element.<br>
proposed|sentence cnt : 4 <br> <br>1. But, but actually it's a problem that Edsger Dijkstra had proposedin the 70s as an example of, of programming problem.<br><br>2. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br><br>3. Knuth when he wrote his books in the 60s proposed the incrementsequence 3x + 1.<br><br>4. So what are we going to do with those two links? Well, the Hibbard deletion mechanism which is pretty old, 50 years ago it was proposed, says go ahead and find the next smallest node in the right sub-tree of that tree.<br>
start|sentence cnt : 76 <br> <br>1.So, we start out i is at the left end and then the remaining, all the remainingentries to the right.<br><br>2. The array representation, all we do is we put, we start with indices at 1.<br><br>3. Start with the API.<br><br>4. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>5. We'll start with the 1, 4, 13, 40, 121, 364 like thatand that's good because it's easy to compute.<br><br>6. So when we start putting the keys in the nodes, we're going to impose one more condition that's called heap ordering.<br><br>7. So, that's our starting point in terms of the code.<br><br>8. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br>
shown|sentence cnt : 13 <br> <br>1. And a good way to think of a symboltable is as shown in the right here.<br><br>2. Alright, so with that mergeimplementation, then the sort implementation is a quite simple,recursive procedure shown here.<br><br>3. Do we need guaranteedperformance? Are we happy with random performance? Do we know, is the arrayrandomly ordered? You can think of a matrix shown in the right here where welist out all the possible attributes and then there's algorithms that worked wellfor different combinations of attributes.<br><br>4.com has got this IP addressthat's shown if this line here in the table, and so forth.<br><br>5. Once we have the array partitioned in thatway, shown here in the middle.<br><br>6. It also has been shown actuallynot that long ago, that the expected height of the tree if they're inserted inrandom order, the height that's the worst case length of a path in the tree.<br><br>7. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br><br>8. Andthis is an elementary programing exercise that is the, the code at the left has theeffects shown at the right.<br>
tale|sentence cnt : 7 <br> <br>1. So a blacklist clientwould print out all the words in our source file, tinyTale.<br><br>2. So in this case,tinyTale.<br><br>3.txt the first couple of words from "A Tale of Two Cities.<br><br>4. So, for example, the word freedom appearsin the Magna Ca, Carta and in Moby Dick and ATale of Two Cities [COUGH] in all three of them but not in Tom Sawyer and not in Aesop'sFables.<br><br>5. So for this small data from the beginningof Dickens' Tale of Two Cities, if we run a FrequencyCounter,the FrequencyCounter client.<br><br>6. And because the interval search trees take logN for every operation, the insert and delete intervals is N log N totaled andthe searches is N log N + R log N.<br><br>7. So this is just an example showingall the words in a Tale of Two Cities using the modular hashing function forstrings like the one that Java uses.<br>
uniform|sentence cnt : 15 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>2. It was proved actually a long time ago even before computer implementations that if you do that, you get a uniformly random permutation and it only takes linear time.<br><br>3. Now, it's key that the uniform random number be between zero and i minus one.<br><br>4. Maybe that one's minor but it also is picking a random card from the whole deck, and as we just pointed out, that's not uniform, it should be between one and i or between i plus one and 52.<br><br>5. So idealistically, what we'd likeis to be able to take any key and uniformly scramble it toproduce a table index.<br><br>6. And again, if the uniform hashing assumption holds the probability that thenumber of keys within a list is within a constant factor of N over M is extremelyclose to one.<br><br>7. The number of possible shuffles is much more and it's 52, it's 52 factorial which is a lot bigger than two to the 32nd, so it's not close to random or uniform.<br><br>8. And every time we pick an integer between zero and i uniformly at random, and swap a of i with that integer.<br>
recommended|sentence cnt : 1 <br> <br>1. The other thing that's possible to do andit's a little mind bending so recommended only for experts.<br>
getting|sentence cnt : 12 <br> <br>1. And so that idea of getting closer andcloser to the query point is going to cut out different parts ofthe tree as we process.<br><br>2. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>3. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>4. People have come up with methods forgetting this done.<br><br>5. One of the practices that will follow often inthis course is to check our API design before getting too far into dealing withthe problem, by building a client that is going to use the data type that wedevelop.<br><br>6. That's a detail, but an important onethat we have to take care of in our implementations to make sure that we'regetting most efficient use of memory.<br><br>7. Watching the [unknown], this is a balanced tree gettingconstructed in the worst case where everything that comes in is in ascendingorder.<br><br>8. And again, we keep going until getting to the bottom, or getting to a place where both children are smaller.<br>
stored|sentence cnt : 7 <br> <br>1. And then use that index to get the valuethat's associated with that key, that's stored in a parallel array.<br><br>2. In this case we, wefind H as the left sub tree of R in [cough] that's a search hit and then forthe get operation, we can return the value that's stored in that node along with thekey H.<br><br>3. And that array, it's got value stored in it, say it doubles and those can change but what immutable implementation would do would be to copy those values into the local data array instance variable and then those values are not going to change.<br><br>4. And again, the, heap is stored in the array, with the first key positionone, next to position two and three and like that.<br><br>5. We've removed the maximum and we still have our data structure heap order and our N keys stored in the first N positions in the array.<br><br>6. So our, eh,our node stored intervals, but we only use our left end point as the key.<br><br>7. And so, for example, if theseare the keys in our symbol table and we're doing a search for the index whereP is stored, we look at the middle.<br>
throw|sentence cnt : 16 <br> <br>1. And all it does is divides by 2 again andthen throws out another 1.<br><br>2. And what assert will do is it will throwan exception unless that condition is true.<br><br>3.Whenever we get a new one, then we throw away the smallest one that's there.<br><br>4.We apply for n - one we get one less here and we can throw out a lot two over n.<br><br>5. So we just throw a point 3 out.<br><br>6. We didn't put in code to throwan exception if the client pops from an empty stack.<br><br>7. With the inductive hypothesis that D of Nequals N lg N, we want to show that D of 2N equals 2N lg 2N, using the recurrence D of2N equals 2D of N plus throw out the 2N.<br><br>8. If the types areincompatible or if either one is null compareTo() should throw an exception.<br>
overview|sentence cnt : 2 <br> <br>1. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>2. So here's just an overview of twoelementary implementations for priority queues using the example operations that Igave before.<br>
clearly|sentence cnt : 5 <br> <br>1.Group of four key, continuous keys in a table space there is called a cluster andclearly we want to keep those clusters small.<br><br>2. And clearly, that's going tosupport a quick implementation of the find operation.<br><br>3. Clearly, these things can be extended in many ways.<br><br>4. And clearly, it's worthwhile to thinkabout for your application whether you want or need a stable sort.<br><br>5. And this clearly can make the difference between being able toaddress a huge problem.<br>
equality|sentence cnt : 4 <br> <br>1. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>2. All right, so there is equalities, now equality again we're going toget a programming language issue but still was important to be explicitabout what's going on with equality.<br><br>3. Then the other thing is thatinstead of doing compare to's, we're going to be doing equality tests.<br><br>4. Okay, so that's a standard, this isjust in words the standard recipe for user type optimize forreference equality check against null.<br>
reduce|sentence cnt : 10 <br> <br>1. It reduces to this case.<br><br>2. Slightly reduces the number of compares.<br><br>3. The basic plan is tothink of the symbol table as really try to reduce the problemto being like an array.<br><br>4. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br><br>5. So we have a, a, a bunch of conventions just toreduce the code.<br><br>6. So, for a particular insertion, we can take advantage of this reduce one caseto another by, in, in the way that we're moving in the tree, not to get everythinghappen with just a, a few extra lines of code in our standard binary search tree.<br><br>7. So, and that gives usthis and reduce it to the other situation that we had before.<br><br>8. And what we do is use a function known asa hash function that takes the key that our symbol table key andreduces it to an integer, an array index, and we use that array index to storethe key and the value in an array.<br>
math|sentence cnt : 47 <br> <br>1. This is not a course on discretemathematics.<br><br>2. This is an example of a mathematical model where the problem is,is very well articulated.<br><br>3. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>4. Now, mathematicians and computer scientists have researchedthis problem in a lot of detail.<br><br>5. We do some mathematical proofs in, in thiscourse when they're critical such as this one.<br><br>6. And we point that outbecause that helps with the mathematical analysis.<br><br>7. So let's look at the analysis ofMergesort, that's a bit of math but very instructive because this really shows thepower of the divide and conquer method.<br><br>8. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br>
breaks|sentence cnt : 1 <br> <br>1. That's array implementations of stack, but it breaks the API by requiringthe client to provide the capacity.<br>
partition|sentence cnt : 99 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So the goal is socalled three way partitioning.<br><br>3. Now the 9th point well it's to the leftof 8, above 2 to the left of 8 and then corresponds toa horizontal partitioning.<br><br>4. So let's take a look at howit works with the demo its more complicated than standard Quicksortpartitioning.<br><br>5. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>6. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>7. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>8. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br>
stopped|sentence cnt : 1 <br> <br>1.Our implementation, we stopped the partitioning scans on items equal to thepartitioning item and then in that case, when all the keys are equal, it's going todivide it exactly in the middle.<br>
conclude|sentence cnt : 1 <br> <br>1. Ifwe have a value that's not in the table like K, well hash and is in position five,no, six no, seven no, eight no and we find an empty position at that point we canconclude that K is not in the table.<br>
mention|sentence cnt : 18 <br> <br>1. And I mentioned that a lot of us would get uswrong.<br><br>2. Now,the height of the tree, as I just mentioned, is the worst case number ofcompares.<br><br>3. But we mentioned this example to illustrate how even asimple algorithmah, can have interesting and complex analysis.<br><br>4. Now, there's an important consideration that we have to bring up related to the programming language, and this is a more general consideration and usually we bring into focus in algorithms but it's worthwhile mentioning.<br><br>5. As I mentionedthey're widely used.<br><br>6. So, for examplestacks and queues you can find those words mentioned in the Java library so there's aJava collection library and the so-called List interface which is displayed here.<br><br>7. So, as I've mentioned, redblack trees and B-trees are widely used as system symbol tables.<br><br>8. So, it's got position and velocityas I mentioned, and every ball has a, a radius.<br>
invariants|sentence cnt : 5 <br> <br>1. So let's, one way to understand the way that an algorithm works is tothink about invariants .<br><br>2. So the codeimplements the invariants.<br><br>3. Again, we can look at insertionsort in terms of invariants.<br><br>4. The invariants are that the entries on ontothe left of the arrow are never changed and they're in ascending order.<br><br>5. And the algorithm maintains those invariants by finding thesmallest entry to the right and exchange it with the next one.<br>
touch|sentence cnt : 16 <br> <br>1. So, that means that you could touch everything in the main memory inabout a second.<br><br>2. Number of items that have to be touchedduring quick sort.<br><br>3. And,but the problem with that quick find algorithm is that, that would taketen^18th operations, or, say array axises or touching memory.<br><br>4. So they have to touch in a constantproportional to n times after touching array entry.<br><br>5. The computers get bigger but they get faster so to toucheverything in the memory is going to take a few seconds.<br><br>6. Now this isn't exactly precisely wh at would happen in the real worldmainly because we didn't put in the simulation what happens when threeparticles are touching or there's two touching in another one hits them.<br><br>7. And what was provedby Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of Munion and find operations will touch the array at most a c (N + M lg star N) times.<br><br>8. We don't haveany, any equal lines that we have to worry about whether we consider rectangles thattouch to be intersecting, and so forth.<br>
into|sentence cnt : 145 <br> <br>1. It's going to be recursive,it's going to be based on the points, the way in which wedivide into halfplanes.<br><br>2. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>3. So,without any extra special code we insert a node into an empty tree.<br><br>4. So, with just two exchanges we insert that new element into the heap in this case.<br><br>5. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>6. I drew all the cases and, and, there's a,whether you're splitting into the middle of a 4-node or the right of a 2-node,there's just a lot of cases.<br><br>7. To push an item,we use N to index into the array, put the item there and then increment N.<br><br>8. In fact, this correspondencewith Quicksort partitioning tells us we can take that proof and prove that if youinsert in distinct keys into a BST, in random order, then the expected number ofcompares for a search and an insert is two natural log N.<br>
expands|sentence cnt : 1 <br> <br>1. It expands like binary search to handle all these convenient clientoperations in a very natural manner.<br>
requirements|sentence cnt : 4 <br> <br>1. We have two requirements, andone is that we have to be able to compute the thing efficiently ina reasonable amount of time.<br><br>2. So that kind of meets thesetwo requirements for Java.<br><br>3. How do we test if two objects are equal? So Java has got requirements as forcomparative and here's the basic requirement about equals.<br><br>4. And also no object is equal to null, so those are absolute requirements for Java.<br>
inexpensive|sentence cnt : 1 <br> <br>1. So very inexpensive and they had macros to do this so and use not too muchcost to find a partitioning element that's much closer to the middle than, and if youuse a, a random one.<br>
technology|sentence cnt : 6 <br> <br>1. Another importantreason is that if you know effect, how to effectively use algorithms and datastructures you're going to have a much better chance at interviewing for a job inthe technology industry then if you don't.<br><br>2. And, and the reason is, and theproblem is that quadratic algorithms don't scale with technology.<br><br>3. And really have enabled a new developmentsand new technology in all of these kinds of applications.<br><br>4.And that definitely enabled new progress in technology and it's a fine example ofthe importance of algorithmic technology.<br><br>5. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br><br>6. It's really an astounding example ofalgorithmic technology.<br>
listing|sentence cnt : 1 <br> <br>1. One is so-called White Listing where we want to take the words in that fileand, and then we have some other much bigger file.<br>
swim|sentence cnt : 8 <br> <br>1. That's the swim operation to eliminate violation when a key value increases.<br><br>2. We call that the swim operation.<br><br>3. We have the swim and sink functions that we showed earlier.<br><br>4. So if N is the number of items in the heap, defined to be in the heap, we're going to increment it, store our new key there and then perform the swim operation.<br><br>5. And that's just perform the swim operation.<br><br>6. So we're going to swim it up, exchange it with its parent as long as it's smaller than its parent.<br><br>7. Swims up to the top, and if we have a node at index k and we know the heap condition is violated there.<br><br>8. Or sink and swim methods are good for making this happen, but we'll delay these implementations until we need them in a more complicated algorithm.<br>
velocities|sentence cnt : 6 <br> <br>1. And then there's resolution which is to figure out how to change thevelocities of the particles according to physical laws.<br><br>2. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>3. So, you have to take both velocities and divide theirdistance by those and, and so forth.<br><br>4. We know their position and velocities shown at the bottom here and wecan predict exactly the moment, which they'll collide assuming that somethingelse doesn't happen to them in between and then so they will put that predictedcollision time on the priority queue and later on, when that time comes to pass wewill be right at moment when they collide and we can figure out what to do.<br><br>5. You got two particles, change your velocities figure out the futurecollision of those particles with the wall and update the priority queue and then themain loop is take the next thing off the priority queue and keep going.<br><br>6. But it's just a little bit of arithmetic with thevelocities and positions to deal with what happens when, when how to predict when agiven particle is going to collide with another given particle knowing theirvelocity and position.<br>
load|sentence cnt : 7 <br> <br>1.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>2. But then we have anotherstudent who had some Java before coming to us and considered himself an expert andsaid, well, I'm going to use linked list because I could use Java's library and Idon't have to worry about downloading your stupid code.<br><br>3. Eventually, you're going to get an overload of memory and you're going to have to rebuild the thing, or clean out the tombstones in some way.<br><br>4. Tells us where, which element is inposition, and then recursively sorts the last part that's loaded, J -one.<br><br>5. And if k is to the right of j, we just do the right subfiles that load the j+ one and that's all this code does is that it, we could do a recursive, arecursive call but this just does it by resetting the values of the parameters.<br><br>6. Nowadays you more likelyto do that online or when you're trying to find the song todownload, you provide the name of the song and then the value will tell youwhat computer got her to get that.<br><br>7. In particular,it's known that after you've thrown M balls into the M bins then the most loadedbin has about log M over log M balls.<br>
convinced|sentence cnt : 2 <br> <br>1. Andso, I think most students have had high school Physics and will be able to do, dothis Math or at least be convinced that the code that does this Math is correct.<br><br>2. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br>
affix|sentence cnt : 1 <br> <br>1. In this case it's a bit trickier to affix thesituation, what we do is we rotate the bottom link left.<br>
happened|sentence cnt : 15 <br> <br>1. Now, our, our original paper on red black treeswas the way the paper was laid out, it turned out that the delete implementationhappened to be placed after all the references.<br><br>2. And then,also we're going to put as the first thing that happened always a, an event that saysredraw everything.<br><br>3. And those statements can be borne out in practice,because the hash functions approximate random, the math assumes random and theformulas predict what actually happened in practice.<br><br>4. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br><br>5. And the idea is that each of thesorts can be implemented with only a few exchanges given that the previous oneshappened.<br><br>6. And then the corresponding oneis, what's the first thing that happened after that time? That's call in to theradio show, I'm going to take that caller, the first call that comes at nine:30.<br><br>7. Now,there is a possibly that something else happened to t hem in between and we'lltalk about that change, too.<br><br>8. And also, we have to update the count, something happened down below, and we use that code to update the counts in a consistent way.<br>
widely|sentence cnt : 20 <br> <br>1. This paper was veryinfluential and, and that basic method is widely used.<br><br>2. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>3. So again this time, sort of timing is whyQuicksort is so widely used.<br><br>4. This things exist but they're not sowidely applied at in practice.<br><br>5. Quicksortactually, they're up until the 1990s the most widely used implementation tookquadratic time.<br><br>6. And it's interesting to note we've looked atimportant and classic algorithms that are widely deployed but we don't have a, auseful, practical algorithms that are widely used that's got all of thesecharacteristics that's in place and stable worst case N log N.<br><br>7. And these methods are all widely used throughout ourcomputational infrastructure.<br><br>8. It was named as one of the most importantalgorithms of the twentieth century and it's widely used for system sorts and manyother applications.<br>
kenny|sentence cnt : 2 <br> <br>1. And that's difficult for Kenny to think about and difficult todrive that information from the implementation so program is just tooslow.<br><br>2. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br>
welcome|sentence cnt : 6 <br> <br>1.Welcome back.<br><br>2. Not difficult, but a definitely tricky programming exercisethat people are welcome to try.<br><br>3. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br><br>4.Welcome.<br><br>5.Welcome back to algorithms.<br><br>6.Welcome back, today we're going to talkabout balance search trees, Which will lead us to an ultimate symboltable implementation that can provide fast performance for all the simulative optionswe've looked at, guaranteed.<br>
tongues|sentence cnt : 1 <br> <br>1. With the forwards tongues of the twobefore and that were blended in after.<br>
demoted|sentence cnt : 1 <br> <br>1. And that's maybe a little bit what happens when a new boss is hired from the outside and then the two subordinates struggle to take over that position and then the boss would get demoted to it's level of competence.<br>
quicksorts|sentence cnt : 1 <br> <br>1. First thing is the inner loop is longer than Quicksorts.<br>
next|sentence cnt : 105 <br> <br>1. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>2. Like using anotherhatch function rather than looking at the next entry.<br><br>3. That's thecode that we'll look at next.<br><br>4.Plus what happens next depends on what the partitioning element was.<br><br>5. If we're not done we're supposed to return true and the next() is supposed togive the next item in the iteration.<br><br>6. Moving current to the next place.<br><br>7. So now with the iterator we have control over which order we gothrough the items and so that's going to go along with the semantics and the datastructure so probably in a stack you want to get the things in stack order like theorder that come out of the stack so that's reverse order in the array so in this casethen next() is just decrement and return the next one and our instance variable is anindex in the array.<br><br>8. So we'll, we'll come back to dealing withthat worse case in the next lecture.<br>
hybrid|sentence cnt : 2 <br> <br>1.You could make it so that the hash table itself grows once it gets really huge andsuch hybrid methods are easy to implement.<br><br>2. And you could havesome hybrid struc ture where you use something different for the internalmodel.<br>
provides|sentence cnt : 5 <br> <br>1. Rankoperation, that is essentially what binary search provides.<br><br>2. Mergesort provides, provides an upper bound, that's an algorithm that'sguaranteed to get the sort done in time proportional to N log N.<br><br>3. That's what binary search provides for us.<br><br>4. There's another facility that Javaprovides that leads to very elegant compact client code that's definitelyworthwhile to add to our basic data types and that's iteration, that's what we'regoing to talk about now.<br><br>5. Again, our symbol table API provides foran easy way to implement this.<br>
everyday|sentence cnt : 4 <br> <br>1.Now, we'll take a look at how the sortingalgorithms that we talked about or expressed in the systems that we useeveryday.<br><br>2. There's the stacks are reallyactually fundamental underlying computation because they implement ,recursion and so, you use stacks often everyday when you wrote, use the Backbutton in the Web browser, the places that you've been are saved on a stack.<br><br>3. Web search is something that weall do multiple times everyday and the key is a keyword ora list of key words and the value is a list of placeswhere that key word is found.<br><br>4. [MUSIC] And it happens everyday,right through the winter, just a couple of miles from my doorstep.<br>
iformly|sentence cnt : 8 <br> <br>1. And it's possible to prove that that produces a uniformly random permutation of the input if there's no duplicate values, assuming that you have real numbers that are generated uniformly at random.<br><br>2. It was proved actually a long time ago even before computer implementations that if you do that, you get a uniformly random permutation and it only takes linear time.<br><br>3. The way wemaintain, there's a number of ways we can maintain the thing but the one that we'lladopt un iformly because it adapts to more complicated situations is just beforewe're done with the put operation we'll say, okay we've done all our work andbefore we return the pointer to the given subtree we're going to take the size ofwhat's on the left and the size of what's on the right and add one for us and that'sgoing to be our count.<br><br>4. So idealistically, what we'd likeis to be able to take any key and uniformly scramble it toproduce a table index.<br><br>5. And every time we pick an integer between zero and i uniformly at random, and swap a of i with that integer.<br><br>6. And they're pretty uniformly distributed.<br><br>7. But, doing the whole array doesn't give you a uniformly random result.<br><br>8. There's actually a very easy way to rearrange an array so that the result is a uniformly random permutation, and only require linear time to get the job done.<br>
plus|sentence cnt : 34 <br> <br>1. And plus it goes on the operator stack.<br><br>2.Plus what happens next depends on what the partitioning element was.<br><br>3. Mid's the midpoint that divides the first part from the second, so our conditionsare that from lo to mid is sorted, and frommid plus 1 to hi is sorted.<br><br>4. If D of N is 2D of N over 2 plus N with D of1 equals 0, then D of N equals N log N.<br><br>5. The first thing to check is find out which one is bigger, it's either 2k or 2k plus one and so set J accordingly.<br><br>6. But, in linear probing, to insert what we do is when we put it inposition I if that's free, if not we just look at I plus one, and I plus two, andwrap around to the beginning if we reach the end.<br><br>7. Here's the 31x plus y ruleto combine all the fields.<br><br>8. If you're goingto implement it compared to students by section, then it'll return just thedifference of the sections which is my minus if less zero if equal then plus ifgreater.<br>
slide|sentence cnt : 12 <br> <br>1. So, the priority queue operations is the insert in delMax that we just showed in the previous slides.<br><br>2.If you're interested in implementing this, you can come back to the slide.<br><br>3. All right, so let's go back toour full implementation and this is just taking care of collectingthe code from the previous slides.<br><br>4. Figuring out whether what we have is a counterclockwise turn that's a little exercise in geometry and we'll just talk about thatbriefly in the next couple of slides.<br><br>5. You can go to books, the book site to see thelecture slides.<br><br>6. The inner class node is the code that was given on the previousslide, and then we'll need implementations of put and get, and we'll also look at animplementation of delete, and an iterator as well.<br><br>7. The andthis is the slide that, that gives the math and I won't talk through this math.<br><br>8. So, just, to simplify our code in the slides in it's off, off from thecase for geometric data processing.<br>
ceiling|sentence cnt : 7 <br> <br>1. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>2. For that is C of N over 2, ceiling of Nover 2 for the left and ceiling of, floor of Nover 2 for the right.<br><br>3. In order to get that done, we're sortingthe left half and the right half and this notation ceiling of N over 2 andfloor of N over 2 that's the N over 2 round up and N over 2 round down, that'sthe size of the two sub-arrays, and we're going to call the same routine forthat size, so the number of compares you needto.<br><br>4. So, that's a, a implementation that, that code isdefinitely tricky and a similar code for ceiling.<br><br>5. What about floor and ceiling?Well, those are a little bit more complicated and we'll have to, not quitethe same as in the ordered array for the binary search so we have to do a littlebit more work for that.<br><br>6. Floor and ceiling that's again is an outgrowthof the rank operation.<br><br>7.So this aspect of red-black BSTs is an extremely nice one because of theoperations that we implemented for regular BSTs that involves some complicated codefor floor and ceiling and rank and so forth, and we don't have to change thatcode at all.<br>
fill|sentence cnt : 19 <br> <br>1. When does all the bins fill up? That's called the couponcollector problem.<br><br>2. Where we initialize the whole grid to be block edall black and then we randomly fill in open sites.<br><br>3. Now we have four pages andnow this time the first one fills up and splits and so forth.<br><br>4. Lying in this table some pages getting anew key and eventually one of them fills up and splits.<br><br>5. And that willfill in the fields and then, we put that transaction on the priority queue.<br><br>6. We want to fill up the memory with stuffto sort and then sort it.<br><br>7. It's in it's final position and you can see down at thebottom, the large elements in the array filling in, in their final position, inthe, the left part of the array is representing the heap.<br><br>8. And so, that's thesituation as the table fills up.<br>
introduction|sentence cnt : 4 <br> <br>1.3 of the book, or in our introduction to programming andJava book.<br><br>2. If you want an in depth review, we have a full text book called, AnIntroduction to Programming in Java: An Interdisciplinary Approach.<br><br>3. Many of you probably implemented stacks inan introductory programming course, but we'll do a thorough introductionto implementations right now.<br><br>4. And that's every programmer'sfirst introduction to assignment statements.<br>
assess|sentence cnt : 2 <br> <br>1. But with that, we can properly assess the resource usage of this implementationfor different client programs.<br><br>2. Whytwo different well it's just the designer's assessment of the idea that ifa programmer is using object maybe spaces, not a, a critically importantconsideration.<br>
services|sentence cnt : 1 <br> <br>1. And, and in the real world you cannowadays find on the web particular sequences of keys that will causeparticular services to crash.<br>
satisfying|sentence cnt : 1 <br> <br>1. So that's complete binary trees represented in array with keys in the nodes, satisfying heap order property.<br>
details|sentence cnt : 18 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>2. So details but any way you can use thiscode as a model to implement equals for any data type that you might windup using as a simple table key.<br><br>3. We use the Java language, but we don'tdwell on details of Java, we mostly use it as an expository language.<br><br>4. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>5. And we will skip the details.<br><br>6. So those are detailsthat are easy to check.<br><br>7. And we're not going to test on itor even go through the details.<br><br>8. Weneed to just in terms of implementation details, our keys and values have to beobjects.<br>
choices|sentence cnt : 1 <br> <br>1. So the, the reason they used that is they thought they gotthem closer to the middle and they also don't like the, some system designersdon't like the idea of using random choices in a system method because of waythat it changes the state of the system.<br>
would|sentence cnt : 110 <br> <br>1. People buying tickets toa rock concert and I'm going to sort by location what we'd hope is that it wouldkeep the sort by time but this is a non-stable sort that doesn't do bad sothen out in the location they're going to have to resort it if they use one ofthese.<br><br>2. And then, the next phasewould be to take that heap ordered array and get, get it to be a sorted result in,in place.<br><br>3. In this case, the maximumdistance from the top to the bottom is sixteen the average is only nine and thebest you could in a perfectly balanced tree it would be seven.<br><br>4. So, then we have to go through all the particlesand change their positions on a straight line trajectory, where would they'll beafter that much time? Then we have to take the two particles that collide and changetheir velocity.<br><br>5. B and this b treewould go down the left link.<br><br>6. For files with large numbers of equal keys and that wasactually found by applications user and, and that's the standard Quicksort that wasin all the textbooks almost all the textbooks if you did not stop thepartitioning on equal keys it would run in quadratic time.<br><br>7. Because it would have N^2,calls to find, to check whether they're connected.<br><br>8. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br>
hugely|sentence cnt : 1 <br> <br>1. so how are we going to fix it? So in the end researchers showed that after a sufficiently long sequence of random inserts and the deletes, the height of the tree becomes square root of n, not log n's, spurred event is hugely bigger than a log n, it might make the difference between acceptable and unacceptable performance in real applications.<br>
dangling|sentence cnt : 1 <br> <br>1. We consider all null nodes to be black nulllinks to be black, we don't have red links dangling off, that would be incompletepre-nodes.<br>
optimize|sentence cnt : 4 <br> <br>1. If it is the case that you happen to betesting two objects that are the same object for equality, you might as welloptimize everything and just test that.<br><br>2.So this is a summary of the optimized Quicksort with cut off the small subfilesin median-of-three partitioning.<br><br>3. Actually since we copied, we couldoptimize by avoiding these moves.<br><br>4. Okay, so that's a standard, this isjust in words the standard recipe for user type optimize forreference equality check against null.<br>
apples|sentence cnt : 2 <br> <br>1. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>2. So, in this example we have two types with two stacks one of apples andone of oranges.<br>
requires|sentence cnt : 4 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2.Find operation requires a little more work.<br><br>3. That's fine, but it requires a sort, sort seems like a lot of work for this problem.<br><br>4.So what we're going to talk about to do it, is an algorithm, that actually prettyold algorithm called 2-3 trees, and a particular implementation that requiresvery little code, called left leaning red black BSTs and then we'll talk about ageneralization called B-trees.<br>
prints|sentence cnt : 3 <br> <br>1. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>2. And so the, it's the concept of so called one way hash functions whichmean that we, we, use it for secure to try to be, have some secure fingerprints foruse on the web.<br><br>3. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
combinatorial|sentence cnt : 2 <br> <br>1. And those are just examples ofclassic results from combinatorial analysis that help us understandwhat happens when we do this, which is what we're doing with hashing.<br><br>2. And these things are studied inclassical combinatorial analysis.<br>
straightforward|sentence cnt : 13 <br> <br>1. So that's very straightforward implementationof the get operation for symbol tables with a binary search tree representation.<br><br>2. And again, it's quite straightforward using the index arithmetic to move around in the heap, and that's called the sink operation because we're going down in the heap.<br><br>3. And usually that's fairly straightforward.<br><br>4. So with thesestraightforward changes at the comparator as argument to the sort and to less andmake array to be sorted array of objects, it's easy to convert any of ourimplementations to support comparators.<br><br>5.Alright, so here's the code for merging, which is quitestraightforward from the demo.<br><br>6. We'll look at couple of elementary priority queue implementationsthat are straightforward.<br><br>7. This is a straightforward modification to our sorts.<br><br>8. Now, the code for partitioning is straightforward to implement.<br>
lower|sentence cnt : 32 <br> <br>1. But they're all in that long list and you're going to have a sloweralgorithm if it's based on this.<br><br>2. That's a lower bound on the complexity of sorting.<br><br>3. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>4. If you've got a large tree and a small treeto combine together what you want to try to do is avoid putting the large treelower, that's going to lead to long tall trees.<br><br>5. Theidea of the lower bound generalizes this argument to figure out a number ofcompares that you need for a minimum to determine the ordering among N items.<br><br>6. So, we knewthat the upper bound was N log, proportional to N log N and we just provedthat the lower bound is proportional to N log N and that means that mergesort is anoptimal algorithm.<br><br>7. So, here's the basic idea for proving a lower bound forsorting.<br><br>8. In the second case,it's slower than selection sort, because it uses about the same number ofcompares, but it uses many more exchanges.<br>
decisions|sentence cnt : 1 <br> <br>1. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br>
analog|sentence cnt : 3 <br> <br>1. And manages to get the sorting job done with guaranteed analogs and compares.<br><br>2.It's about analog in.<br><br>3. But with the basic interval search tree algorithmand the sweep line process that we've talked about, you can get the orthogonal,orthogonal rectangle intersection search problem solved in time proportional toanalog N log N + R log N, where R is the number of intersections.<br>
rotations|sentence cnt : 4 <br> <br>1. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>2. We dothe standard BST insert, color the new link red, and we do the rotations that weneed, either one or two rotations to balance the temporary four node, and thenwe flip colors to pass the red link up one level and then remind me to rotate to thatto make that one lean left.<br><br>3. We flipped the colorsand now our temporary 4-node is up higher in the tree but it's not balanced so weare going to have to do two rotations to make that balanced.<br><br>4. And thenafter that rotation, or if there were no rotations at all, if the insertionhappened over here then we'd test and flip the colors.<br>
encountered|sentence cnt : 1 <br> <br>1. And so the average list length is short, this islike what we encountered with hashing.<br>
whats|sentence cnt : 1 <br> <br>1. Then there's, what's theseventh largest times, that's select that like a median, it generalizes min or max?Which key is that, happens second or seventh? So that's, order statistics, adynamic thing what happened, whats the closest time, thing that happened justbefore, five past nine.<br>
divided|sentence cnt : 6 <br> <br>1.Rearrange the terms, so we get n+1 cn-1 and then divided by n, n+1.<br><br>2. So let's, we have 2N over 2s and then for each one of these we have divided into Nover 4s and each one of those 4N over 4s has anextra cross for the merge of N over 4.<br><br>3. So, it means that we've divided the search cost which would be Nif we have a sequential search by a factor of M.<br><br>4. It's basically that distancedivided by the by the velocity.<br><br>5. Now typically, what we'd what a programmer would do is try to figure onmaking M about equal to the number of keys divided by five say.<br><br>6. But then the time, though,gets divided by M squared, your number of points, M, are spread outover the M squared different squares.<br>
frequently|sentence cnt : 3 <br> <br>1. So the challenge is to do the resizing,but somehow ensure that ithappens infrequently.<br><br>2. It'll say that the most frequent word,where there's no word that appears more frequently than it,which appears 10 times.<br><br>3. So, during this course you'll be referring tothe book site frequently while working online.<br>
threshold|sentence cnt : 4 <br> <br>1. What's that threshold value but, nobody knows thesolution to that mathematical problem.<br><br>2. And that's where we get the result that, by runningenough simulations for a big-enough n, that this, percolation threshold is about.<br><br>3. And actually, the threshold between when itpercolates and when it doesn't percolate is very sharp.<br><br>4. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br>
gone|sentence cnt : 3 <br> <br>1. And the way that it works is we are always reducingone case to another.<br><br>2. But we're only associatingone value with each index.<br><br>3. Be is gone, to is gone sothe next is not, and so forth.<br>
transactions|sentence cnt : 6 <br> <br>1. And in your list, might be kind of short, which would be thestolen cards that you know about, and you'd want to run a, a white list filterfor those cards and print out in your long list of transactions which evertransactions have that stolen cards, So, that's just a couple of examples ofexception filters.<br><br>2. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>3. So and this is just some test datawhere we've got all, all these transactions and so we are going to beable to take in data like this and again an unbounded stream of data.<br><br>4. And just a very, very huge number of transactions.<br><br>5. So our, our challenge is let's say this is on the web we havebillions of transactions, you know, and they are streaming through our data warehouseor processor in some way.<br><br>6. So we're going to look at a client program called TopM that takes thecommand-line argument, how many and this case, it's going to say five and thenit's going to take from standard input the transactions and it will print out the topfive.<br>
consist|sentence cnt : 8 <br> <br>1. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>2. We assume that the array consist of Ndistinct values there's a position created that describes the performance of anyalgorithm to compare sequence done by any algorithm to determine the N factorialdifferent orderings.<br><br>3. So, in this case, we put, with generics, we can have a type parameter onour class and that include, that's inside angle brackets in this code and then, wecan [cough] if we have a stack of apples and we tried to push an orange unto astack of apples then we're going to get a compile-time error because that's stackwas declared to only consist of, of apples.<br><br>4. And also, we have to update the count, something happened down below, and we use that code to update the counts in a consistent way.<br><br>5. So the idea is to keep a linked listwhich consists of nodes that have strings in them, and references,to the next item in the linked list.<br><br>6. And that's just a way to describethat we're going to be manipulating node objects that each consists ofa string and a reference to another node.<br><br>7. And you're also going to want to makecompareTo consistent with equals.<br><br>8. Oneconsisting of just object zero, second one objects one, four and five.<br>
abstruction|sentence cnt : 1 <br> <br>1. Now, the keys and the values caninterchange roles that's why we have the abstruction to separate them.<br>
oriented|sentence cnt : 10 <br> <br>1. And it's a good exercise in object-oriented programmingshowing how just one implementation then we can use that same implementation tosimulate a number of instances.<br><br>2. Usually, we provide two implementations: one that's max oriented, one that's min oriented so that nobody gets confused and they're the same except less and greater switch.<br><br>3. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>4. They're alloriented horizontal or vertical.<br><br>5.So say your geometric objects are points in the plane and you specify a rectanglethat's oriented with the horizontal/vertical axes.<br><br>6. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br><br>7. And we have a 2d rangeis a rectangle oriented to align with the horizontalvertical axis.<br><br>8. They have some exposure toobject oriented programming and recursion.<br>
simply|sentence cnt : 23 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2. There's a method that all Javaclasses inherit for equals, but the default implementation is simply totest whether the references are equal.<br><br>3. So it's in three space,we use a plane and do above and below, andthen simply cycle through the dimensions.<br><br>4. Now, that part of thearray to the left of i is in it's final order and we simply continue.<br><br>5. And without something like priority queues, you couldn't do thisfor a large number of particles because it would require quadratic time and simplycan't be afforded for a huge number of particles.<br><br>6. Will create a new set for that word andput that in the symbol table, and then, we simply get the set associated with the key and add the newword to that set, the new file name to that set.<br><br>7. The datastructure that we're going to use to support the algorithm is simply an integerarray indexed by object.<br><br>8. But simply can'tsupport a huge dynamic connectivity problems.<br>
collision|sentence cnt : 38 <br> <br>1. And the way we are going to that, is tomaintain a priority queue and that priority queue is going to have all thepossible collisions that could happen in the future and they're going to beprioritized by time.<br><br>2.Then we go ahead and then we could check if there's a collision, if the two balls,pieces of the two balls are occupying the same space.<br><br>3. And there's many other thingsthat you can do with this basic collision system.<br><br>4. So, what we want to do is have an easy way to dealwith collisions.<br><br>5.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>6. And there's also a variable called count, which is the number ofcollisions of particles have been involved in.<br><br>7. Now those two particles'velocities have changed , essentially that invalidates the future collisionsinvolving those.<br><br>8. That's our first collision resolution method, hashing with separatechaining.<br>
capacity|sentence cnt : 12 <br> <br>1. So we need to remove this cheat andwe will, but the code is nearly trivialif we have the capacity.<br><br>2. So, we'll build a new array of keys and we have to use an ugly cast because of generic arrays in Java, and that's where it's comparable and we need one more than the capacity to handle this thing where we don't use position zero.<br><br>3. So array resizing doesn'thappen that often, but it's a very effective way ofimplementing the stack API with an array where the client does not have toprovide the maximum capacity of the stack.<br><br>4. For simplicity, we'll show the code where the client gives the capacity of the heap.<br><br>5. Now, we're cheating in thisimplementation to keep it simple, and we'll take care of thischeat in a little while, by requiring the client to providethe capacity of the stack.<br><br>6. And if there's more items onthe stack than the capacity, we'll have to deal with that problem.<br><br>7. That's array implementations of stack, but it breaks the API by requiringthe client to provide the capacity.<br><br>8.Okay, our basic array implementationof stacks had the defect where we required clients to provide the maximumcapacity of the stack ahead of time.<br>
divine|sentence cnt : 1 <br> <br>1. And we'lllook at the next lecture of what it means the divine ordering among objects, littlemore general than what we do for sorting.<br>
crossed|sentence cnt : 2 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So we exchange itwill lt and increment both i and lt and now where the point, where the pointershave crossed i and gt across there's nothing that we haven't examined yet.<br>
rest|sentence cnt : 62 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>3. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>4. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br><br>5.Now, what's interesting about binary search trees is that there are manydifferent binary search trees that correspond to the same set of keys.<br><br>6. So then we're done, andwe found that the nearest neighbor is 5.<br><br>7. That's restoring the heap border along a path from the place where it's violated to the root.<br><br>8. Doesn't seem like we're doing much except putting stuff on stacksand now, when we come to our right parenthesis and that's when it getsinteresting.<br>
pointers|sentence cnt : 11 <br> <br>1. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>2. So we'll maintain two pointers,the first item in the queue and the tail, which is the position forthe next item to appear.<br><br>3. But this general purpose implementationstops the pointers on keys equal to the partitioning items key and we'll take alook at why that's important in a minute.<br><br>4.And you might go trough the exercise of trying to implement Quicksort withoutlooking at our code, and you'll find that testing when the pointers cross can be alittle bit tricky, particulary in the presence of duplicate keys.<br><br>5. So now our representation ofa queue with a length list, we need to maintain two pointers,references.<br><br>6. When we get to the pointers cross we breakout of the loop and exchange the partitioning element into position.<br><br>7. So we exchange itwill lt and increment both i and lt and now where the point, where the pointershave crossed i and gt across there's nothing that we haven't examined yet.<br><br>8. So what we want to do is get the array into threeparts so then now we have two pointers into the middle.<br>
components|sentence cnt : 15 <br> <br>1. Forexample in this small example here, there's three connected components.<br><br>2. And it wasactually the case that the progress of faster and faster processors with more andmore components was slowed because people were using the naive quadratic algorithmto do this design rule checking.<br><br>3. Today we're going to look at Mergesort,which is one of two classic sorting algorithms that arecritical components in the world's computationalinfrastructure.<br><br>4. The find is going to have tocheck if two objects are in the same component and the union command is goingto have to replace components containing two objects with their union.<br><br>5. Union is more difficult in order to merge the components, containingtwo given objects.<br><br>6. To merge components containing twodifferent items.<br><br>7. Our algorithms willgain efficiency by maintaining connected components and using that knowledge toefficiently answer the query that's, that they're presented with.<br><br>8. And with just changing one value in the arraywe get the two large components emerged together.<br>
involve|sentence cnt : 38 <br> <br>1. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br><br>2. And if it's array of objects,you can see that testing for equals can actually involvea lot of code and a lot of cost.<br><br>3.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>4. Now, this illustrates something that youwant to do if you have a lot of bits, you want to try to involve allthe bits somehow into hash function.<br><br>5. As we sawwhen doing the implementation, both the initialized and union operations involvedthe for-loop that go through the entire array.<br><br>6. And there's also a variable called count, which is the number ofcollisions of particles have been involved in.<br><br>7. And since sorting is an operation that'sused in so many situations, many of the standard Java types that you would expectto involve sorts will implement Comparable.<br><br>8. It's often used in embedded systems or in hardware sort type systems becausethere's so little code involved to implement it.<br>
influential|sentence cnt : 1 <br> <br>1. This paper was veryinfluential and, and that basic method is widely used.<br>
improved|sentence cnt : 3 <br> <br>1. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>2. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>3. And as I mentioned, there's been many, many improved versions ofhashing that have been studied.<br>
displacement|sentence cnt : 1 <br> <br>1. The displacement gets up to square root, of pi M over eight.<br>
spacing|sentence cnt : 1 <br> <br>1. Need spacing between certain types of wiresand, you wanted to, before you tried to make the physical circuit to do thischecking, which involved this orthogonal rectangle intersection sort.<br>
libraries|sentence cnt : 2 <br> <br>1. So this recipe works prettywell in practice and it's used in several Java's libraries.<br><br>2. So this allows us to create modular, reusable libraries of algorithms anddata structures that we can use to build more complicated algorithms anddata structures.<br>
completely|sentence cnt : 12 <br> <br>1. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>2. So that's three different clients, three completelydifferent types of data.<br><br>3. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>4. The idea is to completely separatethe interface and the implementation.<br><br>5. And this is simple and completely well defined partitioning of the plane corresponding to a binary tree.<br><br>6. Onevery smaller heap, now we continue just performing sync operations at the rootuntil we get a completely sorted array.<br><br>7. So, with one line of code, we can keep the treesalmost completely flat.<br><br>8. But there's aproblem so you would think that the system sort would be completely solid with allthis resource with all these research and all of the development that's going intoit.<br>
efficient|sentence cnt : 79 <br> <br>1. So the clustering in the data is going tomake the implementation inefficient.<br><br>2. But it won't work well unless we havean efficient symbol table operation, and we'll use this client to comparedifferent symbol table implementations.<br><br>3. But for typical data, it's very efficient.<br><br>4. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>5. And Bentley found this way toprocess it efficiently that's been widely used ever since.<br><br>6. In this case, as we'll see, ultimately we haveways to guarantee that all the operations can be formed efficiently.<br><br>7.Mergesort is not only efficient, it's also.<br><br>8.And how can we do it efficiently that is in, in log N time versus quadratic time.<br>
back|sentence cnt : 70 <br> <br>1. To merge an array, put the result back inthe first one.<br><br>2. We're not gonna try to find them all we'llget back to that in a minute.<br><br>3. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>4. And then once we have the idea that D of N equals N lg N, we can plug back into theoriginal formula.<br><br>5. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>6. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br><br>7. So we'll, we'll come back to dealing withthat worse case in the next lecture.<br><br>8. It seems strange to be ignoring parenthesis and we'll getback to that in a second.<br>
ship|sentence cnt : 4 <br> <br>1. There's a lot of detailed data and the time and maybe thewhole goal of the sort is to group them by cities so we can ship out the data foreach city, to each city and there's plenty of other examples like that in dataprocessing where we find maybe remove duplicates from a mailing list or all thejob applicants that we get, we might want to sort them by the college attendant.<br><br>2. And just the guiding principal ingood modular programming is that we should welcome compile-time errors and avoidrun-time errors because if we can detect an error at compile-time, then we can shipour product or deploy our implementation our implementation of an API and have someconfident that it's going to work for any client whereas, the error is not going toget discovered until run-time it might occur with some client development.<br><br>3. Bad programmers worryabout the code, good programmers worry about data structures, and theirrelationships.<br><br>4. And then with that, simple, relationship wecan use the exactly the code that we developed to go ahead and run a simulationfor this connectivity problem.<br>
earliest|sentence cnt : 1 <br> <br>1. Like, forexample, what's the earliest time? That's the min or what's the latest time? That'sthe max.<br>
repeated|sentence cnt : 1 <br> <br>1. So the well-known technique fordoing that, called repeated doubling,is to, when the array fills up, create a new array of twice the size andcopy all the items over.<br>
arrange|sentence cnt : 14 <br> <br>1. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>2.sort is a method that takes anarray a as its parameter and it, it's the first argument and it rearranges thestrings in that array to be in sorted order.<br><br>3. And an experienced programmers know thisand it's not difficult to arrange for the natural types of data that peopleare going to use for symbol table keys.<br><br>4.Rearrange the terms, so we get n+1 cn-1 and then divided by n, n+1.<br><br>5. So what we have to do first is to rearrange the keys in the array to heaporder it.<br><br>6.Once we have it arranged in that way, then we recursively sort the two parts.<br><br>7. For example,if they're all arranged in a circle and your query point's in the center orsomething of that sort.<br><br>8. Howdo we arrange to do something is natural as this in our Java sorts? Now, we use thefourth in order to be able to implement sorts that can sort any type of data, weuse Java's Comparable interface.<br>
basic|sentence cnt : 65 <br> <br>1. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>2. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>3. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>4. This paper was veryinfluential and, and that basic method is widely used.<br><br>5. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>6. We encapsulate them in basicdata types like these.<br><br>7. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>8. And there's many other thingsthat you can do with this basic collision system.<br>
removing|sentence cnt : 3 <br> <br>1. The key is, when it comes to removingan item, which item do we remove? The two fundamental classic datastructures for this, the stack and the queue, differ in the way in whichthe item to be removed is chosen.<br><br>2.But the advantage of that might be that removing the maximum is easy.<br><br>3. And we'll see later on, there's times when we want to expand the API and provide other operations like removing an arbitrary item from the priority queue, or give the client in the API the capability of changing the priority of an item.<br>
defined|sentence cnt : 10 <br> <br>1. Suppose you have a robot that wants to get from s to t andthere's an obstacle that's defined by some polygon.<br><br>2. So when we have these types ofdata structures and data types that are precisely defined, like stacksand queues and so forth, what we want to do is completely separate the detailsof the implementation from the client.<br><br>3. And this is simple and completely well defined partitioning of the plane corresponding to a binary tree.<br><br>4. In fact we can analyze the running time mathematicallyand show that defined operation, it takes time proportional to how far down thetrees are in the node in the tree, the nodes are in the tree, but we can showthat it's guaranteed that the depth of any node in the tree is at most the logarithmto the base two of N.<br><br>5. So if N is the number of items in the heap, defined to be in the heap, we're going to increment it, store our new key there and then perform the swim operation.<br><br>6. Re-arrange an array of n items into ascending orderaccording to a defined key which is part of the item.<br><br>7.That is the word that we defined, for 2-nodes and 3-nodes, and we also have theperfect balance.<br><br>8. Points are defined data type for geometric objects and so what weneed is code that will compute the polar angle and use that as the basis forcomparison.<br>
techniques|sentence cnt : 4 <br> <br>1.To finish up, we're going to look at therectangle intersection problem that's got important practical applications and, usesthe techniques that we've been studying so far.<br><br>2. Or using either one of those techniquesyou could just get the idea that D of N is close to Log N or you can write a programto expand the recurrence and find that.<br><br>3. Now there's a, a number of practicalimprovements that we can use to make Mergesort even more efficientthan the simple one that we've looked at and we'll take a lookof those because they're examples of techniquesthat we can use for other algorithms.<br><br>4. So these are mathematical formulas andthere's techniques for solving them and we won't go intothat.<br>
pushing|sentence cnt : 1 <br> <br>1. And number two, that every time youresize, you've already paid for it in an amortized sense by inserting,pushing or popping.<br>
intersect|sentence cnt : 73 <br> <br>1. And now 2123 does intersect 1622, so wereturn and intersection.<br><br>2. Any interval thatintersects this query interval 23 25.<br><br>3. And withthat 1D range search, implementation, we get an efficient N log N, 2D orthogonal,orthogonal line segment, intersection.<br><br>4. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>5. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>6. Just check for anintersection, if we find it ret urn if left is no we go right.<br><br>7. So lets look at it if there is no intersection in theleft, since we went to the left and then we have got, low less than max.<br><br>8. Try to find any interval that intersects our queryinterval.<br>
that|sentence cnt : 2299 <br> <br>1. Now we'llmove over to the T and again, that's the root of a three node heap that's heapordered except at the root.<br><br>2. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>3.That's a complete implementation of Quicksort.<br><br>4. That way, we leave a of zero empty.<br><br>5. So that'sour parameter M - that's the number we can afford to store but the total number ofitems we couldn't possibly afford to store them.<br><br>6. That's the most recently added item.<br><br>7. So, at that point the right point ofa horizontal line segment we just remove it because we've processed that linecompletely.<br><br>8. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br>
somewhat|sentence cnt : 5 <br> <br>1. He worked with Doug McIlroy and they wrote a,a, a paper that outline this problem and talk about some of these things and theyhad a three-way partitioning method that was somewhat like the Dijkstra method thatwe showed but a bit more complicated.<br><br>2. This is a somewhat detailed mathematicalderivation, but it is worthwhile going through the steps, to really get a feelingfor why it is that, Quicksort is quick.<br><br>3. And that brings it down somewhat andallows us to keep the tables more full.<br><br>4. You may be somewhat familiar with these, but today we're going to takea careful and close look at them.<br><br>5. But in practice this is something thatstill we have to worry about somewhat.<br>
took|sentence cnt : 8 <br> <br>1. Now that heap is a seven node heap that's all heap ordered, and then the lastthing is to do the root of the whole thing and again, now the two sub trees are heapordered, that's what we mean by bottom up, we took care of the heep ordering from thebottom up.<br><br>2. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br><br>3. And so, I'll just use thatone and pick an index at random and delete and that program took quadratic time andpoor Kenny, when trying to run his program for the huge instance that we asked foundout that it wasn't finishing.<br><br>4. Quicksortactually, they're up until the 1990s the most widely used implementation tookquadratic time.<br><br>5. And rememberwe took some pains to think about the recursive implementation where when we godown a link we replace that link by whatever the recursive routine gives usback and that strategy is going to pay off in giving us a really simple code.<br><br>6. We took two sorted subarrays and we talkedabout an abstract in place merge but we didn't have anactual in place merge.<br><br>7. So in summary, we took animportant problem.<br><br>8. So when we decrement that value N, there's still a pointer to the thing thatwe took off the stack in that array.<br>
percentage|sentence cnt : 1 <br> <br>1. And we can showthat the vacancy percentage at the time that it percolates is an estimate of thisthreshold value.<br>
inserting|sentence cnt : 25 <br> <br>1.Suppose we're inserting K.<br><br>2. So, inserting the first N itemswould take time proportional, if the stack's of size N-1,it's going to take time N, N-2, time N-1.<br><br>3. So if you just calculate the costof inserting the first N items, you're going to have instead of the sumof the integers from to 1 to N, you're going to have the sum ofthe powers of 2 from 1 to N.<br><br>4. Why? Well, we can start with a heap, by inserting all the elements and then deleting the maximum and getting a sort done and that would be linear time if we had this kind of variation, If we had Constantine's operations for both uncertain delMax.<br><br>5. And that's to distinguish thoselinks from the other links in the binary tree so that we can tell when we'reinserting things which nodes belong to tree nodes and which ones don't.<br><br>6. So, that's inserting to a tree with the one node and make it a tree withtwo nodes.<br><br>7. So let's look at just inserting A into this B tree.<br><br>8. Really often what we're doing is just inserting items into a collectionand then, later on, iterating through the items that we have.<br>
improve|sentence cnt : 21 <br> <br>1. Now, experts have worked to come up with improvements on this and there are slight improvements possible.<br><br>2. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br><br>3. And its thefastest and most useful in practice particularly if you make improvements todeal with duplicate keys.<br><br>4. And in this case, it's very easy to improve it much, much more.<br><br>5.So, that's a first improvement.<br><br>6. So, that means that the running time ofweighted quick union with path compression is going be linear in the real world andactually could be improved to even a more interesting function called the Ackermannfunction, which is even more slowly growing than lg<i>.<br><br>7. A very effective improvement, it's calledweighting.<br><br>8. Now, this was very easy to implement and, and we could stopbut usually, what happens in the design of algorithms is now that we understand whatit is that gains performance, we take a look and see, well, could we improve iteven further.<br>
heavy|sentence cnt : 1 <br> <br>1. So,ours will have mass, so there will be some big heavy ones that make things moreinteresting.<br>
feeds|sentence cnt : 1 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br>
alpha|sentence cnt : 8 <br> <br>1. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>2. One myse alpha is forthe hit, one myse alpha for the squared for the insert.<br><br>3.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br><br>4. Like theintegers or natural numbers or real numbers or alphabetical order for strings,chronological order for dates or times and so forth.<br><br>5. Now as alpha gets close toone, you can see these things are going to grow, and particularly the search miss isgrowing to grow quite, quite a bit.<br><br>6. If it's 9/10's full one over one minus alphasquared is 100 one over 100, so it means it's going to be 50 p robes for a searchmiss if it's 9/10's full, and that's independent of N and M, whereas if it'shalf full then we get the nice.<br><br>7. So[cough] here is just an example of what happens if would those implementedcomparators for that class student using the Java system sort, if you call arraythat sort with your a rray of students and you give it this by name comparator, itwill put them in order alphabetical order by the name field.<br><br>8. WhatCanute's theorem says is that under the uniform hashing assumption, the number ofprobes in the linear hash table size M, that is alpha percent full, so the numberof keys is a fraction of M, is for a search miss half one plus one over alpha,and a search miss one plus one over one minus alpha squared.<br>
rarely|sentence cnt : 1 <br> <br>1. And again the default implementation is tocheck whether we refer to the same object and that's rarely what we want,Java system's programs may be want that.<br>
complex|sentence cnt : 14 <br> <br>1.So complexity's going to tell us that it's a quadratic algorithm if that's what itsworst case is.<br><br>2. It's a complex dynamic situation that is better understoodthrough computer simulation.<br><br>3. That's a lower bound on the complexity of sorting.<br><br>4. And the idea is to use three simple rules, you get something very close tothis complex flocking behavior.<br><br>5. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br><br>6. But we mentioned this example to illustrate how even asimple algorithmah, can have interesting and complex analysis.<br><br>7. so, with the, more [COUGH] complex userinterface, this is, very much what the spotlight or find functionon your computer is doing.<br><br>8.with mergesort is a good opportunity totake a look at the intrinsic difficulty in the sorting problem, now that is calledcomplexiting and we'll look at that next.<br>
fast|sentence cnt : 56 <br> <br>1. And where we don't need ordered iteration or any of theordered symbol table operations because it has really fast access to the symboltable.<br><br>2. You might have anew computer that's ten times as fast but you could address a problem that's tentimes as big.<br><br>3. Just put them in anarray, and then, well, insertion is, is fast.<br><br>4. And the question is, can we do better? Can we have a faster way to shuffle? Do we really need to pay the cost of a full sort? The answer to that question is, no.<br><br>5. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>6. If I want that guarantee, if I want to besure that every operation's going to be fast, I'll use a linked list.<br><br>7. In many cases, the first algorithm we come up with would befast enough and maybe it fits in memory and, we'll go ahead and use it, and be offand running.<br><br>8. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br>
restricted|sentence cnt : 2 <br> <br>1. Well, it's like in a Javaarray of integers say, our keys in that case are indexes that arerestricted between zero and array size.<br><br>2. But nowadays that's restricted to justa few implementations like stack and queue anda few other fundamental data structures.<br>
indexes|sentence cnt : 1 <br> <br>1. Well, it's like in a Javaarray of integers say, our keys in that case are indexes that arerestricted between zero and array size.<br>
definition|sentence cnt : 13 <br> <br>1. And this one, by definition,doesn't provide that.<br><br>2. So that's thedefinition of a binary tree.<br><br>3. And follow the link corresponding to theinterval that we know must contain the search key by definition of the tree andthen we recursively continue the search.<br><br>4. That's our definition of what a priorityqueue is.<br><br>5.count,which is the number of nodes in that, in that subtree by definition.<br><br>6. It's a convexpolygon that encloses the points whose vertices points in the set and those areall equivalent definitions.<br><br>7. So, as I mentioned, the symmetric order ispart of the definition of a 2-3 tree.<br><br>8. With the natural order, we had to put the definitioncompared to within the data type.<br>
saves|sentence cnt : 1 <br> <br>1. And it's effective, it means you don'thave to actually move items, and that saves a little bit oftime.<br>
organizing|sentence cnt : 1 <br> <br>1. Many obvious out applications like or, organizing yourmusic library or displaying your search results or listening feeds in your in yourweb browsers.<br>
double|sentence cnt : 22 <br> <br>1. And the reason is that you only createa new array every time it doubles.<br><br>2. The first one is the size of the subarray and this loop getsexecuted on a log N times because each time we double the size of the subarray untilwe get to N.<br><br>3. Typical implementations ofred-black trees that do not use this recursive strategy wind u p having lots ofcases depending on whether left or right or double rotate to the left or doublerotate to the right can be critical of this code because my own was this way forthe first three editions of the book.<br><br>4. Then our value stack is doubled so that's the same stack code but withgenerics, we're using, using two different types of data.<br><br>5. Doublehashing is the variant of layer probing where you just skip a variable amount, notone each time.<br><br>6. So, let's look at a double split likethat.<br><br>7. And you can see at the beginning,it doubles from one to two to four, but once it gets to four, it stays, once itgets to eight, it stays at that size for awhile even thoughthere's some operations.<br><br>8. So how about implementing a hash code forour own type of data? And so our transaction type might have a couple of instance variables,a string, a date, and a double.<br>
handled|sentence cnt : 3 <br> <br>1. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>2.And again, when there's a lot of equal keys then there's going to be place whereone of those is chosen, it's partitioning element then a big chunk of the array getshandled just in a partitioning process.<br><br>3. Again, another common function that'seasily handled by symbol tables.<br>
arbitrary|sentence cnt : 5 <br> <br>1. And then, we talked aboutrandomized queue or bag where we might remove a random or an arbitrary item.<br><br>2. So all that means is we start with an array in arbitrary order and then we'regoing to work from the bottom up to make sure that it's heap order.<br><br>3. And since as with stack and queue operations, theseinsert and deletes might be intermixed in arbitrary ways and there might be hugenumbers of them either one of these is very attractive because they're going totake N times the number of operations.<br><br>4. Sothat's the first piece of code for heap ordering an array with arbitrary valuesand then these diagrams summarize the sync calls that, that we just went through inthe demo starting at five, four, three, two, one.<br><br>5. And we'll see later on, there's times when we want to expand the API and provide other operations like removing an arbitrary item from the priority queue, or give the client in the API the capability of changing the priority of an item.<br>
definitely|sentence cnt : 21 <br> <br>1. And what's worse is, the recursive natureof the sort definitely means that there's going to be lots ofsubarrays to be sorted.<br><br>2. Sothat's the key is to be able to have client code that is so compact foriterating through items in the data structure so we're going to provideiteration for all our basic data structures and it's not too hard to dodefinitely worthwhile the effort.<br><br>3. So thesearches is definitely more complicated and kind of mysterious, but let's look atthe rules for search in an interval search tree.<br><br>4. Andthat's definitely something to worry about.<br><br>5. If the probability is high and there is a lot of open sides, itdefinitely is going to percolate.<br><br>6. And it's definitelyan instructive exercise to check that you believe that, that method works.<br><br>7. So, that's definitely a way to get a deck shuffled quite easily, easy to implement.<br><br>8. Now,usually it's going to be good enough but it's definitely worth while to understandwhat's going on with different sorting algorithms in order to even find improvedperformance over the system sort.<br>
diagrams|sentence cnt : 4 <br> <br>1.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>2. Sothat's the first piece of code for heap ordering an array with arbitrary valuesand then these diagrams summarize the sync calls that, that we just went through inthe demo starting at five, four, three, two, one.<br><br>3.And these diagrams summarize the sync operations that we showed in the demo.<br><br>4. So as I've mentioned and this diagramshows, the splitting of 4-node and a 2-3 tree is a local transformation.<br>
thing|sentence cnt : 340 <br> <br>1. So what do we do to get lookup CSV implemented? Well, first thing is toset up the input stream from the first argument, so that's our input file.<br><br>2. Now increment i, stop at the l which isgreater than k decrement j stop at the e which is less than k and now at this pointthe partitioning process is complete, coomplete cause the pointers have crossedand we have looked at everything in the array.<br><br>3. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>4. These types of things ariseoften in practical applications.<br><br>5. So let's look at the beginning, we don't do anything, we just swap it with itself.<br><br>6. So, suppose you have a deck of cards, one of the things that you might want to try to do is to simply rearrange those cards into random order, that's called shuffling.<br><br>7. It's always refers tosomething that's nearby something else that I just referred to.<br><br>8. And then the last thing we need to do isjust return the item that we saved away.<br>
treats|sentence cnt : 1 <br> <br>1. So it treats it as a base 31 number.<br>
scan|sentence cnt : 21 <br> <br>1. That's what we needed for the Graham scan algorithm forthe convex hull.<br><br>2. Our pointer still scansfrom left to right, but now the elements to the leftof the pointer, including it, are in order, but the elements tothe right have not yet been seen at all.<br><br>3.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>4. And that method is the basis for the Graham Scan.<br><br>5. And the algorithm that we're going to look at, called the Grahamscan is based on those two facts.<br><br>6. And then thenext lecture again we'll look at ways to define different orderings among pointsand Graham scan is a perfect example.<br><br>7. Or you could do it in a linkedlist, and then when it's time to find the, remove the maximum, you have to scanthrough everything to find the maximum.<br><br>8. So, for the selection sort, we have a pointer that wasour variable i, that scans from left to right.<br>
geometric|sentence cnt : 26 <br> <br>1. Many of theseproblems are the basis for geometric processing of huge amounts of data that wesee all over the web.<br><br>2. So again, the geometric interpretationis the keys are points in the plane.<br><br>3. So, there's alot of geometric properties of the convex hull that we can take advantage of todevelop an algorithm.<br><br>4. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>5. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br><br>6. So rest assured these types ofalgorithms lie at the heart of any program you use that isinvolving a lot of geometric data.<br><br>7. Today, we're gonna take alook at a number of interesting applications of symbol tables and thebinary search tree data structure to address problems with processing geometricdata.<br><br>8. Now, in geometric interpretation, we just thinkthat the keys as points on a line.<br>
extra|sentence cnt : 46 <br> <br>1. You have extra space for the links to implement the link lists butthe rest of the table is not much extra space.<br><br>2.That's going to be a constant extra cost.<br><br>3. So,without any extra special code we insert a node into an empty tree.<br><br>4. But we have to use a little extra time andspace to deal with the links.<br><br>5. That is, we need that extra auxiliaryarray for the last merge.<br><br>6. So we have to do a few extra passes to dothe higher sorts but the each element moves only a little bit on each path andthat's how Shellsort gains its efficiency.<br><br>7. But there's plenty of applicationswhere the extra speed for search and insert that we canget this way is worthwhile.<br><br>8. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br>
particular|sentence cnt : 30 <br> <br>1. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>2. Tukey is a statistician and hehad this particular method for order statistics that has some interestingproperties and use that for the partitioning element.<br><br>3. Any particular value happens withprobability one over n, and if it's k, then the left subfile has k - one items init, and the right subfile has n - k items in it.<br><br>4. In particular if you just haveN union commands on N objects which is not unreasonable.<br><br>5. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>6. In particular,all Java classes inherit a method called hash code which is returnsa 32-bit int value.<br><br>7. And this is very,very typical in geometric data, particularly in higher dimensional data,as we'll see in a minute.<br><br>8. Anadversary can learn your hash function and just send you data that causes hugeperformance problem by just making all that data hash to one particular item.<br>
correct|sentence cnt : 8 <br> <br>1. Andso, I think most students have had high school Physics and will be able to do, dothis Math or at least be convinced that the code that does this Math is correct.<br><br>2.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>3.>> Does that help you with the ladies? >> So not only is there some excitement inthat dialogue but it's also technically correct which you don't often find withmath in popular culture of computer science.<br><br>4. We can have more confidence that our priority queue operations are going to work correctly, if we know that the type of data that's on the property queue is immutable.<br><br>5. He was reallyinterested in analyzing correctness of programs and showing that this how youcould convince yourself that this program was operating as expected.<br><br>6. If you have a sort method that can store anyvalues in an array, it could, for example, store zeros in every array entry thatmethod would pass this test, but it didn't really correctly sort the array becauseoverwrote all the values.<br><br>7. We know the two three node heapsthat are the children are heap ordered but we may have to correct the heap orderingat the root so we do a sync on two.<br><br>8.That's pretty simple code, the question is, if you have a sorting algorithm thatpasses that test, are you sure that it correctly sorted the array? Well theanswer to that question is, yes if, yes if you used only the less() and exchange()methods to implement, to refer the data because then you know because you used theexchange() method that the data in the array after the sort is the same data as was inthe array before the sort, sort.<br>
caching|sentence cnt : 2 <br> <br>1. That the references tomemory are all over the place when it's a huge array, so it's not a good algorithmfor a situation where there's caching which is almost everywhere nowadays.<br><br>2. And also it'llperform better for huge tables whereas caching is involved.<br>
chronological|sentence cnt : 1 <br> <br>1. Like theintegers or natural numbers or real numbers or alphabetical order for strings,chronological order for dates or times and so forth.<br>
advanced|sentence cnt : 7 <br> <br>1. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>2. And we'll look at moreadvanced versions of these problems when we want to study hashing.<br><br>3. We do somemath, but not advanced math.<br><br>4. The second part of the course isfor more advanced algorithms including graph algorithms, classic graph searchingalgorithms, minimum spanning tree and shortest path algorithms, algorithms forprocessing strings including regular expressions and data compression.<br><br>5. These are so simple that wewon't go in too much detail, but still it's worthwhile to takea look at them to set the stage for the more advanced implementationswe'll consider next.<br><br>6. There's an advanced data structure called a Fibonacci heap, where inserts are done in constant time and delete max done in log N time, on average over all the operations.<br><br>7. Next, we'll look at more advanced ones.<br>
wild|sentence cnt : 2 <br> <br>1.Actually, some implementations of Quick Sort out in the wild don't have thisproperty, and they suffer a little bit in performance.<br><br>2. There's this one wild loop that we have to worryabout a little bit.<br>
databases|sentence cnt : 5 <br> <br>1.Those are remarkably small numbers, so we're going to have guaranteedperformance, even for huge databases, We're going to be able to guarantee thatwe can get search and insert them with just eighteen to 30 operations and it'squite remarkable, really.<br><br>2. And this is a very common operation, say, in databases.<br><br>3. And even if it's not points in the plane,just databases.<br><br>4. Or fordatabases with large number of dimensions, you could do even muchhigher dimensional data and find nearest neighbors anddo range searching extremely efficiently.<br><br>5. In mostdatabases, nowadays that, that you might use.<br>
relation|sentence cnt : 7 <br> <br>1. And the way to prove this proposition isto from examining the code, to write down what'scalled a recurrence relation.<br><br>2. So we assume that is connectedto is an equivalence relation.<br><br>3. So what we do is, as we did for MergeSort, is write down a mathematical recurrence relation that corresponds towhat the program does.<br><br>4. S that means that, in mathematical terms,equals is called an equivalence relation.<br><br>5. Bad programmers worryabout the code, good programmers worry about data structures, and theirrelationships.<br><br>6. And then with that, simple, relationship wecan use the exactly the code that we developed to go ahead and run a simulationfor this connectivity problem.<br><br>7. When we have an equivalence relationa set of objects and connections divide into subsets called connected components.<br>
perform|sentence cnt : 84 <br> <br>1. And how close it could get to full withoutsacrificing performance.<br><br>2. That, if that assumption doesn't hold and you getbad performance you're going to have disastrous consequences.<br><br>3. At leastthat some indication that you understand the performance characteristics.<br><br>4. [cough] Alright, so now, there's a couple of elementary operationsthat we have to perform on red-black trees, called rotations.<br><br>5. For detailed information ona performance, eval grievance.<br><br>6. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>7. And that has profound impact on theperformance of this algorithm.<br><br>8. We took a look at the last time at thebinary search tree, Which if things are well modeled by randomexertions, have a great performance.<br>
chaining|sentence cnt : 7 <br> <br>1. And so the first way we'll look at is called Separate Chainingand it's a very diagonal idea back1953, and the idea is just build a link list foreach of the table positions.<br><br>2.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>3. That's our first collision resolution method, hashing with separatechaining.<br><br>4. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>5. So we'll look at hash functions,separate chaining and then two collision resolution methods called separatechaining and linear probing.<br><br>6. So that brings us to this summary where red-blacktrees, we were happy with a log based two of N for search and insert with separatechaining, you can really get it down to a constant number of operations for searchand insert.<br><br>7. So the bottom line isseparate chaining versus linear probin collision resolution message methods.<br>
insert|sentence cnt : 235 <br> <br>1.And so the end result is that a search or an insertion in a B-tree in a order m,that's where we're putting M keys per page, requires between log base M - 1N andlog.<br><br>2. So to insert N items,it's about three array accesses.<br><br>3. So, for example if we insert h in to this treehere, it comes off as the left link of R so that gives us a temporary four nodethat's not balanced so we need to rotate the link from S to the right and thatgives us now temporary four node that is balanced and again, these are all localtransformation it's not changing the rest of the tree.<br><br>4. So,without any extra special code we insert a node into an empty tree.<br><br>5.Suppose we're inserting K.<br><br>6. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>7. Just put them in anarray, and then, well, insertion is, is fast.<br><br>8. So, with just two exchanges we insert that new element into the heap in this case.<br>
interviewing|sentence cnt : 1 <br> <br>1. Another importantreason is that if you know effect, how to effectively use algorithms and datastructures you're going to have a much better chance at interviewing for a job inthe technology industry then if you don't.<br>
appropriate|sentence cnt : 7 <br> <br>1.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>2. But it's only going to be fast, ifthe, table size is set appropriately.<br><br>3. So there is going tobe situations that are going to require an understanding of what it takes to engineera, a sort method that's appropriate for your application.<br><br>4. Solve a problem by dividing it into two halves, solvingthe two halves, and then putting the solutions together toget the appropriate answer.<br><br>5. And just leaving empty positions around, in a hash table, orusing links in a link list, did not seem like an appropriate use of space.<br><br>6. [cough] now we're going to use these to implement symbol tables andthere's values associated with each key when appropriate, we'll write the valuesin smaller numbers next to the keys.<br><br>7. It also allows us to focus onperformance when appropriate.<br>
developed|sentence cnt : 10 <br> <br>1. And thensome advanced algorithms that make use of the basic algorithms that we developedearlier in the course.<br><br>2. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>3. We have a full scientific understanding ofthe properties of these algorithms, andthey've been developed as practical system sorts and applicationsorts that have been heavily used over the past 50years.<br><br>4. So people have developed all differentkinds of methods for adapting in this way.<br><br>5. This is a publishing model that Kevin Wayne and I developed and have beenusing for many years, and we think it's a very effective way to support the, kindsof lectures that we're going to be giving in this course.<br><br>6. This is our online course Algorithms developed bymyself and Kevin Wayne here at Princeton.<br><br>7. We've lookedat lot of sorting algorithms and actually, there's hundreds of sorting algorithms outthere and we have chosen the most important and the most interesting for youbut you could literally spend a year reading all the papers on sorting and thenyou still continue to be invented new algorithms are developed and that arefound to have good characteristics all the time.<br><br>8. And then with that, simple, relationship wecan use the exactly the code that we developed to go ahead and run a simulationfor this connectivity problem.<br>
program|sentence cnt : 100 <br> <br>1. We're assuming that people who take this course know how to program,and know the basics of loops, arrays, functions.<br><br>2.3 of the book, or in our introduction to programming andJava book.<br><br>3. Now, which shouldthe output of such a program, such a method be? Well, in order to be able towork with the result, it should be a sequence of vertices that gives us thatpolygon if we follow it.<br><br>4.You can use your own programming environment if your comfortable with oneor you download ours.<br><br>5. And that's difficult for Kenny to think about and difficult todrive that information from the implementation so program is just tooslow.<br><br>6." And many programmers live by that kind of preset.<br><br>7. Butinexperienced programmers often have trouble with it.<br><br>8. NiklausWirth, another pioneer in computer science, wrote a famous book calledAlgorithms + Data Structures = Programs.<br>
making|sentence cnt : 17 <br> <br>1.And making that, 4-node into two 2-nodes and adjusting the lengths appropriately.<br><br>2. So, since we're making array ofnodes, a node would have generics if we use to key in value.<br><br>3.So the transformation that splits that b, c, d, node and inserts the C into the3-node at the root, just involves, making that 3-node into a temporary 4-node.<br><br>4.Now with this code, we're also introducing the idea of makingassertions just to make it easier to debug our code and to haveconfidence that it's correct.<br><br>5. Anadversary can learn your hash function and just send you data that causes hugeperformance problem by just making all that data hash to one particular item.<br><br>6. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>7. What we'll do is we'll keep track of the number of objects in eachtree and then, we'll maintain balance by always making sure that we link the rootof the smaller tree to the root of the larger tree.<br><br>8.You didn't want to have any bugs when you're making a chip.<br>
puts|sentence cnt : 9 <br> <br>1. So insert() just puts it at the end, and sinceits unordered delete maximum has to go through the entire array to try to findthe maximum when it refines it and the changes that we're the one at the end andthen removes it the same way that we do within the stack.<br><br>2. If they key's not there,it puts a new entry in.<br><br>3. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>4. First, it puts all the ones to theleft on the queue.<br><br>5. And then there are many applications where randominputs are fine model.<br><br>6. So that puts B at the root.<br><br>7. And that uses apush down stack for the hull, it puts the points on the hull in it goes ahead andfor every point considering I'm in the order of the polar sort it'll comparewhether the top two points on the hull and the new point implement a CCW turn or not.<br><br>8. And to believe this method, you just have to think recursivelyand prove by induction that this in order method puts all the keys in the datastructure on the queue in their natural order.<br>
language|sentence cnt : 21 <br> <br>1. Differentlanguages have different mechanisms.<br><br>2. We might want to use the natural alphabetic order or we mightwant to make it case insensitive or maybe there is just different languages thathave different rules of the ordering.<br><br>3. And actually that's on the road to developing a compiler or a way totranslate a, a program from a programming language to a computation, soDijkstra's algorithm that uses stack is one way for entering and understanding ofthe basis of computation.<br><br>4. That's the shortcut in manyprogramming languages nowadays for use the index and then increment it.<br><br>5. It's a little bit of programming language detailed but it's,it's really worthwhile because it allows us to use the sorts that we developed forany type of data in a type safe manner.<br><br>6. There's a lot of different ways toimplement callbacks and that's programming language specific.<br><br>7. We use the Java language, but we don'tdwell on details of Java, we mostly use it as an expository language.<br><br>8. So the Javalanguage for that is in the class header.<br>
fibonacci|sentence cnt : 1 <br> <br>1. There's an advanced data structure called a Fibonacci heap, where inserts are done in constant time and delete max done in log N time, on average over all the operations.<br>
third|sentence cnt : 12 <br> <br>1. In the third case now,when i is at the third entry in the array, now we start a index j, andwe move that starting at i to the left.<br><br>2. Now, we have to look at the third case, which is, when it's, thenew node inserted this in between and comes out of this link here.<br><br>3. And then the third kind ofevent is what happens when we hit a vertical line segment? Well, in that caseall we want, need to do is just do a range search, for the interval of y end points.<br><br>4. But it might be the case thatthere's a third particle that knocks one of those out before that thing happens andthat event would be invalidated.<br><br>5. And third onethe other four objects.<br><br>6. Maybe the third line there is the final grade.<br><br>7.So, if we call this client with second argument zero and third argument one, thatmeans we want to use the URL field zero on the CSV file as the key, no one use the IPaddress that's field one in the CSV as the value, you want to associate keys withvalues.<br><br>8. Similar, if our third point comeson the left, again, we'll partition according to the horizontal linethrough that point on the left.<br>
leaves|sentence cnt : 6 <br> <br>1. So, this three has to have at least N factorial leaves and ifthe three of height h, it has utmost two^h leaves.<br><br>2. So, an h-sorted array is h different inter leaves sortedsub-sequences so in this case with h=4 if we start at L and look at everyfourth element - M, P, T - then it's sorted.<br><br>3. The only, the, the tree that hasthe most leaves of height h is totally complete and that one has two^h leaves.<br><br>4. Two^h has to be greater than orequal to the number of leaves.<br><br>5.This sum, minus the same sum for N - one, just leaves the 2CN - one.<br><br>6. And the number of leaves has to be greater orequal to N factorial so that implies the height of the tree has to be greater thanor equal to log base two(N) factorial which is proportional to N log N byStirling's formula.<br>
refuse|sentence cnt : 1 <br> <br>1. And that's why so manysystem programs refuse that.<br>
empty|sentence cnt : 60 <br> <br>1. That way, we leave a of zero empty.<br><br>2.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>3. So,without any extra special code we insert a node into an empty tree.<br><br>4. And so what the test client'sgoing to do is going to just go in the loop as long asstandard in is not empty.<br><br>5. But also taking care of specialcases when the queue is empty.<br><br>6. Iwant to be able to create an empty set, we've got methods to add a key to the set,and to check whether a given key is in the set or not.<br><br>7. So in order to look at every place in the table where L could be, we have tokeep looking til we found an empty table position, or we find L itself.<br><br>8. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br>
strictly|sentence cnt : 1 <br> <br>1. So [cough] so, for example whatabout one-dimensional range counting? Well, what we're going to do is just keepthe keys in a binary search tree and we looked at the implementation of the rankfunction for binary search trees where for every key, we can compute how many keysare there that are strictly less than that key.<br>
blocks|sentence cnt : 1 <br> <br>1. Where, we work with continuous blocks of data that are big.<br>
died|sentence cnt : 8 <br> <br>1. In this one of many different algorithmsthat have been studied for this.<br><br>2. And these things are studied inclassical combinatorial analysis.<br><br>3. Now this was studied in detail by Knauf, DonKnauf, in the 1960's and actually this problem, Knauf says, was the origin of theorigin of analysis of algorithms.<br><br>4. [COUGH] here's a trace of what Mergesortdoes and if you haven't studied a recursive program before it's worthwhilestudying this thing in, in some detail.<br><br>5. Now the firstalgorithm we studied goes back to 300 B.<br><br>6. My friend Philippe Flajolet who recently diedwas a famous French mathematician send me an e-mail late one night.<br><br>7. The other thing is that the lower bound isfor the particular model of computation being studied.<br><br>8. And as I mentioned, there's been many, many improved versions ofhashing that have been studied.<br>
saying|sentence cnt : 9 <br> <br>1. If we get to the bottom and our current nodeis null and that's falling off the bottom of the tree we return null and that'sequivalent to saying our buyer convention that, that key is not in our datastructure, or not in our symbol table.<br><br>2. But what's nice about data driven code is now that the code's workingand again we, we're not saying that this is a trivial code to write but it'sdefinitely manageable.<br><br>3. Really, what we're saying is when we go to the left link of H, it says, if G isin the tree, it has to be down this link.<br><br>4. So Lets suppose that there is no intersect, and that'sequivalent to saying, if there is no intersection in the left then there is nointersection in the right.<br><br>5. We have onestudent who was paying attention to what we're saying and uses an array and canpick the indices into that array at random check whether they're open and, andrepeat.<br><br>6. If it's not there, then we return null,saying the key's not there.<br><br>7. That's equivalent to saying, are they inthe same connective component? So that's some work, going to find the roots of eachitem but the union operation is very easy.<br><br>8. And if both particles are null we're saying wejust want to redraw things.<br>
calls|sentence cnt : 16 <br> <br>1. Because it would have N^2,calls to find, to check whether they're connected.<br><br>2. This gives exactly what happens duringeach of the calls to merge.<br><br>3. So that's a few callsto Union but that's easy to implement.<br><br>4. So, here's a clientthat calls our insertion sort method and all it does is read numbers from standardinput than into an array a then calls insertion sort and then prints them out.<br><br>5. In Java, there's an implicit mechanism that says that any such array ofobject is going to have the compareTo() method, then the sort function calls backthe compareTo() method associated with the objects in the array when it ever needs,whenever it needs to compare two items.<br><br>6.And then it calls the recursive method that takes as arguments the limits of thesubarray that's gonna be sorted.<br><br>7. So, this is so when we have the GCD function, computing thegreatest common denominator, greatest common denominator p and q is greatestcommon denominator of q and p mod q and it just calls itself until q gets to be zero.<br><br>8. And then we use our usual trick of returning the link that we went down to update the other links after the recursive calls.<br>
frame|sentence cnt : 2 <br> <br>1. Soa little Java [cough] code to provide this iteration facility but actually withinthis framework not too much to do and you can see how to implement this for your owndata type and we'll use this paradigm for every basic data type that we, thatinvolves collections of objects that we'll encounter.<br><br>2. The idea of complexity is it's a framework for studying the efficiency of all the algorithms for solving a particularproblem.<br>
contracted|sentence cnt : 1 <br> <br>1. And there was an example not that long ago, where atelephone company contracted with a database provider to build a database thatcould store customer information and the provider implemented the database usingred-black BSTs for search and insert.<br>
exceptional|sentence cnt : 6 <br> <br>1. So that now, we have our set ofexceptional words.<br><br>2. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>3. So the way we'll set that up is tothink about having a list of files a list of words in a file that are exceptional insome way.<br><br>4. And in yourexceptional list would be words that are in the dictionary.<br><br>5. And what we want to do isprint out all the occurrences of our exceptional words in our given file.<br><br>6. If it's not in theexceptional list, then we print it out.<br>
convenient|sentence cnt : 13 <br> <br>1. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>2. So we can,implement these, efficiently and they are, convenient and useful for the clients.<br><br>3. And if you give it toby section comparator, it will them in order by the second field very convenientfor all kinds of data processing applications.<br><br>4. So the way that it's convenient to set up a symbol table is to implement theso-called Associative array abstraction.<br><br>5. But we can also provide a lot of convenient functionalityfor the client that's what we are going to look at next.<br><br>6. But it definitely becomes inconvenient to manage large numbers of tombstones in highly dynamic situations with large numbers of keys and values.<br><br>7. What about, being able to iterate between, among all the keys between twogiven times? That, certainly is convenient.<br><br>8. And contains a simpler operation than get its convenient for manyclients where it just tells us whether there's some value paired with thatkey in the table is empty in size.<br>
interface|sentence cnt : 20 <br> <br>1. So, one thing is we're usinga different key interface.<br><br>2. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>3. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br><br>4. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br><br>5. Butalso, since it's the compare-to interface, and since it's a binary treerepresentation all the other comparable operations extended operations for orderedsymbol tables are going to be implemented and take time proportional to the log N.<br><br>6. Now if we're going to implement our owntype then we have to go ahead and implement the Comparable interfaceaccording to these rules.<br><br>7. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>8. Any uses of the resizing array,so many of the principles that we consider does also a, a link list interface.<br>
substantially|sentence cnt : 1 <br> <br>1. In this example what it tells us, what theorytells us is don't try to design a sorting algorithm that guarantees to usesubstantially for your compares than merge sort.<br>
personal|sentence cnt : 2 <br> <br>1. Well we invented this datastructure this way of looking at balance trees at, at Xerox PARC which was the homeof the personal computer and many other innovations that we live with todayentering graphic user interface and internet and object oriented programmingsand many other things.<br><br>2. On a personalnote, I wrote a research paper on this topic in 1979 with Leo Givas and wethought we pretty well understood these data structures at that time and peoplearound the world use them in implementing various different systems.<br>
landing|sentence cnt : 2 <br> <br>1. Perhaps you wouldn't want to usea resizing-array implementation at the moment that your plane's coming in fora landing.<br><br>2. Sothere is another thing about the uniform hashing assumption is that it is anassumption and if you are writing code where we have to have guaranteedperformance like when your aircraft is landing or you are controlling a nuclearreactor or somebody's pa cemaker.<br>
sword|sentence cnt : 2 <br> <br>1.That's a little implementation detail, but otherwise this is a fine swordimplementation, that actually is very little code, and its got a place in, inthe theory of algorithm, that I will talk about in a second.<br><br>2. Thistechnology is, is useful for storing passwords and digital fingerprints andthings.<br>
partitioned|sentence cnt : 3 <br> <br>1. So now 5 comes in, that's to the left of 4because it was partitioned at a vertical and 5's going to partitionin a horizontal.<br><br>2. Once we have the array partitioned in thatway, shown here in the middle.<br><br>3.Then the method calls the sort for the left subfile first, and then that's gonnabe partitioned on this e, and so forth.<br>
printed|sentence cnt : 1 <br> <br>1.And you can see on the right that the numbers are printed out in sorted order.<br>
imagine|sentence cnt : 4 <br> <br>1. So, you can imagine a creditcard company looking for fraud - it's going to care about keeping track of the largesttransactions.<br><br>2. So,you can imagine trying to look for a selection algorithm that takes timeproportional to n and also the lower bound is n because you have to look ateverything.<br><br>3.So you can imagine the implementations of priority queues using these two basicstrategies.<br><br>4. So you can imagine keeping the item, say, in a linked list or ina doubling array and just keeping just an order just as we would in the, in thestack just keeping in the way that they come in.<br>
creating|sentence cnt : 3 <br> <br>1. So, we start bycreating an empty set of strings, and again since we don't have associatedvalues, we just have the one generic for strings, and then create a new inputstream from, from the first argument so that's the name of the file that containsthe exceptional words and so this just reads the strings while the input stringis not empty and then adds the m to the set.<br><br>2. Creating new arrays on every operation.<br><br>3. Again, it's similar to the other one, we're creating a symbol table thatassociates strings with integers.<br>
bounce|sentence cnt : 3 <br> <br>1. They bounce off one another.<br><br>2. The Physics problem is exactly what happenswhen two balls hit and they bounce off each other according to somewell-understood physical process, and that's the high school Physics.<br><br>3. It's either redraw, bounce, B of A or, or bounce off avertical wall or, or a horizontal wall.<br>
little|sentence cnt : 93 <br> <br>1. A little bit of high school Physics and alittle bit of basic Computer Science.<br><br>2. So now it's alittle bit tricky the way that we implement it since we're using we use arecursive implementation.<br><br>3. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>4. But we have to use a little extra time andspace to deal with the links.<br><br>5. And in on the right we have to do a, a little bit of tricky codeto make sure that we return the floor on the right subtree, if there's some treethere.<br><br>6. And here's the implementation there's very little to itgiven the symbol table API that we've articulated and the implementations thatwe have.<br><br>7. We're gonna start with an overviewdiscussion of why you might want to study algorithms and a little bit of discussionabout the resources that you need to take this course.<br><br>8. So now,how do we implement rank? Well, it's a little like floor.<br>
alphabetical|sentence cnt : 3 <br> <br>1.text has the certain number of three letter words and this client program willresult in those three letter words being rearranged into alphabetical order.<br><br>2. Like theintegers or natural numbers or real numbers or alphabetical order for strings,chronological order for dates or times and so forth.<br><br>3. So[cough] here is just an example of what happens if would those implementedcomparators for that class student using the Java system sort, if you call arraythat sort with your a rray of students and you give it this by name comparator, itwill put them in order alphabetical order by the name field.<br>
exceptions|sentence cnt : 1 <br> <br>1. We have to probably to make bullet proof code -throw exceptions if a client tries to call next() with no items there and triesto call remove() at all, we're not going to support remove().<br>
addressing|sentence cnt : 3 <br> <br>1. We saw a few easy algorithms for solving theproblem, and quickly saw that they were inadequate for addressing huge problems.<br><br>2.Next we're going to consider addressinganother fundamental defect in the implementations we've considered so farthat those implementations are only good for strings.<br><br>3. With linear probing is called open addressing and isalso around the same time in the 50's the idea is just use an array.<br>
screen|sentence cnt : 2 <br> <br>1. One thing is, that you can traverse the convex hull by making only counterclockwise turns or left turns if you're looking at the screen here.<br><br>2.>> [inaudible] the large screen.<br>
bear|sentence cnt : 1 <br> <br>1. So, and we have to, bear inmind, as we're building our logarithms, that both the number of objects can behuge, but also, the number of operations.<br>
park|sentence cnt : 5 <br> <br>1. And he was able to show, and we'll talk just a little bitabout this, that if, there's, only half of the parking spaces are occupied, then, onaverage, half the people find, find it after one place and the other half have tolook one extra.<br><br>2. So, what happens is that you are on a one waystreet and you are looking for a parking place and, it's, the idea's you startlooking for a parking place at particular times and say "Okay, now I need a parkingplace", and what you're doing is linear probing hashing.<br><br>3. No way can you formulate theproblem as so called parking problem.<br><br>4. Then that modelsthe hash function, then how far do they have to go to look for a place? That'scanoot's parking problem.<br><br>5. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br>
attached|sentence cnt : 2 <br> <br>1. [cough] or in, in youknow, in the case when we're just inserting a new node and it's turns out tobe the right red link attached to a black one, if that handles that case.<br><br>2. So, that's adding a new node with a red linkat the bottom inserting that into whatever the two or three node it's attached to.<br>
implementing|sentence cnt : 31 <br> <br>1. And then again there's all, allkinds of difficulties in implementing convex hull in real world situationsbecause of various degeneracies.<br><br>2. Alright, so now let's look at the code for implementing Quick-union.<br><br>3. How do we, we do not implementing the API? The API says we should justbe able to create a stack and it should be able to grow andshrink to any size.<br><br>4.If you're interested in implementing this, you can come back to the slide.<br><br>5. And implementing that in code is really easy.<br><br>6. So how about implementing a hash code forour own type of data? And so our transaction type might have a couple of instance variables,a string, a date, and a double.<br><br>7. So that's a trace of implementing binarysearch to find the rank of a key in ordered array.<br><br>8. So that's a simple example ofimplementing a hash code for our own type of data that might include severaldifferent types of instance variables.<br>
argue|sentence cnt : 1 <br> <br>1. Nowusually we argue against why the interface is just adding operations to an interface,usually our reason for doing so is that we can't guarantee that all the operationscan be performing efficiently.<br>
invoke|sentence cnt : 6 <br> <br>1. And thenthe sort code can just use that compareTo() method, invoked in a sense of theobject like an entry in the array and as argument and another instance in theobject like another entry in the array to test whether the first is less than thesecond as in this example.<br><br>2.Arrays and then all you need todo is invoke Arrays.<br><br>3. Then, the less method will take that comparator asan argument and this is the one that actually invokes the method compare twodifferent keys.<br><br>4. To invoke arrays that sort,you have to import the name space from java.<br><br>5. But what we'll do is invoke a recursive method starting at the root andwhatever link gets returned, we'll set that to root.<br><br>6. So now we invoke the sink where we exchange that node with the larger of its two children until we find a place where it's larger than both of those children.<br>
added|sentence cnt : 16 <br> <br>1. That's the most recently added item.<br><br>2. For insert, we have a method calledpush that take a string as argument and for remove, we have a method, pop, thatreturns the string most recently added.<br><br>3. Then it'll put be on the top ofthe stack and then pop the top item on the stack which is now be, andthen pop the item most recently added.<br><br>4. And now we've added it to the heap by just incrementing in and putting it in there.<br><br>5. So, it will get added to, as the right link of A and every time weadd a node we just create a red link to its parents and so, that's changing thetwo node into a three node.<br><br>6. For queue,we examine the item least recently added.<br><br>7. We looked to the push downstack where we removed the item that was most recently added, And the queue where weremove the item that was least recently added.<br><br>8. For the stack, we take out the itemthat was most recently added.<br>
built|sentence cnt : 9 <br> <br>1. Now, built in to Java is the so-called the Comparableinterface and all the Comparable interface is the specification that a type, datatype that implements Comparable will have a compareTo() method.<br><br>2. So that's something that isa convention that's built into Java and that enables the hash code to be used forhashing.<br><br>3. So that's a binary search tree built, from thoseintervals.<br><br>4. So this isthe binary search tree that's built from those five intervals, six intervals in ourexample.<br><br>5. In the standard built-in types ofthe Java language we're going to have those customized implementations andwe can rely on them doing what we expect.<br><br>6. So hashing is widely used forsystems programming and applications, so some conventions forhashing are built into Java.<br><br>7. And then there's 2 referencesthat we built in our class node, 1 to a string and another 1 to a node andthose are each 8 bytes.<br><br>8. And that's built into java and alsosome classic algorithms depend on that.<br>
makes|sentence cnt : 17 <br> <br>1. So if a big blockof things comes into memory, there's no more extra costs, whereas Heapsort isgoing to look far away from the current place as it goes down the tree and thatmakes it slower in a lot of situations.<br><br>2. So, the weighted algorithm always makes sure that the smaller tree goesbelow.<br><br>3. Insert P, that goes to the right of M that makes M atemporary four node that happens to be balanced, so flip the colors.<br><br>4.Next we'll look at separate chaining, acollision red solution strategy that makes use of elementary link list.<br><br>5. And then that makes that temporarily overful.<br><br>6. And everytime we add an open site, we check to see if it makes the system percolate.<br><br>7. One more pass makes two subarrays of size eight, and the last passis just a sorted array.<br><br>8. Same kind of dynamic characteristicas selection sort, except, for every step, it's not just comparing, it's also exchanging,which makes it even slower in practice.<br>
codons|sentence cnt : 2 <br> <br>1.For example, here's another CSV file that from biology that deals with, amino acidsand codons and names.<br><br>2. And certain codons have names, that's theamino acids.<br>
broad|sentence cnt : 10 <br> <br>1. And the other reason is that we cansupport a broader set of simple table operations that are veryconvenient for many clients.<br><br>2. Where we could get guaranteedlogarithmic performance for a broad range of symbol table operations.<br><br>3. And the, the bottom lineis that if you randomize the order and use three-way partitioning then there's lot ofapplications where your sort routine is going to be linear not N log N so it willbe much more faster than Mergesort and you know, the methods for really a broad classof applications.<br><br>4. So, if they're going to be comparable,we might as well take advantage of it, both to get more efficient algorithms and to be able to take advantage ofa broader set of operations.<br><br>5. So, why should one study algorithms? Well, their input,impact is very broad and far-reaching.<br><br>6. So, that's one importantreason to study algorithms, their impact is broad and far-reaching.<br><br>7. So,why not just use those? Why use our own implementations? Well, the problem isoften in such library code is kind of designed by committee phenomenon that moreand more operations get added and the API becomes too broad or bloated.<br><br>8. Their impact's broad and far-reaching,they have old roots and present new opportunities, they allow us to solveproblems that could not otherwise be addressed, you can use them forintellectual stimulation to become a proficient programmer.<br>
anybody|sentence cnt : 2 <br> <br>1. And, and, anybody taking highschool Physics will, be able to deal with these formulas and the rest of this mayhave to go to a reference book to get up to speed on them.<br><br>2. For, anybody after that time doesn't get aticket.<br>
referring|sentence cnt : 1 <br> <br>1. So, during this course you'll be referring tothe book site frequently while working online.<br>
capability|sentence cnt : 5 <br> <br>1. And so that's a little extra code, and then you have to add the resizingcapability as well to implement the data structurethe same as for stack.<br><br>2. So again, a very general capability that'sgot lots and lots of applications and easy to implement withour symbol table api.<br><br>3. And we'll see later on, there's times when we want to expand the API and provide other operations like removing an arbitrary item from the priority queue, or give the client in the API the capability of changing the priority of an item.<br><br>4. So, we'll build a new priority queue, min priority queue or we'll havethe capability to delete the minimum.<br><br>5. There's many reason that immutable keys are that programming languages provide the capability to build immutable keys and this is a fine example of one.<br>
reduced|sentence cnt : 1 <br> <br>1. [cough] but once it'sreduced to code we can be, it might have some trouble debugging at first but atleast we can be convinced that it works.<br>
certainly|sentence cnt : 10 <br> <br>1.But it's, easy to see from demo and from the diagrams that those are going to beconstant, guaranteed logarithmic performance for all operations, which iscertainly what we want in a symbol table implementation Now what about theimplementation? Well, we're actually not going to talkabout a direct implementation of 2-3 trees, because it's kind of complicated.<br><br>2. It's certainly worth adding them.<br><br>3. And actually there is avalue as N gets large that if you're less than that value it almost certainly willnot percolate, if you're greater it almost certainly will.<br><br>4. And, quicksort certainly plays a role in most systemsorts.<br><br>5. So that's certainly somethingto be aware of when using hashing in practice.<br><br>6. All right, so, and certainly you want tofollow some of these best practices, so fields that are most likely to differ, those are the ones that youmight want to compare first.<br><br>7. What about, being able to iterate between, among all the keys between twogiven times? That, certainly is convenient.<br><br>8. Now, these are the things thathave to be proven and we're not going to get into the details of geometric proofbut they're intuitive and certainly have no trouble accepting that these things aretrue.<br>
checker|sentence cnt : 2 <br> <br>1. For example, you might have a spellchecker where you want to identifymisspelled words.<br><br>2. And that's just checker if anything happenedwith those two particles.<br>
dwell|sentence cnt : 1 <br> <br>1. We use the Java language, but we don'tdwell on details of Java, we mostly use it as an expository language.<br>
relationship|sentence cnt : 2 <br> <br>1. Bad programmers worryabout the code, good programmers worry about data structures, and theirrelationships.<br><br>2. And then with that, simple, relationship wecan use the exactly the code that we developed to go ahead and run a simulationfor this connectivity problem.<br>
will|sentence cnt : 121 <br> <br>1. But for certain applications we can get close to constant time for one or the other operations and that will be useful in different implementations.<br><br>2.It's in place we don't use any auxiliary array it's not stable, but its worst-caseguaranteed time is proportional to N lg N as well as the average and, and the bestthis is not a result but that's also the case so it's N lg N guarantee N place, butit's not stable, and we still have the hope that someday somebody will develop asimple in-place stable worst case N lg N algorithm but we're not quite there yet.<br><br>3. And then what thismethod will do is go through and merge those little subarrays of size onetogether in pairs to get subarrays of size two.<br><br>4. And it turns out to be very close to a generic algorithmic design techniquethat we will be looking at in many, many different applications.<br><br>5. Sotypically for ordered simple tables, when keys are comparable will provide a muchwider interface it's very useful for many clients.<br><br>6. So to begin, we will talk about stacks.<br><br>7. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>8. The key point is that the sort implementation has nodependence on the type of data that's handled by the Comparable interface and adifferent Comparable array will be sorted in the same way though eventually, becauseof the interface mechanism, they call back to the actual compareTo() code that goeswith a type of object being sorted.<br>
circle|sentence cnt : 2 <br> <br>1. For example,if they're all arranged in a circle and your query point's in the center orsomething of that sort.<br><br>2. With geometric data,the worse case can be bad, so like all the points couldbe arranged in a circle.<br>
computational|sentence cnt : 16 <br> <br>1.So, there are number of implementation challenges for the Graham Scan and we'renot going to go into detail on this because this is a lecture on sortingalgorithms not computational geometry but it is indicative of how, even if we have agood sort, we might have to do some extra work to actually solve our problem in anapplication.<br><br>2.So [cough] this is if we implement a point data type for computational geometry, youcan have a method ccw() that just with this little math calculation (b.<br><br>3.Because if we have a computational process that takes quadratic time, then it's notgoing to scale, we're not going to be able to do large number of particles.<br><br>4. And these methods are all widely used throughout ourcomputational infrastructure.<br><br>5. Computational complexity isvery useful way to help us understand properties of algorithm and help guide ourdesign decisions.<br><br>6. That's a Monte Carlo simulation, a computational problemthat gives us a solution to this, scientifc problem where, mathematicalproblems nobody knows how to solve yet.<br><br>7.Algorithms are computational models, and algorithmic models are replacingmathematical models in scientific inquiry.<br><br>8. So, there's degeneracies to deal with and floatingpoint precision but people, researchers in computational geometry have worked thisout and actually there's not that much code at all in the end involved.<br>
hopcroft|sentence cnt : 1 <br> <br>1. And what was provedby Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of Munion and find operations will touch the array at most a c (N + M lg star N) times.<br>
rectangle|sentence cnt : 38 <br> <br>1. Particularly, think aboutthe rectangle being small, it's going to be not that different thana regular search in a binary search tree.<br><br>2. But now we're going to use that forintersecting rectangles rather than using range search as our basic operation, we'regoing to use interval search.<br><br>3. And, and that willgive us now three rectangles on our sweep line.<br><br>4. But now,maybe a year and a half later, you have a computer that's two times faster but youalso want to build a bigger computer so you have twice as many rectangles tocheck.<br><br>5. And so now, the question is when wehit a, a new rectangle, we want to do an interval search to, if we're at the leftto check which ones intersect and the interval search tree algorithm is going totell us which intersections there are right away.<br><br>6. And you mightwanna ask, which points are inside the rectangle or how many points are insidethe rectangle? Or maybe what you are processing is rectangles.<br><br>7. And we want to be able to find orcount the points in a given rectangle.<br><br>8. And while the nearest neighbor can't be, we don't have to go down the right subtreeat 6 because you can't have a point in that rectangle that's closerto the query point than 3.<br>
selection|sentence cnt : 46 <br> <br>1. Selection sort is going to use quadratic time because it always has to gothrough the whole thing to look for the minimum.<br><br>2. Well then, maybe somebody in this class will invent that but untilsomething like that is discovered use the quick select based on Quicksortpartitioning you can get linear time selection when you don't need a full sort.<br><br>3. So, from these observations it's clear that what we, whatwe'd like is a selection algorithm that takes linear time.<br><br>4. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>5. That's the a Quicksort like implementationsolving the selection problem.<br><br>6. Now it's easy to develop on mathematical model for the costof selection sort and here's the proposition that describes that.<br><br>7. Now, if the array is partiallysorted, it doesn't matter to selection sort.<br><br>8. So, the basicselection sort method is to, in the ith iteration, find the smallest remainingentry and to the right of i or bigger index than i and then swap that with i.<br>
highest|sentence cnt : 3 <br> <br>1. If you do the, actuallyit doesn't cut it in half at exactly each time only on average so you need a fulleranalysis like the one we did for Quicksort and the bottom line of that analysis givesthe number of comparisons required as a function of n and of k in terms of thisformula here and if you plug in k = n/2, you get the result that the number ofcompares required to fine the median that's the highest value this formula cantake is two + two natural log of two.<br><br>2. And then fromthat, you can figure out how many keys there are or return them all between theindex, the lowest one in the range, index the highest one in the range.<br><br>3. And so that one is going to reada sequence of strings from standard input and print out the one thatoccurs with highest frequency.<br>
vacated|sentence cnt : 1 <br> <br>1. Now, in this case, to implement delete max we save away that value at the root in max, and we eliminate loitering by nulling out that vacated position, then return the max value.<br>
construct|sentence cnt : 25 <br> <br>1.Now let's look at constructing a 2-3 tree from an initially empty tree.<br><br>2. The constructor has to create the array and then go through andset the value corresponding to each index I to I.<br><br>3.So let's start with the constructor, well we have a, a private integer array.<br><br>4. The construction, actually,it turns out although it's a little more complicated to prove, that it always usesjust a linear number of comparison exchanges.<br><br>5. We have a constructor tocreate an empty stack.<br><br>6. It's a class, the constructor doesn't haveto do anything, there's no constructor.<br><br>7. It moves keys pastother keys that could be equal and so its easy to construct examples showing thatSelection Sort is not stable.<br><br>8. This is areal landmark in the theoryof algorithms because for a long time, it's not known, we knew we could have theaverage case, the linear time but could we find a worst case? And this paper foundsuch a construction.<br>
handling|sentence cnt : 1 <br> <br>1. The implementation could hardly be morestraightforward and it's an excellent way to solve the problem of handling multipletypes of data with one implementation.<br>
allowed|sentence cnt : 5 <br> <br>1. Now, in other situations,maybe they're not comparable and all we're allowed to use isto use the equals operations.<br><br>2. The operations that thealgorithms are allowed to perform.<br><br>3. And so people that were usingquadratic algorithms were definitely held back and, it was, Ed, Ed McCreight atXerox Park who, discovered interval search trees and the logarithmic algorithm thatallowed us to sustain Moore's law and keep building bigger and bigger computers.<br><br>4. And that'ssomething that's not allowed.<br><br>5. Again, wejust had a red link and now we have a BST with two red links along the pathconnected to A and that's not allowed.<br>
lines|sentence cnt : 18 <br> <br>1. And it'sessentially based on the idea of computing the slopes of the lines between a and b,between a and c and comparing them to decide whether you're turning counterclockwise or clockwise.<br><br>2. And again, as we know,such an algorithm is not going to be practical, for huge numbers of linesegments.<br><br>3. And so, people, to design new computers,would, make huge drawings that just showed the lines that corresponded to thematerials that had to be created to make the computer.<br><br>4.You, you can't have [cough] lines that come too close to other lines, certaintypes of lines can't intersect.<br><br>5.So, any point that's inside that interval, is going to represent a horizontal linesegment that is an intersection.<br><br>6. So, it's called the orthogonal line segment, segment intersection searchwhere the lines segments or constrained to be either horizontal or vertical.<br><br>7. So, in this case there's fourplaces where these lines intersect.<br><br>8. We don't haveany, any equal lines that we have to worry about whether we consider rectangles thattouch to be intersecting, and so forth.<br>
hibbard|sentence cnt : 9 <br> <br>1. And that's the basis for a general method for deleting nodes from BSTs known as Hibbard deletion.<br><br>2. That's Hibbard deletion.<br><br>3. Actually not that much code is complicated, but not particularly more complicated than other code we've seen like rank, and floor, and ceiling, and that implements Hibbard deletion.<br><br>4. So, what they did in this implementation was theyjust put in regular Hibbard deletion in the binary search in the red-black BST.<br><br>5. This is the code for Hibbard deletion.<br><br>6. And there was a lawsuit and some legal testimony andI am happy to report that, that it was clear that Hibbard deletion was theproblem once the expert analyzed it and the expert witness, who's a colleague ofmine, said if implemented properly, the height of a red-black BST with N keys isat most two log N.<br><br>7. And the problem is and this was quite a surprise when it was first discovered, actually many years after Hibbard proposed the algorithm is this lack of symmetry tends to lead to difficulties and here we're just inserting the leading alternating, in certain delete a random key, so that maybe well models a situation or practical situation.<br><br>8. The first case for Hibbard deletion is what we want to do to delete a node with key case.<br>
inversion|sentence cnt : 6 <br> <br>1. And we define an array to bepartially sorted if its number of inversions is linear,if it's less than some constant times N.<br><br>2. And the proof is, the number ofcomparisons and the number of exchanges is equal to the number of exchanges equalto the number of inversions, and there's an extra compare forevery element except the first.<br><br>3. This array has six inversions.<br><br>4. So this array has six inversions, T and R are out of order,because R should go before T.<br><br>5. To talk about this in a quantitative way,we define what's called an inversion.<br><br>6. An inversion is just a pair of keysthat are out of order in the array.<br>
enable|sentence cnt : 16 <br> <br>1. So that's something that isa convention that's built into Java and that enables the hash code to be used forhashing.<br><br>2. But with a geometric algorithm likea 3d-tree you could get the time to n log n that enabled all sortsof new scientific investigation in this example of the use ofalgorithms to enable new research.<br><br>3. Next we're going to talkabout Binary Search Trees, a classic data structures that'll enables us to provideefficient implementation of symbol table and out rhythms.<br><br>4. Now the thing about assertions in Java is that you can enable or disable them atruntime.<br><br>5. This, this kind of stimulation is enabledby priority queues.<br><br>6. So this is a useful and non trivialclient that's enabled by symbol table.<br><br>7. But weighted quick union withpath compression in practice is, is close enough that it's going to enable thesolution of huge problems.<br><br>8. Again, this is a modularprogramming style that's enabled by object oriented programming languages,such as Java.<br>
highlighted|sentence cnt : 1 <br> <br>1. So, what we wouldlike to do is just declare a new array using our generic name Item as in thehighlighted line here.<br>
gracefully|sentence cnt : 2 <br> <br>1. Separate chaining is reallyeasy to implement both insert and delete it performs, it degrades, it does sogracefully and the clustering is, is maybe less of a problem if you have a bad hashfunction.<br><br>2. So we need a data-structurethat more gracefully adapts to the distribution of the data.<br>
denote|sentence cnt : 1 <br> <br>1. If we're sorting N items then let C of Ndenote the number of compares that we need tosort the N items.<br>
occurred|sentence cnt : 1 <br> <br>1. And it might have occurred to you while we are looking at thesealgorithms.<br>
appoint|sentence cnt : 1 <br> <br>1. And these are just conventions and some are details but it's importantto appoint them all at front.<br>
wonder|sentence cnt : 1 <br> <br>1. Like these are all the ones associatedwith this, lecture, so we might build an indexfrom that set of files, and then we might wonder well where do we use the importstatements.<br>
doing|sentence cnt : 59 <br> <br>1. It seems like a lot of baggage tocarry around and the reason that we do it, why do we go to the trouble doing it isthat we can, if we have a data structure that's iterable we can use a very compactand elegant client code in Java, the so called for-each statement.<br><br>2. Very instructive to study this trace to really understand what this recursivealgorithm is doing.<br><br>3. Essentially terminate the length of the [inaudible]list that we have to search through when we're doing a insertion.<br><br>4.Simulations in the real world, usually, we wind up doing huge amounts of data and wecannot have a quadratic algorithm.<br><br>5. You can, limit the depth of recursion byalways doing the smaller sub-array before the larger sub-array.<br><br>6. We just during the insertion, make sure that we, we [cough] maintain theproperties the balance properties and by doing that, we wind up with balance treesand we make all the operations quick and we don't have to re-implement, we don'thave to change it at all.<br><br>7. But then,when we're doing selection, what we'll do is just go in one sub array or the otherdepending on where j is.<br><br>8. So, we start with this sort example and then 7-sortingit - just involves doing insertion sort but just reaching back7 each time.<br>
associating|sentence cnt : 5 <br> <br>1. When we insert a new node all we want to do is create a newnode with the, I've given, associating the given value with a given key, as beforebut now we just make that node red.<br><br>2. That's building a symbol table associatingkeys with sets of files.<br><br>3. And the idea behind that is to think aboutjust associating one value with each key.<br><br>4. So this creates a new symbol table associating string keys with sets offiles.<br><br>5. But we're only associatingone value with each index.<br>
spotlight|sentence cnt : 1 <br> <br>1. so, with the, more [COUGH] complex userinterface, this is, very much what the spotlight or find functionon your computer is doing.<br>
eight|sentence cnt : 74 <br> <br>1. And then we do the same thing on theright, and eventually we have two eights that wemerge together to get the final result.<br><br>2. The property of a complete tree is at the height of a complete tree with N nodes is the biggest integer less than log base 2 of N.<br><br>3. And three, four, eight, and nine all have entry eight.<br><br>4. Well no, the maximum,end point in the left node is eight.<br><br>5. All have entries eight.<br><br>6.Not the deletion algorithm that's guaranteed to keep the constant blackheight all the time.<br><br>7. Then, the whole array consistsof sorted subarrays to size two, and then we make another pass through to getsize four, and then size eight, and so forth.<br><br>8. Nine and four, So now four is the root of the tree containing four is eight.<br>
wasting|sentence cnt : 1 <br> <br>1. A good algorithm is much more effectivethan spending money or time wasting money or time usinga bad one.<br>
indexed|sentence cnt : 1 <br> <br>1. The datastructure that we're going to use to support the algorithm is simply an integerarray indexed by object.<br>
sweeping|sentence cnt : 1 <br> <br>1. Sosweeping from left to right means we consider each x coordinate as an event.<br>
interfaces|sentence cnt : 1 <br> <br>1. For Java, because of the desireto check types at compile time, the use of specific method called an interface andthen, we'll look at the details of how to implement callbacks with the Javainterfaces now.<br>
